---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__16" h2Title="Proto y herencia" slot="mainContent">
    <ChaptrSect h3Title="Herencia prototipica" codeText="">
      <ChaptrSubSect h4Title="Asignar prototipo con" codeText="[[Prototype]]">
        <p class="chaptrSubSect__p">El <code>[[Prototype]]</code> es una referencia interna que cada objeto en JavaScript tiene hacia otro objeto, llamado su "prototipo". Es un enlace que permite que un objeto pueda acceder a las propiedades y métodos de su prototipo si no los encuentra en sí mismo</p>
        <p class="chaptrSubSect__p">En la práctica, puedes acceder a este prototipo utilizando la propiedad <code>__proto__</code> (aunque <mark>no es recomendable</mark> para uso en producción, y deberías preferir el uso de métodos como <code>Object.getPrototypeOf()</code> o <code>Object.create()</code>)</p>
        <pre class="chaptrSubSect__console wScript">
          const çdog = &#123;
            hasVacune: true,
            @bark()&#123;
                console.log('/º Guau! Guau! º/');
              &#125;
          &#125;;

          const ·myDog = &#123;
            breed: 'BullTerrier'
          &#125;;
        
          /* Enlazamos el prototipo de "myDog" con "dog" */
          ·myDog.__proto__ = çdog;

          console.log(·myDog.•hasVacune);
          ⋗ ∞true                     /* heredado de dog */

          ·dog.@bark();
          ⋗ /º 'Guau! Guau! º/        /* heredado de dog*/</pre>
        <p class="chaptrSubSect__p">Todos los objetos en JavaScript pueden tener un prototipo, y estos prototipos son simplemente otros objetos. De hecho, todos los objetos tienen un prototipo, excepto el objeto más alto en la cadena de herencia: <code>Object.prototype</code>, cuyo prototipo es <code>null</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çfelino = &#123;
            hunt: true,
          &#125;;

          const çlion = &#123;
            __proto__: çfelino,
            @purr()&#123;
                console.log('/º mrrr mrrrr º/');
              &#125;
          &#125;;

          const çcat = &#123;
            __proto__: çlion,
            @maulla()&#123;
                console.log('/º miau miau º/');
              &#125;
          &#125;;

          console.log(çcat.•hunt);
          ⋗ ∞true                     /* heredado de felino */

          çcat.@purr();
          ⋗ /º 'mrrr mrrrr' º/        /* heredado de lion */
        
          çcat.@maulla();
          ⋗ /º 'miau miau' º/         /* propio de cat */</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Asignar prototipo con" codeText="Object.create()">
        <p class="chaptrSubSect__p">Permite la creación de objetos con prototipos específicos sin la necesidad de definir un constructor, y no requiere la creación de una función constructora. Es el método <mark>recomendado</mark></p>
        <pre class="chaptrSubSect__console wScript">
          const çfelino = &#123;
            hunt: true,
          &#125;;

          /* Creamos el objeto cat con felino como prototipo */
          const çcat = Object.ªcreate(çfelino);

          console.log(çcat.•hunt);
          ⋗ ∞true                     /* heredado de felino */</pre>
        <p class="chaptrSubSect__p"><code>Object.create()</code> es más potente, tiene un segundo argumento opcional: los descriptores de propiedad, que te permite definir las propiedades del nuevo objeto con control total sobre sus características (<code>value</code>, <code>writable</code>, <code>enumerable</code>, <code>configurable</code>)</p>
        <pre class="chaptrSubSect__console wScript">
          const çfelino = &#123;
            hunt: true,
          &#125;;

          /* Creamos el objeto cat con felino como prototipo */
          const çcat = Object.ªcreate(çfelino, &#123;
            domesticable: &#123;
              value: true,
              writable: false,
              enumerable: true,
              configurable: false,
            &#125;,
          &#125;);

          console.log(çcat.•hunt);
          ⋗ ∞true                     /* heredado de felino */
          console.log(çcat.•domesticable);
          ⋗ ∞true                     /* propio de cat */

          console.log(Object.•getOwnPropertyDescriptor(çcat, 'domesticable'));
          ⋗ /º &#123;value: true, writable: false, enumerable: true, configurable: false&#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Asignar prototipo con Contructor y " codeText="new">
        <p class="chaptrSubSect__p">Esta forma de crear objetos permite encapsular la lógica de inicialización dentro de una función constructora. Cada vez que se usa el operador <code>new</code>, se crea un nuevo objeto cuyo prototipo es <code>Constructor.prototype</code>, y la función se ejecuta para inicializar sus propiedades.</p>
        <pre class="chaptrSubSect__console wScript">
          function çAnimal() &#123;
            this.•eat = true;
            this.•sleep = @function() &#123;
              console.log('zzzzzzzz');
            &#125;;
          &#125;

          /*/º Creamos un nuevo objeto con Animal.prototype como prototipo º/*/
          const çrabbit = new çAnimal();

          /* Verificamos las propiedades del nuevo objeto */
          console.log(çrabbit.•eat);
          ⋗ /º true º/
          çrabbit.ªsleep();
          ⋗ /º 'zzzzzzzz' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Asignar prototipo con función y " codeText="prototype">
        <p class="chaptrSubSect__p">Esta es la forma tradicional de establecer prototipos en JavaScript. Cada función tiene una propiedad especial llamada <code>prototype</code>, que se utiliza cuando se crean objetos con el operador <code>new</code>. El objeto creado tendrá su <code>[[Prototype]]</code> apuntando al valor de esa propiedad. Aunque hoy en día se prefiere usar <code>class</code> o <code>Object.create()</code>, este método sigue siendo importante porque es la base del sistema de herencia en JavaScript</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos el objeto prototipo */
          const çanimal = &#123;
            pulmones: true,
            sleepNoise: @function() &#123;
              console.log('zzzzzzzz');
            &#125;,
          &#125;;

          /* Creamos la función constructora */
          function çRabbit(#color) &#123;
            this.•color = #color;
          &#125;

          /* Creamos un nuevo objeto que hereda de animal */
          çRabbit.•prototype = Object.ªcreate(çanimal);

          /* Restauramos el constructor */
          çRabbit.•prototype.constructor = çRabbit;

          /* Creamos una nueva instancia */
          const çrabbit = new çRabbit('Blanco');

          /* Verificamos las propiedades del nuevo objeto */
          console.log(çrabbit.•pulmones);   ⋗ ∞true              /* heredado de animal */
          console.log(çrabbit.•color);    ⋗ /º 'Blanco' º/            /* propio de rabbit */
          çrabbit.ªsleepNoise();    ⋗ /º 'zzzzzzzz' º/              /* heredado de animal */
        
          /* Verificamos la cadena de prototipos */
          console.log(çrabbit.__proto__ === çRabbit.•prototype);    ⋗ ∞true
          console.log(çRabbit.•prototype.__proto__ === çanimal);    ⋗ ∞true
          console.log(çanimal.__proto__ === Object.•prototype);   ⋗ ∞true
          console.log(Object.•prototype.__proto__ === null);      ⋗ ∞true

          /* Verificamos el cnstructor */
          console.log(çrabbit.constructor === çRabbit);   ⋗ ∞true</pre>
          <p class="chaptrSubSect__p">La cadena de prototipos quedaría así</p>
          <pre class="chaptrSubSect__console wScript">
            çrabbit --&gt; çRabbit.•prototype --&gt; çanimal --&gt; Object.•prototype --&gt; null</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Asignar prototipo con clases" codeText="">
        <p class="chaptrSubSect__p">Forma <mark>más clara y legible</mark> de trabajar con prototipos a partir de ECMAScript6</p>
        <pre class="chaptrSubSect__console wScript">
          /* Definimos la clase Animal */
          class çAnimal &#123;
            constructor(#nombre) &#123;
              this.•nombre = #nombre;
            &#125;
            @sound() &#123;
              console.log('/º Algún sonido... º/');
            &#125;
          &#125;

          /* Definimos la clase Dog que extiende de Animal */
          class çDog ¬extends çAnimal &#123;
            constructor(#nombre, #raza) &#123;
              @super(#nombre);
              this.•raza = #raza;
            &#125;
            @sound() &#123;
              console.log('/º Guau! º/');
            &#125;
          &#125;

          /* Creamos una nueva instancia */
          const çmyDog = new çDog('Max', 'Bulldog');

          /* Verificamos las propiedades */
          console.log(çmyDog.•nombre);    ⋗ /º 'Max' º/          /* propio de Dog */
          console.log(çmyDog.•raza);    ⋗ /º 'Bulldog' º/       /* propio de Dog */
          çmyDog.ªsound();    ⋗ /º "Guau!" º/              /* propio de Dog */</pre>
        <p class="chaptrSubSect__p">Internamente ocurre esto</p>
        <pre class="chaptrSubSect__console wScript">
          çRabbit.•prototype.__proto__ === çAnimal.•prototype;  ⋗ /º true º/</pre>
        <p class="chaptrSubSect__p">La cadena de prototipos quedaría así</p>
        <pre class="chaptrSubSect__console wScript">
          çrabbit --&gt; çRabbit.•prototype --&gt; çAnimal.•prototype --&gt; Object.•prototype --&gt; null</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Info de propiedades heredadas con" codeText="hasOwn()">
        <p class="chaptrSubSect__p">Este método verifica si una propiedad pertenece directamente al objeto (no heredada de su prototipo), de forma más clara y moderna que <code>obj.hasOwnProperty()</code></p>
        <pre class="chaptrSubSect__console wScript">
          /* Definimos la clase Animal */
          class çAnimal &#123;
            constructor(#nombre) &#123;
              this.•nombre = #nombre;
            &#125;
            @sound() &#123;
              console.log('/º Algún sonido... º/');
            &#125;
          &#125;

          /* Definimos la clase Dog que extiende de Animal */
          class çDog ¬extends çAnimal &#123;
            constructor(#nombre, #raza) &#123;
              @super(#nombre);
              this.•raza = #raza;
            &#125;
            @sound() &#123;
              console.log('/º Guau! º/');
            &#125;
          &#125;

          /* Creamos una nueva instancia */
          const çmyDog = new çDog('Max', 'Bulldog');

          /* Verificamos las propiedades */
          console.log(Object.ªhasOwn(çmyDog, 'nombre'));        ⋗ ∞true
          console.log(Object.ªhasOwn(çmyDog, 'raza'));          ⋗ ∞true
          console.log(Object.ªhasOwn(çmyDog, 'sound'));         ⋗ ∞false
          console.log('sound' ¬in çmyDog);                          ⋗ ∞true</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Crear instancias con constructor y" codeText="prototype">
        <p class="chaptrSubSect__p">Toda función en JavaScript tiene una propiedad llamada <code>prototype</code>, en la que por defecto trae una única propiedad llamada <code>constructor</code> que apunta a la función misma. Esto permite crear nuevas instancias del mismo tipo de un objeto ya existente, sin necesidad de saber explícitamente cuál era el constructor original</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos la función constructora */
          function çAnimal() &#123;
            this.•pulmones = true;
            this.•sleep = @function() &#123;
              console.log('zzzzzzzz');
            &#125;;
          &#125;

          /* Creamos una instancia de Animal */
          const çrabbit = new çAnimal();

          /* Añadimos una propiedad a la nueva instancia */
          çrabbit.•color = 'Blanco';

          /* Creamos otra instancia a partir del constructor de rabbit */
          const çoldRabbit = new çrabbit.constructor();

          /* Añadimos una propiedad a la nueva instancia */
          çoldRabbit.•color = 'Gris';

          /* Verificamos las instancias creadas */
          console.log(çrabbit);
          ⋗ /º Animal &#123; pulmones: true, color: 'Blanco', sleep: ƒ &#125; º/

          console.log(çoldRabbit);
          ⋗ /º Animal &#123; pulmones: true, color: 'Gris', sleep: ƒ &#125; º/</pre>
        <p class="chaptrSubSect__p">Por qué no se crea directamente la nueva instancia desde <code>Animal</code>  usando <code>new Animal()</code>? Cuando se ejecuta</p>
        <pre class="chaptrSubSect__console wScript">
          const çoldRabbit = new çrabbit.constructor();</pre>
        <p class="chaptrSubSect__p">JavaScript usa el constructor asociado al objeto <code>rabbit</code>. 
        Dado que <code>rabbit</code> fue creado con <code>Animal</code>, su propiedad constructor apunta a la función <code>Animal</code></p>
        <pre class="chaptrSubSect__console wScript">
          çrabbit.constructor === çAnimal;      ⋗ ∞true</pre>
        <p class="chaptrSubSect__p">Por lo tanto, <code>new rabbit.constructor()</code> equivale funcionalmente a <code>new Animal()</code>. Sin embargo, usar <code>rabbit.constructor</code> tiene una ventaja importante</p>
        <p class="chaptrSubSect__p">Permite crear una nueva instancia del mismo tipo que el objeto original, incluso si el constructor cambia más adelante. Esto hace el código más genérico y flexible, especialmente cuando trabajamos con herencia o con constructores personalizados.</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Aclaraciones" codeText="">
        <p class="chaptrSubSect__p"><code>.__proto__</code></p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Es una propiedad interna que tienen todos los objetos (excepto los creados con <code>Object.create(null)</code>).</li>
          <li class="chaptrSubSectUl__li">Esta propiedad apunta al prototipo <code>prototype</code> del constructor que se usó para crear ese objeto</li>
          <li class="chaptrSubSectUl__li">Forma parte de la cadena de herencia prototípica, que permite a las instancias acceder a métodos y propiedades heredadas.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          çobj.__proto__ === çConstructor.•prototype;      ⋗ ∞true</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">⚠️ Aunque <code>__proto__</code> sigue existiendo y es útil para aprendizaje o depuración, <b>no se recomienda usarlo en producción</b> . En su lugar, usa los métodos oficiales: <code>Object.getPrototypeOf(obj)</code> y <code>Object.setPrototypeOf(obj, proto)</code></li>
        </ul>
        <p class="chaptrSubSect__p"><code>.prototype</code></p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Es una propiedad de las funciones constructoras es decir, las funciones usadas para crear objetos con <code>new</code>.</li>
          <li class="chaptrSubSectUl__li">Contiene los métodos y propiedades que serán heredados por las instancias creadas con new.</li>
          <li class="chaptrSubSectUl__li">Las instancias acceden a esas propiedades a través de la cadena de prototipos (<code>__proto__</code>).</li>
        </ul>
        <p class="chaptrSubSect__p">Relación entre <code>__proto__</code> y <code>.prototype</code></p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos la función constructora */
          function çAnimal(#name) &#123; 
            this.•name = #name;
          &#125;

          /* Añadimos un método al prototipo de Animal */
          çAnimal.•prototype.•bark = @function() &#123;
            console.log(`/º $&#123;this.name&#125; dice guau! º/`);
          &#125;;

          /* Creamos una instancia */
          const çdog = new çAnimal('Max');

          /* Analizamos */
          console.log(çdog.__proto__);       ⋗ /º &#123; bark: ƒ &#125; º/
          console.log(çAnimal.•prototype);    ⋗ /º &#123; bark: ƒ &#125; º/

          console.log(çdog.__proto__ === çAnimal.•prototype);      ⋗ ∞true

          /* dog hereda el método bark desde el prototipo */
          çdog.ªbark();         ⋗ /º "Max dice guau!" º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Métodos modernos para configurar prototipo" codeText="">
        <p class="chaptrSubSect__p">Obtiene el prototipo de un objeto con <code>Object.getPrototypeOf()</code>. Este método es la alternativa moderna y segura a <code>rabbit.__proto__</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çanimal = &#123;
            eat: true,
            @sleep() &#123;
              console.log('zzzzzzzz');
            &#125;
          &#125;;

          /* Creamos un nuevo objeto y le asignamos el prototipo animal */
          const çrabbit = Object.ªcreate(çanimal);

          /* Verificamos cual es su prototipo */
          console.log(Object.ªgetPrototypeOf(çrabbit));
          ⋗ /º &#123; eat: true, sleep: ƒ &#125; º/

          /*/º Comparamos con el objeto animal (su prototipo) º/*/
          console.log(Object.ªgetPrototypeOf(çrabbit) === çanimal);
          ⋗ /º true º/</pre>
        <p class="chaptrSubSect__p">Establece el prototipo de un objeto con <code>Object.setPrototypeOf()</code></p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos el objeto prototipo 1 */
          const çanimal = &#123;
            eat: true,
          &#125;;

          /* Creamos el objeto prototipo 2 */
          const çalien = &#123;
            eat: false,
          &#125;;

          /* Creamos una nueva instancia con Animal como prototipo */
          const çrabbit = Object.ªcreate(çanimal);

          /* Verificamos la propiedad del prototipo actual */
          console.log(çrabbit.•eat);      ⋗ ∞true
          console.log(Object.ªgetPrototypeOf(çrabbit) === çanimal);      ⋗ ∞true

          /* Establecemos un nuevo prototipo */
          Object.ªsetPrototypeOf(çrabbit, çalien);

          /* Verificamos la propiedad después del cambio */
          console.log(çrabbit.•eat);        ⋗ ∞false
          console.log(Object.ªgetPrototypeOf(çrabbit) === çalien);        ⋗ ∞true
          </pre>
        <p class="chaptrSubSect__p">Ambos sustituyen el uso directo de <code>__proto__</code>, que aunque sigue existiendo, <b>no se recomienda</b> usarlo en producción</p>
        <p class="chaptrSubSect__p">⚠️ Aunque <code>Object.setPrototypeOf()</code> es muy útil, no debe usarse frecuentemente en código que se ejecute muchas veces (por ejemplo, dentro de bucles o funciones críticas). Modificar el prototipo dinámicamente en tiempo de ejecución puede afectar el rendimiento del motor JavaScript, ya que invalida ciertas optimizaciones internas</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Crear objeto vacio sin prototipo" codeText="">
        <p class="chaptrSubSect__p">En JavaScript, todos los objetos (por defecto) heredan propiedades y métodos de <code>Object.prototype</code>. Esto incluye métodos como</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><code>hasOwnProperty()</code>.</li>
          <li class="chaptrSubSectUl__li"><code>toString()</code>.</li>
          <li class="chaptrSubSectUl__li"><code>valueOf()</code>.</li>
          <li class="chaptrSubSectUl__li"><code>constructor</code>.</li>
          <li class="chaptrSubSectUl__li"><code>__proto__</code>.</li>
          <li class="chaptrSubSectUl__li"><code>isPrototypeOf()</code>.</li>
          <li class="chaptrSubSectUl__li"><code>propertyIsEnumerable()</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Sin embargo, a veces puede ser útil crear un objeto totalmente limpio, sin heredar nada. Para ello se usa</p>
        <pre class="chaptrSubSect__console wScript">
          const çemptyObject = Object.ªcreate(null);

          console.log(çemptyObject); ⋗ /º &#123;&#125; º/
          console.log(Object.ªgetPrototypeOf(çemptyObject)); ⋗ ∞null</pre>
        <p class="chaptrSubSect__p">⚠️ Precaución: Un objeto sin prototipo puede romper funciones o librerías que asumen la existencia de métodos como <code>hasOwnProperty()</code></p>
        <pre class="chaptrSubSect__console wScript">
          /* Objeto normal */
          const çnormal = &#123;&#125;;
          console.log(çnormal.toString());         ⋗ /º "[object Object]" º/

          /* Objeto sin prototipo */
          const çempty = Object.ªcreate(null);
          console.log(çempty.toString);        ⋗ ∞undefined

          /* Verificamos su prototipo */
          console.log(Object.ªgetPrototypeOf(çempty));        ⋗ ∞null
          console.log(Object.ªgetPrototypeOf(çnormal));         ⋗ /º &#123; ... &#125; (Object.prototype) º/
        </pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_15" nextPage="/lessons/lesson_17"/>
</MainLayout>



<!-- 
&lt;&gt;
()&#123;&#125;
﹛﹜    Llaves no estiladas
﹕     2 puntos no estilizados
ªmétodos
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ ∞Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">
＃
-->
