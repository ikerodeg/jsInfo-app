---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__30" h2Title="MÃ³dulos" slot="mainContent">
    <ChaptrSect h3Title="IntroducciÃ³n" codeText="">
      <ChaptrSubSect h4Title="DefiniciÃ³n" codeText="">
        <p class="chaptrSubSect__p">Un mÃ³dulo es simplemente un archivo. Un script es un mÃ³dulo. Los mÃ³dulos pueden cargarse entre sÃ­ y usar directivas especiales <code>export</code> e <code>import</code> para intercambiar funcionalidad, llamar a funciones de un mÃ³dulo de otro</p>
        <p class="chaptrSubSect__p">âš ï¸ Los mÃ³dulos usan "modo estricto" por defecto (<code>"use strict"</code> implÃ­cito) y tienen su propio scope (las variables no van a window)</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><code>export</code> etiqueta las variables y funciones que necesitan ser accesibles desde fuera del mÃ³dulo actual.</li>
          <li class="chaptrSubSectUl__li"><code>import</code> permite importar funcionalidades desde otros mÃ³dulos.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          ğŸ“‚ /Âº sayHi.js Âº/
          export function @sayHi(#user) &#123;
            console.log(`/Âº Hello, $&#123;user&#125;! Âº/`);
          &#125;;</pre>
        <p class="chaptrSubSect__p">Luego en otro archivo se importa</p>
        <pre class="chaptrSubSect__console wScript">
          ğŸ“‚ /Âº main.js Âº/
          import &#123;#sayHi&#125; from '/Âº ./sayHi.js Âº/';

          @sayHi('Iker');
          â‹— /Âº Hello Iker! Âº/</pre>
        <p class="chaptrSubSect__p">Como los mÃ³dulos admiten palabras clave y caracterÃ­sticas especiales, debemos decirle al navegador que un script debe tratarse como un mÃ³dulo, utilizando el atributo <code>module</code></p>
        <pre class="chaptrSubSect__console wScript">
          /Âº &lt;script src="./sayHi.js" type="module"&gt;&lt;/script&gt; Âº/</pre>
        <p class="chaptrSubSect__p">Si se intenta abrir una pÃ¡gina web localmente a travÃ©s del protocolo <code>file://</code> las directivas <code>import</code> y <code>export</code> no funcionan. Se debe usar un servidor web local, como static-server, o VS Code Live Server Extension para probar los mÃ³dulos.</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="" codeText="import.meta">
        <p class="chaptrSubSect__p">El objeto <code>import.meta</code> contiene la informaciÃ³n sobre el mÃ³dulo actual.Su contenido depende del entorno. En el navegador, contiene la URL del script, o la URL de la pÃ¡gina web actual si estÃ¡ dentro de HTML</p>
        <pre class="chaptrSubSect__console wScript">
          /Âº &lt;script type="module"&gt; Âº/
            console.log(Ã§import.â€¢meta.â€¢url);        /*/Âº URL del script o pÃ¡gina actual Âº/*/
          /Âº &lt;/script&gt; Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="MÃ³dulos son diferidos" codeText="">
        <p class="chaptrSubSect__p">Los mÃ³dulos en JavaScript siempre se cargan de forma diferida (<span class="bttn">deferred</span>), lo que significa que su descarga y ejecuciÃ³n no bloquean el procesamiento del HTML. Esto aplica tanto a scripts externos como a scripts en lÃ­nea con <code>type="module"</code></p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Los mÃ³dulos se descargan en paralelo junto con el resto de los recursos de la pÃ¡gina.</li>
          <li class="chaptrSubSectUl__li">Esperan a que el documento HTML estÃ© completamente cargado antes de ejecutarse.</li>
          <li class="chaptrSubSectUl__li">Se respeta el orden en el que aparecen en el documento: si un mÃ³dulo va antes que otro, se ejecutarÃ¡ primero.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /Âº &lt;script type="module" src="./moduleA.js"&gt;&lt;/script&gt; Âº/      /*/Âº Carga 1Âº Âº/*/
          /Âº &lt;script type="module" src="./moduleB.js"&gt;&lt;/script&gt; Âº/</pre>
        <p class="chaptrSubSect__p">Para los mÃ³dulos tambiÃ©n se puede usar el atributo <code>async</code>, tanto en scripts externos como en lÃ­nea. Un script <code>async</code> se ejecuta tan pronto como estÃ¡ listo, sin esperar al resto del documento ni a otros scripts</p>
        <pre class="chaptrSubSect__console wScript">
          /Âº &lt;script async type="module"&gt; Âº/
              import &#123;#counter&#125; from '/Âº ./analytics.js Âº/'
              #counter.Âªcount();
          /Âº &lt;/script&gt; Âº/</pre>
        <p class="chaptrSubSect__p">Este script se ejecutarÃ¡ en cuanto termine de cargar <code>analytics.js</code>, independientemente del orden en el HTML</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Scripts externos" codeText="">
        <p class="chaptrSubSect__p">Los scripts externos que se buscan desde otro origen requieren encabezados <code>CORS</code> (Cross-Origin Requests), el servidor remoto debe proporcionar un encabezado <span class="bttn">Access-Control-Allow-Origin</span> permitiendo la bÃºsqueda.</p>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Export e Import" codeText="">
      <ChaptrSubSect h4Title="Export antes de las sentencias" codeText="">
        <p class="chaptrSubSect__p">Podemos marcar cualquier declaraciÃ³n como exportada colocando la palabra clave <code>export</code> antes. Esto permite que esa variable, funciÃ³n o clase sea accesible desde otros mÃ³dulos mediante <code>import</code></p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº Exportar un array Âº/*/
          export let Â·months = ['Jan', 'Feb', 'Mar'];

          /*/Âº Exportar una constante Âº/*/
          export const Â·FABRICATIONYEAR = Â¬2015;

          /*/Âº Exportar una clase Âº/*/
          export class Ã§User &#123;
            constructor(#name) &#123;
              this.â€¢name = #name;
            &#125;
          &#125;

          /*/Âº Exportar una funciÃ³n Âº/*/
          export function @sayHi(#user) &#123;
            console.log(`/Âº Hello $&#123;user&#125; Âº/`);
          &#125;</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Export separado" codeText="">
        <p class="chaptrSubSect__p">TambiÃ©n podemos colocar <code>export</code> por separado, al final del archivo. Esta forma es Ãºtil cuando definimos varias funciones o clases y queremos exportarlas juntas, manteniendo el cÃ³digo mÃ¡s limpio y organizado</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº Definimos las funciones normalmente Âº/*/
          function @sayHi(#user) &#123;
            console.log(`/Âº Hello, $&#123;user&#125; Âº/`);
          &#125;

          function @sayBye(#user) &#123;
            console.log(`/Âº Bye, $&#123;user&#125; Âº/`);
          &#125;

          /*/Âº Exportamos todas las funciones en un solo bloque Âº/*/
          export &#123; @sayHi, @sayBye &#125;;</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Esta sintaxis es equivalente a escribir <code>export</code> delante de cada funciÃ³n.</li>
          <li class="chaptrSubSectUl__li">Es especialmente Ãºtil cuando el archivo contiene muchas declaraciones, y queremos mantener las exportaciones todas juntas al final.</li>
          <li class="chaptrSubSectUl__li">Los nombres dentro del bloque <code>&#123; ... &#125;</code> deben coincidir con los identificadores definidos anteriormente (mÃ¡s adelante veremos cÃ³mo renombrarlos con <code>as</code>).</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="" codeText="import">
        <p class="chaptrSubSect__p">Generalmente, colocamos una lista de los elementos que queremos importar entre llaves <code>&#123;&#125;</code></p>
        <pre class="chaptrSubSect__console wScript">
          import &#123;@sayHi, @sayBye&#125; from '/Âº ./say.js Âº/'</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="" codeText="import as">
        <p class="chaptrSubSect__p">La palabra clave <code>as</code> permite renombrar elementos importados para evitar conflictos o mejorar la legibilidad del cÃ³digo. Puede usarse tanto para renombrar funciones o variables especÃ­ficas como para asignar un nombre al mÃ³dulo completo</p>
        <p class="chaptrSubSect__p"><strong><i>Renombrar elementos individuales:</i></strong> Podemos importar funciones o variables bajo nombres distintos. Esto es Ãºtil cuando el archivo importador ya tiene funciones con nombres iguales o se quiere abreviar nombres largos</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“‚ say.js Âº/*/
          export function @sayHi(#user) &#123;
            console.log(`/Âº Hello, $&#123;user&#125; Âº/`);
          &#125;

          export function @sayBye(#user) &#123;
            console.log(`/Âº Bye, $&#123;user&#125; Âº/`);
          &#125;

          /*/Âº ğŸ“‚ main.js Âº/*/
          import &#123; @sayHi Â¬as @hi, @sayBye Â¬as @bye &#125; from '/Âº ./say.js Âº/';

          @hi('/Âº Iker Âº/');           â‹— /Âº Hello, Iker Âº/
          @bye('/Âº Ã‰der Âº/');          â‹— /Âº Bye, Ã‰der Âº/</pre>
        <p class="chaptrSubSect__p"><strong><i>Importar todo el mÃ³dulo bajo un Ãºnico nombre:</i></strong> TambiÃ©n podemos usar <code>as</code> junto con <code>*</code> para importar todo lo exportado de un mÃ³dulo dentro de un Ãºnico objeto. Cada exportaciÃ³n se accede como propiedad de ese objeto</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“‚ say.js Âº/*/
          export function @sayHi(#user) &#123;
            console.log(`/Âº Hello, $&#123;user&#125; Âº/`);
          &#125;

          export function @sayBye(#user) &#123;
            console.log(`/Âº Bye, $&#123;user&#125; Âº/`);
          &#125;

          /*/Âº ğŸ“‚ main.js Âº/*/
          import * Â¬as Ã§say from '/Âº ./say.js Âº/';

          Ã§say.ÂªsayHi('/Âº Iker Âº/');           â‹— /Âº Hello, Iker Âº/
          Ã§say.ÂªsayBye('/Âº Ã‰der Âº/');          â‹— /Âº Bye, Ã‰der Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="" codeText="export as">
        <p class="chaptrSubSect__p">Podemos usar la palabra clave <code>as</code> tambiÃ©n al exportar, para renombrar las exportaciones. Esto permite que los archivos que importen estas funciones vean nombres distintos a los originales dentro del mÃ³dulo</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“‚ say.js Âº/*/
          function @sayHi(#user) &#123;
            console.log(`/Âº Hello, $&#123;user&#125; Âº/`);
          &#125;

          function @sayBye(#user) &#123;
            console.log(`/Âº Bye, $&#123;user&#125; Âº/`);
          &#125;

          /*/Âº Exportamos las funciones con nuevos nombres Âº/*/
          export &#123; @sayHi Â¬as @hola, @sayBye Â¬as @adios &#125;;</pre>
        <p class="chaptrSubSect__p">Ahora <code>hi</code> y <code>bye</code>, se importan desde otros archivos con los nombres renombrados</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“‚ main.js Âº/*/
          import * Â¬as Ã§say from '/Âº ./say.js Âº/';

          Ã§say.Âªhola('/Âº Iker Âº/');           â‹— /Âº Hello, Iker Âº/
          Ã§say.Âªadios('/Âº Ã‰der Âº/');          â‹— /Âº Bye, Ã‰der Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="" codeText="export default">
        <p class="chaptrSubSect__p">Permite definir la exportaciÃ³n principal de un mÃ³dulo, de manera que pueda importarse fÃ¡cilmente sin llaves <code>&#123;&#125;</code> Cada mÃ³dulo puede tener solo una exportaciÃ³n predeterminada</p>
        <p class="chaptrSubSect__p"><strong><i>Export default con nombre</i></strong></p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“‚ user.js Âº/*/
          export default class Ã§User &#123;
            constructor(#name)&#123;
              this.â€¢name = #name;
            &#125;
          &#125;
          
          /*/Âº ğŸ“‚ main.js Âº/*/
          import Ã§User from '/Âº ./user.js Âº/';

          const Ã§user1 = new Ã§User('Ã‰der');
          console.log(Ã§user1.â€¢name);        â‹— /Âº 'Ã‰der' Âº/</pre>
        <p class="chaptrSubSect__p">La clase <code>User</code> se importa sin llaves y puede renombrarse como se desee</p>
        <p class="chaptrSubSect__p"><strong><i>Export default sin nombre</i></strong></p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“‚ user.js Âº/*/
          export default class &#123;
            constructor(#name)&#123;
              this.â€¢name = #name;
            &#125;
          &#125;
          
          /*/Âº ğŸ“‚ main.js Âº/*/
          import Ã§AnyName from '/Âº ./user.js Âº/';

          const Ã§user2 = new Ã§AnyName('Ã‰der');
          console.log(Ã§user2.â€¢name);        â‹— /Âº 'Ã‰der' Âº/</pre>
        <p class="chaptrSubSect__p">Se puede importar la exportaciÃ³n por defecto junto con exportaciones con nombre usando llaves</p>
        <p class="chaptrSubSect__p"><strong><i>Export default combinado con exportaciones con nombre</i></strong></p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“‚ user.js Âº/*/
          export default class &#123;
            constructor(#name)&#123;
              this.â€¢name = #name;
            &#125;
          &#125;

          export function @sayHi(#user) &#123;
            console.log(`/Âº Hello, $&#123;user&#125; Âº/`);
          &#125;
          
          /*/Âº ğŸ“‚ main.js Âº/*/
          import Ã§User, &#123; @sayHi &#125; from '/Âº ./user.js Âº/';

          const Ã§user3 = new Ã§User('Ã‰der');
          @sayHi(Ã§user3.â€¢name);        â‹— /Âº 'Ã‰der' Âº/</pre>
        <p class="chaptrSubSect__p">Se puede importar la exportaciÃ³n por defecto junto con exportaciones con nombre usando llaves</p>
        <p class="chaptrSubSect__p"><strong><i>Importar todo el mÃ³dulo como un objeto</i></strong></p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“‚ main.js Âº/*/
          import * Â¬as Ã§user from '/Âº ./user.js Âº/';

          const Ã§user4 = new Ã§user.â€¢default('Ã‰der');      /*/Âº default contiene la exportaciÃ³n principal Âº/*/
          Ã§user.@sayHi(Ã§user4.â€¢name);        â‹— /Âº 'Ã‰der' Âº/</pre>
        <p class="chaptrSubSect__p">Ãštil cuando se desea agrupar todas las exportaciones bajo un mismo objeto.</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Solo puede haber una exportaciÃ³n predeterminada por mÃ³dulo.</li>
          <li class="chaptrSubSectUl__li">Facilita la importaciÃ³n, permitiendo usar cualquier nombre, pero puede llevar a inconsistencias si se abusa de ella.</li>
          <li class="chaptrSubSectUl__li">Se recomienda usar <code>export</code> <code>default</code> cuando el mÃ³dulo tiene una entidad claramente principal (una clase, funciÃ³n o constante central).</li>
        </ul>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Importaciones dinÃ¡micas" codeText="">
      <ChaptrSubSect h4Title="La expresiÃ³n" codeText="import()">
        <p class="chaptrSubSect__p">La expresiÃ³n <code>import(module)</code> permite cargar mÃ³dulos dinÃ¡micamente en tiempo de ejecuciÃ³n. Devuelve una promesa que se resuelve en un objeto con todas las exportaciones del mÃ³dulo</p>
        <p class="chaptrSubSect__p">Esto es Ãºtil cuando no sabemos quÃ© mÃ³dulo necesitaremos hasta que se ejecute el cÃ³digo, o para cargar funcionalidades bajo demanda y optimizar el rendimiento</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“‚ say.js Âº/*/
          export function @sayHi() &#123;
            console.log(`/Âº Hola! Âº/`);
          &#125;

          export function @sayBy() &#123;
            console.log(`/Âº AdiÃ³s! Âº/`);
          &#125;
          
          /*/Âº ğŸ“‚ main.js Âº/*/
          async function @loadSay() &#123;
            let &#123; @hi, @bye &#125; await import ('/Âº ./say.js Âº/');
            @hi()       
            @bye()        
          &#125;

          @loadSay();
          â‹— /Âº "Hola!" Âº/
          â‹— /Âº "AdiÃ³s!" Âº/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">A diferencia del <strong>import estÃ¡tico</strong>, el <strong>import dinÃ¡mico</strong> puede ejecutarse en cualquier lugar del cÃ³digo.</li>
          <li class="chaptrSubSectUl__li">Ideal para <strong>lazy loading</strong>: solo cargar el mÃ³dulo si realmente se necesita.</li>
          <li class="chaptrSubSectUl__li">Devuelve un objeto mÃ³dulo con todas las exportaciones disponibles.</li>
          <li class="chaptrSubSectUl__li">Se debe usar <code>await</code> dentro de funciones <code>async</code> o <code>.then()</code> para manejar la promesa.</li>
        </ul>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_29" nextPage="/lessons/lesson_31"/>
</MainLayout>





<!-- 
&lt;&gt;          < > no estilados
&#123;&#125;      {} no estilados
()&#123;&#125;    ( ) { } no estilados
ï¹›ï¹œ              { } Llaves no estilados
ï¹•                : 2 puntos no estilados
ï¼ƒ                # Rejilla no estilada

ÂªmÃ©todos
â€¢parametro
Â·variable
#variable en Func/if/for
Ã§Objetos
â‹— Resultado
@funcion()
Â¬numbers
objProperty:
ÂºobjProperty
/* comentario */
'/Âº modo texto quita span Âº/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">

-->
