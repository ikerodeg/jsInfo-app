---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__14" h2Title="Objetos" slot="mainContent">
    <ChaptrSect h3Title="Creación de objetos" codeText="">
      <ChaptrSubSect h4Title="Notación literal" codeText="{}">
        <p class="chaptrSubSect__p">Se guarda en una variable (<mark>se recomienda usar </mark><code>const</code>) con un nombre y se usa un par llaves. Es la manera más rápida y se considera buenas practicas</p>
        <pre class="chaptrSubSect__console wScript">
          const çmyObject = &#123; name: 'Eder' &#125;;
        
          console.log(çmyObject);
          ⋗ /º&#123; name: 'Eder' &#125;º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Constructor" codeText="Object">
        <p class="chaptrSubSect__p">Usando el constructor <code>new</code> y <code>Object</code> y el operador <code>new</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çmyObject = new Object();
          çmyObject.•name = 'Eder';
        
          console.log(çmyObject);
          ⋗ /º&#123; name: 'Eder' &#125;º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Factory Function" codeText="">
        <p class="chaptrSubSect__p">Usando una función a la que se le pasa unos parámetros</p>
        <pre class="chaptrSubSect__console wScript">
          function @makeObjects(#name) &#123;
            return &#123;
              name: #name,
            &#125;;
          &#125;;

          const çmyObject = @makeObjects('Eder');
          console.log(çmyObject);
          ⋗ /º&#123; name: 'Eder' &#125;º/</pre>
        <p class="chaptrSubSect__p">En el ejemplo anterior las propiedades tienen los mismos nombres que las variables, pero podemos simplemente escribir un único nombre como propiedad/valor</p>
        <pre class="chaptrSubSect__console wScript">
          function @makeObjects(#name, #age) &#123;
            return &#123;
              #name,
              #age
            &#125;;
          &#125;;

          const çmyObject = @makeObjects('Eder', ¬5);
          console.log(çmyObject);
          ⋗ /º&#123; name: 'Eder', age: 5 &#125;º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Acceso a propiedades" codeText="">
      <ChaptrSubSect h4Title="Operador del punto" codeText=".">
        <p class="chaptrSubSect__p">Se puede acceder a los valores de las propiedades utilizando el operador del punto</p>
        <pre class="chaptrSubSect__console wScript">
          const çeder = &#123;
            age: ¬5,
            height: ¬112,
          &#125;;

          console.log(çeder.•height);
          ⋗ /º 112 º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Operador de corchete" codeText="[ ]">
        <p class="chaptrSubSect__p">Es más versátil y permite el acceso dinámico a las propiedades del objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const çeder = &#123;
            age: ¬5,
            height: ¬112,
          &#125;;

          console.log(çeder['height']);           /*/º Ojo con las comillas º/*/
          ⋗ /º 112 º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Actualizar propiedades" codeText="">
      <ChaptrSubSect h4Title="Operador del punto" codeText=".">
        <p class="chaptrSubSect__p">Se puede actualizar los valores de las propiedades utilizando el operador del punto</p>
        <pre class="chaptrSubSect__console wScript">
          const çeder = &#123;
            age: ¬5,
            height: ¬112,
          &#125;;

          çeder.•height = ¬117;

          console.log(çeder);
          ⋗ /º &#123; age: 5, height: 117 &#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Operador del corchete" codeText="[]">
        <p class="chaptrSubSect__p">Se puede actualizar los valores de las propiedades utilizando el operador del corchete</p>
        <pre class="chaptrSubSect__console wScript">
          const çeder = &#123;
            age: ¬5,
            height: ¬112,
          &#125;;

          çeder['height'] = ¬117;

          console.log(çeder);
          ⋗ /º &#123; age: 5, height: 117 &#125; º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Agregar propiedades" codeText="">
      <ChaptrSubSect h4Title="Operador del punto" codeText=".">
        <p class="chaptrSubSect__p">Se puede agregar propiedades utilizando el operador del punto</p>
        <pre class="chaptrSubSect__console wScript">
          const çeder = &#123;
            age: ¬5,
            height: ¬117,
          &#125;;

          çeder.•weight = ¬30;

          console.log(çeder);
          ⋗ /º &#123; age: 5, height: 117, weight: 30 &#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Operador del corchete" codeText="[]">
        <p class="chaptrSubSect__p">Se puede agregar propiedades utilizando el operador del corchete</p>
        <pre class="chaptrSubSect__console wScript">
          const çeder = &#123;
            age: ¬5,
            height: ¬117,
          &#125;;

          çeder['weight'] = ¬30;

          console.log(çeder);
          ⋗ /º &#123; age: 5, height: 117, weight: 30 &#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Variables externas" codeText="">
        <p class="chaptrSubSect__p">Se puede agregar propiedades cuyo valor sea el de una variable externa</p>
        <pre class="chaptrSubSect__console wScript">
          const ·weight = ¬30;

          const çeder = &#123;
            age: ¬5,
            height: ¬117,
          &#125;;

          çeder.•weight = ·weight;
          
          console.log(çeder);
          ⋗ /º &#123; age: 5, height: 117, weight: 30 &#125; º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Borrado de propiedades" codeText="">
      <ChaptrSubSect h4Title="Operador" codeText="delete">
        <p class="chaptrSubSect__p">Se puede borrar propiedades utilizando el operador <code>delete</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çeder = &#123;
            age: ¬5,
            height: ¬117,
            weight: ¬30,
          &#125;;

          delete çeder.•weight;           /*/º No da error si no existe la propiedad º/*/
          
          console.log(çeder);
          ⋗ /º &#123; age: 5, height: 117 &#125; º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Vaciado de objeto" codeText="">
      <ChaptrSubSect h4Title="Manteniendo la ref al objeto original" codeText="">
        <p class="chaptrSubSect__p">Cuando vacías un objeto usando un bucle <code>for...in</code> o <code>Object.keys()</code> y <code>delete</code>, eliminas las propiedades del objeto original <mark>manteniendo la referencia</mark> al mismo. Esto es útil cuando quieres que cualquier referencia a ese objeto en otros lugares (por ejemplo, otras variables que apuntan al mismo objeto) también vean los cambios</p>
        <pre class="chaptrSubSect__console wScript">
          const çshopListBase = &#123;
            verduras: ¬5,
            carnes: ¬7,
            frutas: ¬10,
          &#125;;

          /* Creamos una nueva referencia al objeto original */
          const çshopListNew = çshopListBase;

          console.log(çshopListNew);                 /* verificamos objeto nuevo */
          ⋗ /º&#123; verduras: 5, carnes: 7, frutas: 10 &#125;º/

          /* Vaciamos el objeto original */
          Object.ªkeys(çshopListBase).@forEach(#prop =&gt; delete çshopListBase[#prop]);

          console.log(çshopListNew);                /* verificamos objeto nuevo */
          ⋗ /º&#123; &#125;º/                 /* el objeto nuevo también se ha vaciado */</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Rompiendo la ref al objeto original" codeText="">
        <p class="chaptrSubSect__p">Cuando reasignas a un objeto un objeto vacío lo que haces es que ahora apunte a un nuevo objeto en memoria, pero las otras referencias al objeto original seguirán apuntando al antiguo objeto, no al nuevo <mark>eliminando la referencia</mark> al objeto original</p>
        <pre class="chaptrSubSect__console wScript">
          const çshopListBase = &#123;
            verduras: ¬5,
            carnes: ¬7,
            frutas: ¬10,
          &#125;;

          /* Creamos una nueva referencia al objeto original */
          const çshopListNew = çshopListBase;

          console.log(çshopListNew);
          ⋗ /º&#123; verduras: 5, carnes: 7, frutas: 10 &#125;º/

          /* Reasignamos el objeto original a un nuevo objeto vacío */
          çshopListBase = &#123;&#125;;              /*/º Ojo aquí da error si usamos const º/*/;

          console.log(çshopListNew);
          ⋗ /º&#123; &#125;º/                 /* ahora está vacío */
        
          console.log(çshopListBase);
          ⋗ /º&#123; verduras: 5, carnes: 7, frutas: 10 &#125;º/ /* sigue teniendo los valores originales */</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Buscar propiedades" codeText="key">
      <ChaptrSubSect h4Title="Operador" codeText="in">
        <p class="chaptrSubSect__p">El operador <code>in</code> devuelve <code>true</code> si la propiedad especificada está en el objeto especificado o su prototipo</p>
        <pre class="chaptrSubSect__console wScript">
          const çengineModel1 = &#123;
            tipo: 'gasolina',
            cv: ¬375,
            turbo: true,
            mod: '/º 1.5Mod RR º/',
          &#125;;

          console.log('mod' ¬in çengineModel1);           /*/º Si existe la propiedad 'mod' º/*/
          ⋗ /º true º/</pre>
          <p class="chaptrSubSect__p">Si omitimos las comillas, significa que buscará el valor de esa variable dentro del objeto. En este caso lo que busca es si <code>'1.5Mod RR'</code> forma parte de las propiedades del objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const ·mod = '/º 1.5Mod RR º/';

          const çengineModel1 = &#123;
            tipo: 'gasolina',
            cv: ¬375,
            turbo: true,
            mod: ·mod,
          &#125;;

          console.log(·mod ¬in çengineModel1);           /*/º Busca la propiedad 1.5Mod RR º/*/
          ⋗ /º false º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Iteración sobre propiedades" codeText="keys">
      <ChaptrSubSect h4Title="El ciclo" codeText="for..in">
        <p class="chaptrSubSect__p">Sirve para recorrer las propiedades de un objeto, itera no solo sobre el objeto original lo hace sobre los añadidos después. Admite <code>break</code> y <code>continue</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çengineModel1 = &#123;
            tipo: 'gasolina',
            cv: ¬375,
            turbo: true,
            mod: '/º 1.5Mod RR º/',
          &#125;;

          for (let #prop ¬in çengineModel1) &#123;
            console.log(#prop);
          &#125;

          ⋗ /º 'tipo' º/
          ⋗ /º 'cv' º/
          ⋗ /º 'turbo' º/
          ⋗ /º 'mod' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText="Object.keys()">
        <p class="chaptrSubSect__p">Sirve para recorrer las propiedades de un objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const çengineModel1 = &#123;
            tipo: 'gasolina',
            cv: ¬375,
            turbo: true,
            mod: '/º 1.5Mod RR º/',
          &#125;;

          for (let #prop of Object.ªkeys(çengineModel1)) &#123;
            console.log(#prop);
          &#125;

          ⋗ /º 'tipo' º/
          ⋗ /º 'cv' º/
          ⋗ /º 'turbo' º/
          ⋗ /º 'mod' º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Iteración sobre valores" codeText="values">
      <ChaptrSubSect h4Title="El ciclo" codeText="for..in">
        <p class="chaptrSubSect__p">También sirve para recorrer los valores de las propiedades</p>
        <pre class="chaptrSubSect__console wScript">
          const çengineModel1 = &#123;
            tipo: 'gasolina',
            cv: ¬375,
            turbo: true,
            mod: '/º 1.5Mod RR º/',
          &#125;;

          for (let #prop ¬in çengineModel1) &#123;
            console.log(çengineModel1[#prop]);
          &#125;

          ⋗ /º"gasolina"º/
          ⋗ /º 375 º/
          ⋗ /ºtrueº/
          ⋗ /º"1.5Mod RR"º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText="Object.values()">
        <p class="chaptrSubSect__p">Sirve para recorrer los valores de un objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const çengineModel1 = &#123;
            tipo: 'gasolina',
            cv: ¬375,
            turbo: true,
            mod: '/º 1.5Mod RR º/',
          &#125;;

          for (let #value of Object.ªvalues(çengineModel1)) &#123;
            console.log(#value);
          &#125;

          ⋗ /º "gasolina" º/
          ⋗ /º 375 º/
          ⋗ /º true º/
          ⋗ /º "1.5Mod RR" º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Iteración sobre pares" codeText="">
      <ChaptrSubSect h4Title="El ciclo" codeText="for..in">
        <p class="chaptrSubSect__p">Podemos mostrar los pares <mark>keys</mark> + <mark>values</mark></p>
        <pre class="chaptrSubSect__console wScript">
          const çengineModel1 = &#123;
            tipo: 'gasolina',
            cv: ¬375,
            turbo: true,
            mod: '/º 1.5Mod RR º/',
          &#125;;

          for (let #prop ¬in çengineModel1) &#123;
            console.log(`$&#123;#prop&#125;: $&#123;çengineModel1[#prop]&#125;`);
          &#125;

          ⋗ /º tipo: º/ /º"gasolina"º/
          ⋗ /º cv: º/ /º 375 º/
          ⋗ /º turbo: º/ /ºtrueº/
          ⋗ /º mod: º/ /º"1.5Mod RR"º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText="Object.entries()">
        <p class="chaptrSubSect__p">Devuelve un <mark>array de arrays</mark>, donde cada par de arrays representa una entrada en el objeto original. Cada par consiste en una clave (nombre de la propiedad) y su valor correspondiente, en ese orden</p>
        <pre class="chaptrSubSect__console wScript">
          const çengineModel1 = &#123;
            tipo: 'gasolina',
            cv: ¬375,
            turbo: true,
            mod: '/º 1.5Mod RR º/',
          &#125;;

          for (let #propValue of Object.ªentries(çengineModel1)) &#123;
            console.log(#propValue);
          &#125;

          ⋗ /º [tipo: º/ /º"gasolina"] º/
          ⋗ /º [cv: º/ /º 375] º/
          ⋗ /º [turbo: º/ /ºtrue] º/
          ⋗ /º [mod: º/ /º"1.5Mod RR"] º/</pre>
        <p class="chaptrSubSect__p">También lo podemos asignar directamente a una variable</p>
        <pre class="chaptrSubSect__console wScript">
          const çengineModel1 = &#123;
            tipo: 'gasolina',
            cv: ¬375,
            turbo: true,
            mod: '/º 1.5Mod RR º/',
          &#125;;

          const ·entriesEngineModel1 = Object.ªentries(çengineModel1);

          console.log(·entriesEngineModel1);

          ⋗ /º [ º/
              /º [tipo: º/ /º"gasolina"], º/
              /º [cv: º/ /º 375], º/
              /º [turbo: º/ /ºtrue], º/
              /º [mod: º/ /º"1.5Mod RR"] º/
          /º ] º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Copia de objetos" codeText="">
      <ChaptrSubSect h4Title="Copia superficial con" codeText="for..in">
        <p class="chaptrSubSect__p">Hace una <mark>copia superficial</mark> <mark>shallow copy</mark> del objeto. Solo se copian las propiedades del objeto principal, pero si el objeto original contiene propiedades que son otros objetos, esos objetos anidados <b>NO</b> se clonan profundamente</p>
        <pre class="chaptrSubSect__console wScript">
          const çpersona1 = &#123;
            nombre: 'Iker',
            edad: ¬48,
          &#125;;

          const çpersona2 = &#123;&#125;;

          for (let #prop ¬in çpersona1) &#123;
            çpersona2[#prop] = çpersona1[#prop];
          &#125;

          çpersona2.•nombre = 'Eder';
          çpersona2.•edad = ¬5;

          console.log(çpersona2);
          ⋗ /º&#123; nombre: 'Eder', edad: 5 &#125;º/
          console.log(çpersona1);
          ⋗ /º&#123; nombre: 'Iker', edad: 48 &#125;º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Copia superficial con" codeText="spread {...obj}">
        <p class="chaptrSubSect__p">Hace una <mark>copia superficial</mark> <mark>shallow copy</mark> del objeto. Solo se copian las propiedades del objeto principal, pero si el objeto original contiene propiedades que son otros objetos, esos objetos anidados <b>NO</b> se clonan profundamente</p>
        <pre class="chaptrSubSect__console wScript">
          const çpersona1 = &#123;
            nombre: 'Iker',
            edad: ¬48,
          &#125;;

          çpersona2 = &#123;...çpersona1&#125;;

          çpersona2.•nombre = 'Eder';
          çpersona2.•edad = ¬5;

          console.log(çpersona2);
          ⋗ /º&#123; nombre: 'Eder', edad: 5 &#125;º/
          console.log(çpersona1);
          ⋗ /º&#123; nombre: 'Iker', edad: 48 &#125;º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Copia superficial con" codeText="Object.assign()">
        <p class="chaptrSubSect__p">Hace una <mark>copia superficial</mark> <mark>shallow copy</mark> del objeto. Solo se copian las propiedades del objeto principal, pero si el objeto original contiene propiedades que son otros objetos, esos objetos anidados <b>NO</b> se clonan profundamente</p>
        <pre class="chaptrSubSect__console wScript">
          const çpersona1 = &#123;
            nombre: 'Iker',
            edad: ¬48,
          &#125;;

          çpersona2 = &#123; &#125;;
          Object.ªassign(çpersona2, çpersona1);
          
          çpersona2.•nombre = 'Eder';
          çpersona2.•edad = ¬5;

          console.log(çpersona2);
          ⋗ /º&#123; nombre: 'Eder', edad: 5 &#125;º/
          console.log(çpersona1);
          ⋗ /º&#123; nombre: 'Iker', edad: 48 &#125;º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Copia profunda con" codeText="structuredClone()">
        <p class="chaptrSubSect__p">Realiza una copia profunda <mark>deepClone</mark>, incluidas todas las propiedades anidadas. Primero convierte el objeto en una cadena <mark>JSON</mark> para después a partir de esa cadena, crear un nuevo objeto. Sin embargo, esta técnica solo funciona si el objeto y sus propiedades son serializables en <mark>JSON</mark>. Si el objeto contiene propiedades no serializables, como <mark><b>funciones</b></mark> o referencias a objetos no serializables, <b>NO</b> funcionará</p>
        <pre class="chaptrSubSect__console wScript">
          const çpersona1 = &#123;
            nombre: 'Iker',
            edad: ¬48,
          &#125;;

          çpersona2 = structuredClone(çpersona1);

          çpersona2.•nombre = 'Eder';
          çpersona2.•edad = ¬5;

          console.log(çpersona2);
          ⋗ /º&#123; nombre: 'Eder', edad: 5 &#125;º/
          console.log(çpersona1);
          ⋗ /º&#123; nombre: 'Iker', edad: 48 &#125;º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Métodos de objeto" codeText="">
      <ChaptrSubSect h4Title="Forma literal" codeText="">
        <p class="chaptrSubSect__p">Una función que es la propiedad de un objeto, es denominada su <mark>método</mark></p>
        <pre class="chaptrSubSect__console wScript">
          const çpersona1 = &#123;
            nombre: 'Eder',
            edad: ¬5,
            sayHi: @function() &#123;
              console.log('/º Hola que tal! º/');
            &#125;,
          &#125;;

          çpersona1.ªsayHi();
          ⋗ /º "Hola que tal!" º/</pre>
        <p class="chaptrSubSect__p">Existe una sintaxis más corta para los métodos en objetos literales. Podemos omitir <code>function</code> y simplemente escribir <code>sayHi()</code>. En casi todos los casos la sintaxis abreviada es la <mark>preferida</mark></p>
        <pre class="chaptrSubSect__console wScript">
          const çpersona1 = &#123;
            nombre: 'Eder',
            edad: ¬5,
            @sayHi() &#123;
              console.log('/º Hola que tal! º/');
            &#125;,
          &#125;;

          çpersona1.ªsayHi();
          ⋗ /º "Hola que tal!" º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Expresión de función + asignación" codeText="">
        <p class="chaptrSubSect__p">Podemos añadir una expresion de función ya declarada a nuestro objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const ·sayHi = @function() &#123;
            console.log('/º Hola que tal! º/');
          &#125;;

          const çpersona1 = &#123;
            nombre: 'Eder',
            edad: ¬5,
            sayHi: ·sayHi,
          &#125;;

          çpersona1.ªsayHi();
          ⋗ /º "Hola que tal!" º/</pre>
        <p class="chaptrSubSect__p">También podemos añadirla al objeto con el método del punto</p>
        <pre class="chaptrSubSect__console wScript">
          const ·sayHi = @function() &#123;
            console.log('/º Hola que tal! º/');
          &#125;;

          const çpersona1 = &#123;
            nombre: 'Eder',
            edad: ¬5,
          &#125;;

          çpersona1.ªsayHi = ·sayHi;

          çpersona1.ªsayHi();
          ⋗ /º "Hola que tal!" º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="La palabra clave" codeText="this">
      <ChaptrSubSect h4Title="Uso de" codeText="this">
        <p class="chaptrSubSect__p">Es común que un <mark>método de objeto</mark> necesite acceder a la información almacenada en el objeto para cumplir su tarea. Por ejemplo, el código dentro de <code>obj1.explain()</code> puede necesitar acceder a la propiedad <code>expl</code></p>
        <p class="chaptrSubSect__p">Para acceder al objeto, un método puede usar la palabra clave <code>this</code>, el valor de <code>this</code> es el objeto “antes del punto”, el usado para llamar al método</p>
        <pre class="chaptrSubSect__console wScript">
          const çobj1 = &#123;
            expl: 'Hola desde el objeto 1',
            @explain() &#123;
              console.log('/º $&#123;this.expl&#125; º/');
            &#125;,
          &#125;;


          çobj1.ªexplain();
          ⋗ /º "Hola desde el objeto 1 º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Las funciones flecha no tienen" codeText="this">
        <p class="chaptrSubSect__p">Las funciones de flecha son especiales: ellas no tienen su “propio” <code>this</code>. Si nosotros hacemos referencia a <code>this</code> desde tales funciones, esta será tomada desde afuera de la función “normal”</p>
        <pre class="chaptrSubSect__console wScript">
          const çobj1 = &#123;
            expl: 'Hola desde el objeto 1',
            @explain() =&gt; &#123;
              console.log('/º $&#123;this.expl&#125; º/');
            &#125;,
          &#125;;


          çobj1.ªexplain();
          ⋗ /º Error º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Reutilización de métodos" codeText="">
      <ChaptrSubSect h4Title="El método" codeText=".call">
        <p class="chaptrSubSect__p">Podemos usar una función exterior en cada objeto que tengamos para no escribir un método repetido en cada uno de ellos, y aplicarlo a cada uno con <code>call</code></p>
        <pre class="chaptrSubSect__console wScript">
          function @method1(#likes) &#123;
            console.log(`/º $&#123;this.name&#125;: $&#123;#likes&#125; likesº/`);
          &#125;;

          const çuser1 = &#123; name: 'Eder' &#125;;
          const çuser2 = &#123; name: 'Iker' &#125;;

          çuser1.ªmethod1(¬50);
          ⋗ /º "Eder: 50 likesº/

          çuser2.ªmethod1(¬10);
          ⋗ /º "Iker: 10 likesº/</pre>
        <p class="chaptrSubSect__p">Tambien podemos llamar a un método dentro de un objeto para que sea usado en otro</p>
        <pre class="chaptrSubSect__console wScript">
          const çuser1 = &#123;
            name: 'Eder',
            @showInfo(#likes, #friends) &#123;
              return `/º $&#123;this.name&#125;: $&#123;#likes&#125; likes, $&#123;#friends&#125; amigos º/`;
            &#125;,
          &#125;;

          const çuser2 = &#123; name: 'Iker' &#125;;

          console.log(çuser1.ªshowInfo.ªcall(çuser2, ¬9, ¬4));
          ⋗ /º "Iker: 9 likes, 4 amigos º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".apply">
        <p class="chaptrSubSect__p">La única diferencia con <code>call</code> es la forma en que recibe los parámetros. A <code>apply</code> se le pasa los parámetros por medio de un array</p>
        <pre class="chaptrSubSect__console wScript">
          const çuser1 = &#123;
            name: 'Eder',
            @showInfo(#likes, #friends) &#123;
              return `/º $&#123;this.name&#125;: $&#123;#likes&#125; likes, $&#123;#friends&#125; amigos º/`;
            &#125;,
          &#125;;

          const çuser2 = &#123; name: 'Iker' &#125;;
        
          console.log(çuser1.ªshowInfo.ªapply(çuser2, [¬9, ¬4]));
          ⋗ /º "Iker: 9 likes, 4 amigos º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".bind">
        <p class="chaptrSubSect__p">Crea una función en base a la función que vamos a enlazar. <mark>Retorna una función</mark> con el nuevo contexto. Al igual que las otras dos de arriba, se trata de mantener el "contexto" para poder seguir usando <code>this</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çuser1 = &#123;
            name: 'Eder',
            @eat(#food) &#123;
              return `/º $&#123;this.name&#125; come $&#123;#food&#125;º/`;
            &#125;,
          &#125;;

          const çuser2 = &#123; name: 'Iker' &#125;;

          const ·comidaUser2 = çuser1.ªeat.bind(çuser2);

          console.log(·comidaUser2('pizza'));
          ⋗ /º "Iker come pizzaº/</pre>
        <p class="chaptrSubSect__p">Como el método <code>bind</code> devuelve una función, para invocarla necesitamos almacenarla en una variable, como si fuera una expresion de función. Digamos que podemos crear métodos para usarlos en distintos objetos</p>
        <pre class="chaptrSubSect__console wScript">
          const çuser1 = &#123; name: 'Eder' &#125;;
          const çuser2 = &#123; name: 'Iker' &#125;;
          
          function @greet() &#123;
            console.log(`/º Hola soy $&#123;this.name&#125; º/`);
          &#125;

          const ·greetEder = @greet.bind(çuser1);
          const ·greetIker = @greet.bind(çuser2);

          ·greetEder();
          ⋗ /º "Hola soy Eder º/
        
          ·greetIker();
          ⋗ /º "Hola soy Iker º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Función constructora" codeText="">
      <ChaptrSubSect h4Title="Creación de la función" codeText="">
        <p class="chaptrSubSect__p">La función constructora es nombrada con la <mark>primera letra en mayúsculas</mark>, y pasamos los parámetros entre paréntesis que en el objeto serán las propiedades</p>
        <pre class="chaptrSubSect__console wScript">
          function @Car(#make, #model, #year) &#123;
            this.•make = #make;
            this.•model = #model;
            this.•year = #year;
          &#125;;</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Creación de objetos con" codeText="new">
        <p class="chaptrSubSect__p">Asignamos a una variable el resultado de ejecutar la función constructora, pasándole los argumentos que serán los valores de las propiedades ya predefinidas usando el operador <code>new</code></p>
        <pre class="chaptrSubSect__console wScript">
          function @Car(#make, #model, #year) &#123;
            this.•make = #make;
            this.•model = #model;
            this.•year = #year;
          &#125;;

          /* Método compartido por todas las futuras instancias de Car */
          @Car.ªprototype.ªstart = @function() &#123;
            console.log(`$&#123;this.make&#125; $&#123;this.model&#125; arranca 🚗`);
          &#125;;

          const ·myCar = new @Car('Nissan', '/º GT-R º/', ¬2024);
          const ·anotherCar = new @Car('Ford', '/º RS-Cosworth º/', ¬2000);

          console.log(·myCar);
          ⋗ /º &#123; make: 'Nissan', model: "GT-R", year: 2024 &#125; º/

          console.log(·anotherCar);
          ⋗ /º &#123; make: 'Ford', model: "RS-Cosworth", year: 2000 &#125; º/

          ·myCar.ªstart();
          ⋗ /º "Nissan GT-R arranca 🚗" º/

          ·anotherCar.ªstart();
          ⋗ /º "Ford RS-Cosworth arranca 🚗" º/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Cada vez que llamamos a la función con <code>new</code>, se crea un nuevo objeto <b>vacio</b> y se asigna a la variable.</li>
          <li class="chaptrSubSectUl__li">Asigna ese nuevo objeto creado al <code>this</code> dentro de la función.</li>
          <li class="chaptrSubSectUl__li">Añade la propiedad <code>prototype</code> de la función al objeto (para heredar métodos si los hay).</li>
          <li class="chaptrSubSectUl__li">Devuelve ese objeto automáticamente aunque no uses <code>return</code>.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Constructor modo test" codeText="new.target">
        <p class="chaptrSubSect__p">En funciones constructoras, si olvidas usar <code>new</code>, la función puede no comportarse como esperas, porque <code>this</code> no apuntará a un nuevo objeto, sino al contexto global o <code>undefined</code> en modo estricto</p>
        <p class="chaptrSubSect__p">Usar <code>new.target</code> permite verificar si una función ha sido llamada correctamente con <code>new</code>. Si no ha sido llamada con <code>new</code>, se puede corregir el error automáticamente, como en el ejemplo que vemos</p>
        <pre class="chaptrSubSect__console wScript">
          function @Jugador(#name) &#123;
            if (!çnew.•target) &#123;                   
              return new @Jugador(#name);     /*/º Si se olvidó new, lo aplicamos automáticamente º/*/
              console.log('/º Se olvidó usar new, corrigiendo...º/');
            &#125;
            console.log('/º Constructor llamado correctamente con new º/');
            this.•name = #name;
          &#125;;

          const ·lateralIzq = @Jugador('Éder');          /*/º Olvidamos usar new º/*/
          ⋗ /º Se olvidó usar new, corrigiendo...º/

          const ·delantero = new @Jugador('Iker');       /*/º Usamos new correctamente º/*/
          ⋗ /º Constructor llamado correctamente con new º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Métodos en el constructor" codeText="">
        <p class="chaptrSubSect__p">Podemos agregar a <code>this</code> no sólo propiedades, sino también métodos</p>
        <pre class="chaptrSubSect__console wScript">
          function @Jugador(#name) &#123;
            this.•name = #name;
            this.•greet = @function() &#123;
              console.log(`/º Hola soy $&#123;this.name&#125; º/`);
            &#125;;
          &#125;;

          const ·lateralIzq = new @Jugador('Éder');
          const ·delantero = new @Jugador('Iker');

          ·lateralIzq.ªgreet();
          ⋗ /º "Hola soy Éder" º/

          ·delantero.ªgreet();
          ⋗ /º "Hola soy Iker" º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Conversión a primitivo" codeText="">
      <ChaptrSubSect h4Title="to array con" codeText=".keys">
        <p class="chaptrSubSect__p">Devuelve un array de propiedades. Los métodos <code>Object.*</code> devuelven arrays de objetos “reales”, no solo un iterable</p>
        <pre class="chaptrSubSect__console wScript">
          const çuser = &#123;
            name: 'Éder',
            age: ¬4,
          &#125;;
        
          const çuserKeys = Object.ªkeys(çuser);

          console.log(çuserKeys);
          ⋗ /º ["name", "age"] º/
        </pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="to array con" codeText=".values">
        <p class="chaptrSubSect__p">Devuelve un array de valores. Los métodos <code>Object.*</code> devuelven arrays de objetos “reales”, no solo un iterable</p>
        <pre class="chaptrSubSect__console wScript">
          const çuser = &#123;
            name: 'Éder',
            age: ¬4,
          &#125;;

          const çuserValues = Object.ªvalues(çuser);

          console.log(çuserValues);
          ⋗ /º ["Éder", 4] º/
        </pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="to array con" codeText=".entries">
        <p class="chaptrSubSect__p">Devuelve un array de pares propiedad/valor. Los métodos <code>Object.*</code> devuelven arrays de objetos “reales”, no solo un iterable</p>
        <pre class="chaptrSubSect__console wScript">
          const çuser = &#123;
            name: 'Éder',
            age: ¬4,
          &#125;;
        
          const çuserEntries = Object.ªentries(çuser);

          console.log(çuserEntries);
          ⋗ /º [["name", "Éder"], ["age", 4]] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="from array to object" codeText=".fromEntries">
        <p class="chaptrSubSect__p">Los objetos carecen de muchos métodos que existen para los arrays, (map,filter y otros), si queremos aplicarlos, entonces podemos usar <code>Object.entries</code> para convertir los pares propiedad/valor en un array, seguido de <code>Object.fromEntries</code> para transformarlo de nuevo en un objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const çbagShop = &#123;
            banana: ¬3,
            burguer: ¬2,
            kiwi: ¬3,
          &#125;;
        
          /* Convertimos los entries a un array de arrays */
          const ·entriesBagShop = Object.ªentries(çbagShop);
          console.log(·entriesBagShop);
          ⋗ /º [["banana", 3], ["burguer", 2], ["kiwi", 3]] º/

          /* Aplicamos un map para incrementar el doble cada valor */
          const ·doubledEntriesBagShop = ·entriesBagShop.ªmap(([#key, #value]) =&gt; [#key, #value * ¬2]);
          console.log(·doubledEntriesBagShop);
          ⋗ /º [["banana", 6], ["burguer", 4], ["kiwi", 6]] º/

          /* Convertimos el array modificado de nuevo a un objeto */
          const ·updatedBagShop = Object.ªfromEntries(·doubledEntriesBagShop);
          console.log(·updatedBagShop);
          ⋗ /º &#123; banana: 6, burguer: 4, kiwi: 6 &#125; º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="Symbol">
      <ChaptrSubSect h4Title="Creación y asignación" codeText="">
        <p class="chaptrSubSect__p">Permite crear valores únicos e inmutables. Son ideales para definir propiedades "ocultas" o no enumerables, o métodos en objetos sin generar conflictos con otros nombres de propiedades</p>
        <p class="chaptrSubSect__p">Los <code>Symbols</code> son valores primitivos únicos. No puedes crear uno con new <code>Symbol()</code>, y si intentas concatenarlo con una cadena, obtendrás un error</p>
        <pre class="chaptrSubSect__console wScript">
          const ·id = @Symbol();
        
          console.log(·id);
          ⋗ /º Symbol() º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Symbols con" codeText="description">
        <p class="chaptrSubSect__p">Cuando creas un <code>Symbol</code> usando <code>Symbol('description')</code>, la cadena proporcionada como argumento se convierte en una etiqueta descriptiva que sirve principalmente para facilitar la depuración (mostrar en consola o logs) y asignarles un significado humano comprensible</p>
        <pre class="chaptrSubSect__console wScript">
          const ·symb1 = @Symbol('passFacebook');
          const ·symb2 = @Symbol('passFacebook');

          console.log(·symb1 === ·symb2);
          ⋗ /º false º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Añadir a un objeto literal" codeText="">
        <p class="chaptrSubSect__p">Usando la notacion de corchetes <code>[]</code></p>
        <pre class="chaptrSubSect__console wScript">
          const ·dni = @Symbol('dniNumber');

          const çuser = &#123;
            name: 'Iker',
            [·dni]: ¬555555,
          &#125;;

          console.log(çuser);
          ⋗ /º &#123; name: 'Iker', Symbol(dniNumber): 555555 &#125; º/</pre>
        <p class="chaptrSubSect__p">Al usar el símbolo <code>dni</code> entre corchetes como clave en el objeto, se está creando una propiedad que no colisiona con otras propiedades del objeto y que no es accesible a través de métodos convencionales como <code>Object.keys()</code>. De esta manera, la propiedad <code>dni</code> no aparecerá cuando iteres sobre el objeto o cuando imprimas sus propiedades.</p>
        <p class="chaptrSubSect__p">El objeto <code>user</code> tendrá una propiedad <code>name</code> accesible de manera normal, pero la propiedad que almacena el valor <code>555555</code> está protegida usando el símbolo, lo que asegura que no sea fácilmente accesible o manipulada desde el exterior del objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const ·dni = @Symbol('dniNumber');

          const çuser = &#123;
            name: 'Iker',
            [·dni]: ¬555555,
          &#125;;

          çuser.•dni = ¬123456;               /*/º No afecta al símbolo º/*/
          console.log(çuser);
          ⋗ /º &#123; name: 'Iker', dni: 123456, Symbol(dniNumber): 555555 &#125; º/

          çuser[·dni] = ¬888888;          /*/º Modifica el símbolo º/*/
          console.log(çuser);
          ⋗ /º &#123; name: 'Iker', dni: 123456, Symbol(dniNumber): 888888 &#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Añadir a un objeto creado" codeText="">
        <p class="chaptrSubSect__p">Usando la notacion de corchetes <code>[]</code></p>
        <pre class="chaptrSubSect__console wScript">
          const ·dni = @Symbol('dniNumber');

          const çuser = &#123;
            name: 'Iker',
          &#125;;

          çuser[·dni] = ¬888888;
          console.log(çuser);
          ⋗ /º &#123; name: 'Iker', Symbol(dniNumber): 888888 &#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Symbols globales" codeText="Symbol.for()">
        <p class="chaptrSubSect__p"><code>Symbol.for(key)</code> busca en un registro global de Symbols utilizando una clave específica <code>(key)</code></p>
        <p class="chaptrSubSect__p">Si el <code>Symbol</code> con esa clave ya existe en el registro global, lo devuelve</p>
        <p class="chaptrSubSect__p">Si no existe, lo crea y lo almacena en ese registro global, de modo que pueda ser <mark>reutilizado</mark> en <mark>cualquier parte</mark> del código que acceda a esa misma clave</p>
        <pre class="chaptrSubSect__console wScript">
          const ·globalSym1 = @Symbol.for('mySymbolDesc');
          const ·globalSym2 = @Symbol.for('mySymbolDesc');

          console.log(·globalSym1 === ·globalSym2);
          ⋗ /º true º/</pre>
        <p class="chaptrSubSect__p">Ejemplo paso a paso</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos un Symbol global */
          const ·globalSym = @Symbol.for('user');

          /* Crear un objeto usando ese Symbol global como clave */
          const çuser = &#123;
            name: 'Iker',
            [#globalSym]: ¬555555
          &#125;;

          console.log(çuser[@Symbol.for('user')]);
          ⋗ 555555</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Tomar el nombre desde un global" codeText="Symbol.keyFor()">
        <p class="chaptrSubSect__p">Para devolver el nombre de un global symbol</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos un Symbol global */
          const ·globalSym = @Symbol.for('mySymbolDesc');

          /* Tomar el nombre de un global symbol */
          const ·nameFromGlobalSym = @Symbol.ªkeyFor(·globalSym);

          console.log(·nameFromGlobalSym);
          ⋗ /º 'mySymbolDesc' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Diferencias entre normales y globales" codeText="">
        <p class="chaptrSubSect__p"><code>Symbol()</code> Siempre crea un <code>Symbol</code> único y no es accesible globalmente, incluso si usas la misma descripción</p>
        <p class="chaptrSubSect__p"><code>Symbol.for()</code> Crea o recupera un <code>Symbol</code> del registro global, permitiendo que el <code>Symbol</code> sea compartido en diferentes partes del programa usando la misma clave</p>
        <pre class="chaptrSubSect__console wScript">
          const ·sym1 = @Symbol('desc');
          const ·sym2 = @Symbol('desc');

          console.log(·sym1 === ·sym2);
          ⋗ /º false º/

          const ·globalSym1 = @Symbol.for('desc2');
          const ·globalSym2 = @Symbol.for('desc2');

          console.log(·globalSym1 === ·globalSym2);
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Conversión a primitivo" codeText="Symbol.toPrimitive">
        <p class="chaptrSubSect__p">Es un <code>Symbol</code> incorporado en JavaScript que se usa como clave especial en los objetos. Al implementar una función con <code>Symbol.toPrimitive</code>, le puedes decir a JavaScript cómo convertir un objeto a un valor primitivo cuando se necesita</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          çobj[@Symbol.ªtoPrimitive](#hint);
        </pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><code>obj</code>: Es el objeto al que quieres definir la conversión.</li>
          <li class="chaptrSubSectUl__li"><code>Symbol.toPrimitive</code>: Es la propiedad especial que le dice a JavaScript cómo convertir este objeto a un valor primitivo.</li>
          <li class="chaptrSubSectUl__li"><code>hint</code>: Es un argumento que le dice al método en qué tipo primitivo se espera convertir el objeto. Los posibles valores de hint son:</li>
          <li class="chaptrSubSectUl__li--sub"><code>string</code>: JavaScript espera que el objeto se convierta en un string.</li>
          <li class="chaptrSubSectUl__li--sub"><code>number</code>: JavaScript espera que el objeto se convierta en un número.</li>
          <li class="chaptrSubSectUl__li--sub"><code>default</code>: No está claro si JavaScript espera un string o un número, pero en este caso debes decidir cuál devolver.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          const çuser = &#123;
            name: 'Éder',
            age: ¬4,
            [@Symbol.ªtoPrimitive](#hint) &#123;
              if (#hint === 'string') &#123;
                return this.•name;
              &#125;
              if (#hint === 'number') &#123;
                return this.•age;
              &#125;
              return this.•age;   /*/º default º/*/
            &#125;,
          &#125;;

          console.log(@String(çuser));
          ⋗ /º sugerencia: string º/
          ⋗ /º 'Éder' º/

          console.log(@Number(çuser));
          ⋗ /º sugerencia: number º/
          ⋗ /º 4 º/

          console.log(çuser + ¬4);
          ⋗ /º sugerencia: default º/
          ⋗ /º 8 º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Conversión a primitivo alternativa" codeText="">
        <p class="chaptrSubSect__p">Proporcionan una forma alternativa “al viejo estilo” de implementar la conversión</p>
        <pre class="chaptrSubSect__console wScript">
          const çuser = &#123;
            name: 'Éder',
            age: ¬4,

            @toString() &#123;    /* para sugerencia string */
              return this.•name;
            &#125;,

            @valueOf() &#123;    /* para sugerencia number o default */
              return this.•age;
            &#125;,

          &#125;;

          console.log(@String(çuser));
          ⋗ /º sugerencia: string º/
          ⋗ /º 'Éder' º/

          console.log(@Number(çuser));
          ⋗ /º sugerencia: number º/
          ⋗ /º 4 º/

          console.log(çuser + ¬4);
          ⋗ /º sugerencia: default º/
          ⋗ /º 8 º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_11" nextPage="/lessons/lesson_15"/>
</MainLayout>


<!-- 
&lt;&gt;
()&#123;&#125;
﹛﹜    Llaves no estiladas
﹕     2 puntos no estilizados
ªmétodos
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ ∞Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">
＃
-->
