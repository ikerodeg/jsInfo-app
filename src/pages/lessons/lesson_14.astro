---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__14" h2Title="Objetos" slot="mainContent">
    <ChaptrSect h3Title="CreaciÃ³n de objetos" codeText="">
      <ChaptrSubSect h4Title="NotaciÃ³n literal" codeText="{}">
        <p class="chaptrSubSect__p">Se guarda en una variable (<mark>se recomienda usar </mark><code>const</code>) con un nombre y se usa un par llaves. Es la manera mÃ¡s rÃ¡pida y se considera buenas practicas</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§myObject = &#123; name: 'Eder' &#125;;
        
          console.log(Ã§myObject);
          â‹— /Âº&#123; name: 'Eder' &#125;Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Constructor" codeText="Object">
        <p class="chaptrSubSect__p">Usando el constructor <code>new</code> y <code>Object</code> y el operador <code>new</code></p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§myObject = new Object();
          Ã§myObject.â€¢name = 'Eder';
        
          console.log(Ã§myObject);
          â‹— /Âº&#123; name: 'Eder' &#125;Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Factory Function" codeText="">
        <p class="chaptrSubSect__p">Usando una funciÃ³n a la que se le pasa unos parÃ¡metros</p>
        <pre class="chaptrSubSect__console wScript">
          function @makeObjects(#name) &#123;
            return &#123;
              name: #name,
            &#125;;
          &#125;;

          const Ã§myObject = @makeObjects('Eder');
          console.log(Ã§myObject);
          â‹— /Âº&#123; name: 'Eder' &#125;Âº/</pre>
        <p class="chaptrSubSect__p">En el ejemplo anterior las propiedades tienen los mismos nombres que las variables, pero podemos simplemente escribir un Ãºnico nombre como propiedad/valor</p>
        <pre class="chaptrSubSect__console wScript">
          function @makeObjects(#name, #age) &#123;
            return &#123;
              #name,
              #age
            &#125;;
          &#125;;

          const Ã§myObject = @makeObjects('Eder', Â¬5);
          console.log(Ã§myObject);
          â‹— /Âº&#123; name: 'Eder', age: 5 &#125;Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Acceso a propiedades" codeText="">
      <ChaptrSubSect h4Title="Operador del punto" codeText=".">
        <p class="chaptrSubSect__p">Se puede acceder a los valores de las propiedades utilizando el operador del punto</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§eder = &#123;
            age: Â¬5,
            height: Â¬112,
          &#125;;

          console.log(Ã§eder.â€¢height);
          â‹— /Âº 112 Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Operador de corchete" codeText="[ ]">
        <p class="chaptrSubSect__p">Es mÃ¡s versÃ¡til y permite el acceso dinÃ¡mico a las propiedades del objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§eder = &#123;
            age: Â¬5,
            height: Â¬112,
          &#125;;

          console.log(Ã§eder['height']);           /*/Âº Ojo con las comillas Âº/*/
          â‹— /Âº 112 Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Actualizar propiedades" codeText="">
      <ChaptrSubSect h4Title="Operador del punto" codeText=".">
        <p class="chaptrSubSect__p">Se puede actualizar los valores de las propiedades utilizando el operador del punto</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§eder = &#123;
            age: Â¬5,
            height: Â¬112,
          &#125;;

          Ã§eder.â€¢height = Â¬117;

          console.log(Ã§eder);
          â‹— /Âº &#123; age: 5, height: 117 &#125; Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Operador del corchete" codeText="[]">
        <p class="chaptrSubSect__p">Se puede actualizar los valores de las propiedades utilizando el operador del corchete</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§eder = &#123;
            age: Â¬5,
            height: Â¬112,
          &#125;;

          Ã§eder['height'] = Â¬117;

          console.log(Ã§eder);
          â‹— /Âº &#123; age: 5, height: 117 &#125; Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Agregar propiedades" codeText="">
      <ChaptrSubSect h4Title="Operador del punto" codeText=".">
        <p class="chaptrSubSect__p">Se puede agregar propiedades utilizando el operador del punto</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§eder = &#123;
            age: Â¬5,
            height: Â¬117,
          &#125;;

          Ã§eder.â€¢weight = Â¬30;

          console.log(Ã§eder);
          â‹— /Âº &#123; age: 5, height: 117, weight: 30 &#125; Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Operador del corchete" codeText="[]">
        <p class="chaptrSubSect__p">Se puede agregar propiedades utilizando el operador del corchete</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§eder = &#123;
            age: Â¬5,
            height: Â¬117,
          &#125;;

          Ã§eder['weight'] = Â¬30;

          console.log(Ã§eder);
          â‹— /Âº &#123; age: 5, height: 117, weight: 30 &#125; Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Variables externas" codeText="">
        <p class="chaptrSubSect__p">Se puede agregar propiedades cuyo valor sea el de una variable externa</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·weight = Â¬30;

          const Ã§eder = &#123;
            age: Â¬5,
            height: Â¬117,
          &#125;;

          Ã§eder.â€¢weight = Â·weight;
          
          console.log(Ã§eder);
          â‹— /Âº &#123; age: 5, height: 117, weight: 30 &#125; Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Borrado de propiedades" codeText="">
      <ChaptrSubSect h4Title="Operador" codeText="delete">
        <p class="chaptrSubSect__p">Se puede borrar propiedades utilizando el operador <code>delete</code></p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§eder = &#123;
            age: Â¬5,
            height: Â¬117,
            weight: Â¬30,
          &#125;;

          delete Ã§eder.â€¢weight;           /*/Âº No da error si no existe la propiedad Âº/*/
          
          console.log(Ã§eder);
          â‹— /Âº &#123; age: 5, height: 117 &#125; Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Vaciado de objeto" codeText="">
      <ChaptrSubSect h4Title="Manteniendo la ref al objeto original" codeText="">
        <p class="chaptrSubSect__p">Cuando vacÃ­as un objeto usando un bucle <code>for...in</code> o <code>Object.keys()</code> y <code>delete</code>, eliminas las propiedades del objeto original <mark>manteniendo la referencia</mark> al mismo. Esto es Ãºtil cuando quieres que cualquier referencia a ese objeto en otros lugares (por ejemplo, otras variables que apuntan al mismo objeto) tambiÃ©n vean los cambios</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§shopListBase = &#123;
            verduras: Â¬5,
            carnes: Â¬7,
            frutas: Â¬10,
          &#125;;

          /* Creamos una nueva referencia al objeto original */
          const Ã§shopListNew = Ã§shopListBase;

          console.log(Ã§shopListNew);                 /* verificamos objeto nuevo */
          â‹— /Âº&#123; verduras: 5, carnes: 7, frutas: 10 &#125;Âº/

          /* Vaciamos el objeto original */
          Object.Âªkeys(Ã§shopListBase).@forEach(#prop =&gt; delete Ã§shopListBase[#prop]);

          console.log(Ã§shopListNew);                /* verificamos objeto nuevo */
          â‹— /Âº&#123; &#125;Âº/                 /* el objeto nuevo tambiÃ©n se ha vaciado */</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Rompiendo la ref al objeto original" codeText="">
        <p class="chaptrSubSect__p">Cuando reasignas a un objeto un objeto vacÃ­o lo que haces es que ahora apunte a un nuevo objeto en memoria, pero las otras referencias al objeto original seguirÃ¡n apuntando al antiguo objeto, no al nuevo <mark>eliminando la referencia</mark> al objeto original</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§shopListBase = &#123;
            verduras: Â¬5,
            carnes: Â¬7,
            frutas: Â¬10,
          &#125;;

          /* Creamos una nueva referencia al objeto original */
          const Ã§shopListNew = Ã§shopListBase;

          console.log(Ã§shopListNew);
          â‹— /Âº&#123; verduras: 5, carnes: 7, frutas: 10 &#125;Âº/

          /* Reasignamos el objeto original a un nuevo objeto vacÃ­o */
          Ã§shopListBase = &#123;&#125;;              /*/Âº Ojo aquÃ­ da error si usamos const Âº/*/;

          console.log(Ã§shopListNew);
          â‹— /Âº&#123; &#125;Âº/                 /* ahora estÃ¡ vacÃ­o */
        
          console.log(Ã§shopListBase);
          â‹— /Âº&#123; verduras: 5, carnes: 7, frutas: 10 &#125;Âº/ /* sigue teniendo los valores originales */</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Buscar propiedades" codeText="key">
      <ChaptrSubSect h4Title="Operador" codeText="in">
        <p class="chaptrSubSect__p">El operador <code>in</code> devuelve <code>true</code> si la propiedad especificada estÃ¡ en el objeto especificado o su prototipo</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§engineModel1 = &#123;
            tipo: 'gasolina',
            cv: Â¬375,
            turbo: true,
            mod: '/Âº 1.5Mod RR Âº/',
          &#125;;

          console.log('mod' Â¬in Ã§engineModel1);           /*/Âº Si existe la propiedad 'mod' Âº/*/
          â‹— /Âº true Âº/</pre>
          <p class="chaptrSubSect__p">Si omitimos las comillas, significa que buscarÃ¡ el valor de esa variable dentro del objeto. En este caso lo que busca es si <code>'1.5Mod RR'</code> forma parte de las propiedades del objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·mod = '/Âº 1.5Mod RR Âº/';

          const Ã§engineModel1 = &#123;
            tipo: 'gasolina',
            cv: Â¬375,
            turbo: true,
            mod: Â·mod,
          &#125;;

          console.log(Â·mod Â¬in Ã§engineModel1);           /*/Âº Busca la propiedad 1.5Mod RR Âº/*/
          â‹— /Âº false Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="IteraciÃ³n sobre propiedades" codeText="keys">
      <ChaptrSubSect h4Title="El ciclo" codeText="for..in">
        <p class="chaptrSubSect__p">Sirve para recorrer las propiedades de un objeto, itera no solo sobre el objeto original lo hace sobre los aÃ±adidos despuÃ©s. Admite <code>break</code> y <code>continue</code></p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§engineModel1 = &#123;
            tipo: 'gasolina',
            cv: Â¬375,
            turbo: true,
            mod: '/Âº 1.5Mod RR Âº/',
          &#125;;

          for (let #prop Â¬in Ã§engineModel1) &#123;
            console.log(#prop);
          &#125;

          â‹— /Âº 'tipo' Âº/
          â‹— /Âº 'cv' Âº/
          â‹— /Âº 'turbo' Âº/
          â‹— /Âº 'mod' Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText="Object.keys()">
        <p class="chaptrSubSect__p">Sirve para recorrer las propiedades de un objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§engineModel1 = &#123;
            tipo: 'gasolina',
            cv: Â¬375,
            turbo: true,
            mod: '/Âº 1.5Mod RR Âº/',
          &#125;;

          for (let #prop of Object.Âªkeys(Ã§engineModel1)) &#123;
            console.log(#prop);
          &#125;

          â‹— /Âº 'tipo' Âº/
          â‹— /Âº 'cv' Âº/
          â‹— /Âº 'turbo' Âº/
          â‹— /Âº 'mod' Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="IteraciÃ³n sobre valores" codeText="values">
      <ChaptrSubSect h4Title="El ciclo" codeText="for..in">
        <p class="chaptrSubSect__p">TambiÃ©n sirve para recorrer los valores de las propiedades</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§engineModel1 = &#123;
            tipo: 'gasolina',
            cv: Â¬375,
            turbo: true,
            mod: '/Âº 1.5Mod RR Âº/',
          &#125;;

          for (let #prop Â¬in Ã§engineModel1) &#123;
            console.log(Ã§engineModel1[#prop]);
          &#125;

          â‹— /Âº"gasolina"Âº/
          â‹— /Âº 375 Âº/
          â‹— /ÂºtrueÂº/
          â‹— /Âº"1.5Mod RR"Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText="Object.values()">
        <p class="chaptrSubSect__p">Sirve para recorrer los valores de un objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§engineModel1 = &#123;
            tipo: 'gasolina',
            cv: Â¬375,
            turbo: true,
            mod: '/Âº 1.5Mod RR Âº/',
          &#125;;

          for (let #value of Object.Âªvalues(Ã§engineModel1)) &#123;
            console.log(#value);
          &#125;

          â‹— /Âº "gasolina" Âº/
          â‹— /Âº 375 Âº/
          â‹— /Âº true Âº/
          â‹— /Âº "1.5Mod RR" Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="IteraciÃ³n sobre pares" codeText="">
      <ChaptrSubSect h4Title="El ciclo" codeText="for..in">
        <p class="chaptrSubSect__p">Podemos mostrar los pares <mark>keys</mark> + <mark>values</mark></p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§engineModel1 = &#123;
            tipo: 'gasolina',
            cv: Â¬375,
            turbo: true,
            mod: '/Âº 1.5Mod RR Âº/',
          &#125;;

          for (let #prop Â¬in Ã§engineModel1) &#123;
            console.log(`$&#123;#prop&#125;: $&#123;Ã§engineModel1[#prop]&#125;`);
          &#125;

          â‹— /Âº tipo: Âº/ /Âº"gasolina"Âº/
          â‹— /Âº cv: Âº/ /Âº 375 Âº/
          â‹— /Âº turbo: Âº/ /ÂºtrueÂº/
          â‹— /Âº mod: Âº/ /Âº"1.5Mod RR"Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText="Object.entries()">
        <p class="chaptrSubSect__p">Devuelve un <mark>array de arrays</mark>, donde cada par de arrays representa una entrada en el objeto original. Cada par consiste en una clave (nombre de la propiedad) y su valor correspondiente, en ese orden</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§engineModel1 = &#123;
            tipo: 'gasolina',
            cv: Â¬375,
            turbo: true,
            mod: '/Âº 1.5Mod RR Âº/',
          &#125;;

          for (let #propValue of Object.Âªentries(Ã§engineModel1)) &#123;
            console.log(#propValue);
          &#125;

          â‹— /Âº [tipo: Âº/ /Âº"gasolina"] Âº/
          â‹— /Âº [cv: Âº/ /Âº 375] Âº/
          â‹— /Âº [turbo: Âº/ /Âºtrue] Âº/
          â‹— /Âº [mod: Âº/ /Âº"1.5Mod RR"] Âº/</pre>
        <p class="chaptrSubSect__p">TambiÃ©n lo podemos asignar directamente a una variable</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§engineModel1 = &#123;
            tipo: 'gasolina',
            cv: Â¬375,
            turbo: true,
            mod: '/Âº 1.5Mod RR Âº/',
          &#125;;

          const Â·entriesEngineModel1 = Object.Âªentries(Ã§engineModel1);

          console.log(Â·entriesEngineModel1);

          â‹— /Âº [ Âº/
              /Âº [tipo: Âº/ /Âº"gasolina"], Âº/
              /Âº [cv: Âº/ /Âº 375], Âº/
              /Âº [turbo: Âº/ /Âºtrue], Âº/
              /Âº [mod: Âº/ /Âº"1.5Mod RR"] Âº/
          /Âº ] Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Copia de objetos" codeText="">
      <ChaptrSubSect h4Title="Copia superficial con" codeText="for..in">
        <p class="chaptrSubSect__p">Hace una <mark>copia superficial</mark> <mark>shallow copy</mark> del objeto. Solo se copian las propiedades del objeto principal, pero si el objeto original contiene propiedades que son otros objetos, esos objetos anidados <b>NO</b> se clonan profundamente</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§persona1 = &#123;
            nombre: 'Iker',
            edad: Â¬48,
          &#125;;

          const Ã§persona2 = &#123;&#125;;

          for (let #prop Â¬in Ã§persona1) &#123;
            Ã§persona2[#prop] = Ã§persona1[#prop];
          &#125;

          Ã§persona2.â€¢nombre = 'Eder';
          Ã§persona2.â€¢edad = Â¬5;

          console.log(Ã§persona2);
          â‹— /Âº&#123; nombre: 'Eder', edad: 5 &#125;Âº/
          console.log(Ã§persona1);
          â‹— /Âº&#123; nombre: 'Iker', edad: 48 &#125;Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Copia superficial con" codeText="spread {...obj}">
        <p class="chaptrSubSect__p">Hace una <mark>copia superficial</mark> <mark>shallow copy</mark> del objeto. Solo se copian las propiedades del objeto principal, pero si el objeto original contiene propiedades que son otros objetos, esos objetos anidados <b>NO</b> se clonan profundamente</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§persona1 = &#123;
            nombre: 'Iker',
            edad: Â¬48,
          &#125;;

          Ã§persona2 = &#123;...Ã§persona1&#125;;

          Ã§persona2.â€¢nombre = 'Eder';
          Ã§persona2.â€¢edad = Â¬5;

          console.log(Ã§persona2);
          â‹— /Âº&#123; nombre: 'Eder', edad: 5 &#125;Âº/
          console.log(Ã§persona1);
          â‹— /Âº&#123; nombre: 'Iker', edad: 48 &#125;Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Copia superficial con" codeText="Object.assign()">
        <p class="chaptrSubSect__p">Hace una <mark>copia superficial</mark> <mark>shallow copy</mark> del objeto. Solo se copian las propiedades del objeto principal, pero si el objeto original contiene propiedades que son otros objetos, esos objetos anidados <b>NO</b> se clonan profundamente</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§persona1 = &#123;
            nombre: 'Iker',
            edad: Â¬48,
          &#125;;

          Ã§persona2 = &#123; &#125;;
          Object.Âªassign(Ã§persona2, Ã§persona1);
          
          Ã§persona2.â€¢nombre = 'Eder';
          Ã§persona2.â€¢edad = Â¬5;

          console.log(Ã§persona2);
          â‹— /Âº&#123; nombre: 'Eder', edad: 5 &#125;Âº/
          console.log(Ã§persona1);
          â‹— /Âº&#123; nombre: 'Iker', edad: 48 &#125;Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Copia profunda con" codeText="structuredClone()">
        <p class="chaptrSubSect__p">Realiza una copia profunda <mark>deepClone</mark>, incluidas todas las propiedades anidadas. Primero convierte el objeto en una cadena <mark>JSON</mark> para despuÃ©s a partir de esa cadena, crear un nuevo objeto. Sin embargo, esta tÃ©cnica solo funciona si el objeto y sus propiedades son serializables en <mark>JSON</mark>. Si el objeto contiene propiedades no serializables, como <mark><b>funciones</b></mark> o referencias a objetos no serializables, <b>NO</b> funcionarÃ¡</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§persona1 = &#123;
            nombre: 'Iker',
            edad: Â¬48,
          &#125;;

          Ã§persona2 = structuredClone(Ã§persona1);

          Ã§persona2.â€¢nombre = 'Eder';
          Ã§persona2.â€¢edad = Â¬5;

          console.log(Ã§persona2);
          â‹— /Âº&#123; nombre: 'Eder', edad: 5 &#125;Âº/
          console.log(Ã§persona1);
          â‹— /Âº&#123; nombre: 'Iker', edad: 48 &#125;Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="MÃ©todos de objeto" codeText="">
      <ChaptrSubSect h4Title="Forma literal" codeText="">
        <p class="chaptrSubSect__p">Una funciÃ³n que es la propiedad de un objeto, es denominada su <mark>mÃ©todo</mark></p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§persona1 = &#123;
            nombre: 'Eder',
            edad: Â¬5,
            sayHi: @function() &#123;
              console.log('/Âº Hola que tal! Âº/');
            &#125;,
          &#125;;

          Ã§persona1.ÂªsayHi();
          â‹— /Âº "Hola que tal!" Âº/</pre>
        <p class="chaptrSubSect__p">Existe una sintaxis mÃ¡s corta para los mÃ©todos en objetos literales. Podemos omitir <code>function</code> y simplemente escribir <code>sayHi()</code>. En casi todos los casos la sintaxis abreviada es la <mark>preferida</mark></p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§persona1 = &#123;
            nombre: 'Eder',
            edad: Â¬5,
            @sayHi() &#123;
              console.log('/Âº Hola que tal! Âº/');
            &#125;,
          &#125;;

          Ã§persona1.ÂªsayHi();
          â‹— /Âº "Hola que tal!" Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="ExpresiÃ³n de funciÃ³n + asignaciÃ³n" codeText="">
        <p class="chaptrSubSect__p">Podemos aÃ±adir una expresion de funciÃ³n ya declarada a nuestro objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·sayHi = @function() &#123;
            console.log('/Âº Hola que tal! Âº/');
          &#125;;

          const Ã§persona1 = &#123;
            nombre: 'Eder',
            edad: Â¬5,
            sayHi: Â·sayHi,
          &#125;;

          Ã§persona1.ÂªsayHi();
          â‹— /Âº "Hola que tal!" Âº/</pre>
        <p class="chaptrSubSect__p">TambiÃ©n podemos aÃ±adirla al objeto con el mÃ©todo del punto</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·sayHi = @function() &#123;
            console.log('/Âº Hola que tal! Âº/');
          &#125;;

          const Ã§persona1 = &#123;
            nombre: 'Eder',
            edad: Â¬5,
          &#125;;

          Ã§persona1.ÂªsayHi = Â·sayHi;

          Ã§persona1.ÂªsayHi();
          â‹— /Âº "Hola que tal!" Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="La palabra clave" codeText="this">
      <ChaptrSubSect h4Title="Uso de" codeText="this">
        <p class="chaptrSubSect__p">Es comÃºn que un <mark>mÃ©todo de objeto</mark> necesite acceder a la informaciÃ³n almacenada en el objeto para cumplir su tarea. Por ejemplo, el cÃ³digo dentro de <code>obj1.explain()</code> puede necesitar acceder a la propiedad <code>expl</code></p>
        <p class="chaptrSubSect__p">Para acceder al objeto, un mÃ©todo puede usar la palabra clave <code>this</code>, el valor de <code>this</code> es el objeto â€œantes del puntoâ€, el usado para llamar al mÃ©todo</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§obj1 = &#123;
            expl: 'Hola desde el objeto 1',
            @explain() &#123;
              console.log('/Âº $&#123;this.expl&#125; Âº/');
            &#125;,
          &#125;;


          Ã§obj1.Âªexplain();
          â‹— /Âº "Hola desde el objeto 1 Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Las funciones flecha no tienen" codeText="this">
        <p class="chaptrSubSect__p">Las funciones de flecha son especiales: ellas no tienen su â€œpropioâ€ <code>this</code>. Si nosotros hacemos referencia a <code>this</code> desde tales funciones, esta serÃ¡ tomada desde afuera de la funciÃ³n â€œnormalâ€</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§obj1 = &#123;
            expl: 'Hola desde el objeto 1',
            @explain() =&gt; &#123;
              console.log('/Âº $&#123;this.expl&#125; Âº/');
            &#125;,
          &#125;;


          Ã§obj1.Âªexplain();
          â‹— /Âº Error Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="ReutilizaciÃ³n de mÃ©todos" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".call">
        <p class="chaptrSubSect__p">Podemos usar una funciÃ³n exterior en cada objeto que tengamos para no escribir un mÃ©todo repetido en cada uno de ellos, y aplicarlo a cada uno con <code>call</code></p>
        <pre class="chaptrSubSect__console wScript">
          function @method1(#likes) &#123;
            console.log(`/Âº $&#123;this.name&#125;: $&#123;#likes&#125; likesÂº/`);
          &#125;;

          const Ã§user1 = &#123; name: 'Eder' &#125;;
          const Ã§user2 = &#123; name: 'Iker' &#125;;

          Ã§user1.Âªmethod1(Â¬50);
          â‹— /Âº "Eder: 50 likesÂº/

          Ã§user2.Âªmethod1(Â¬10);
          â‹— /Âº "Iker: 10 likesÂº/</pre>
        <p class="chaptrSubSect__p">Tambien podemos llamar a un mÃ©todo dentro de un objeto para que sea usado en otro</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§user1 = &#123;
            name: 'Eder',
            @showInfo(#likes, #friends) &#123;
              return `/Âº $&#123;this.name&#125;: $&#123;#likes&#125; likes, $&#123;#friends&#125; amigos Âº/`;
            &#125;,
          &#125;;

          const Ã§user2 = &#123; name: 'Iker' &#125;;

          console.log(Ã§user1.ÂªshowInfo.Âªcall(Ã§user2, Â¬9, Â¬4));
          â‹— /Âº "Iker: 9 likes, 4 amigos Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".apply">
        <p class="chaptrSubSect__p">La Ãºnica diferencia con <code>call</code> es la forma en que recibe los parÃ¡metros. A <code>apply</code> se le pasa los parÃ¡metros por medio de un array</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§user1 = &#123;
            name: 'Eder',
            @showInfo(#likes, #friends) &#123;
              return `/Âº $&#123;this.name&#125;: $&#123;#likes&#125; likes, $&#123;#friends&#125; amigos Âº/`;
            &#125;,
          &#125;;

          const Ã§user2 = &#123; name: 'Iker' &#125;;
        
          console.log(Ã§user1.ÂªshowInfo.Âªapply(Ã§user2, [Â¬9, Â¬4]));
          â‹— /Âº "Iker: 9 likes, 4 amigos Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".bind">
        <p class="chaptrSubSect__p">Crea una funciÃ³n en base a la funciÃ³n que vamos a enlazar. <mark>Retorna una funciÃ³n</mark> con el nuevo contexto. Al igual que las otras dos de arriba, se trata de mantener el "contexto" para poder seguir usando <code>this</code></p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§user1 = &#123;
            name: 'Eder',
            @eat(#food) &#123;
              return `/Âº $&#123;this.name&#125; come $&#123;#food&#125;Âº/`;
            &#125;,
          &#125;;

          const Ã§user2 = &#123; name: 'Iker' &#125;;

          const Â·comidaUser2 = Ã§user1.Âªeat.bind(Ã§user2);

          console.log(Â·comidaUser2('pizza'));
          â‹— /Âº "Iker come pizzaÂº/</pre>
        <p class="chaptrSubSect__p">Como el mÃ©todo <code>bind</code> devuelve una funciÃ³n, para invocarla necesitamos almacenarla en una variable, como si fuera una expresion de funciÃ³n. Digamos que podemos crear mÃ©todos para usarlos en distintos objetos</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§user1 = &#123; name: 'Eder' &#125;;
          const Ã§user2 = &#123; name: 'Iker' &#125;;
          
          function @greet() &#123;
            console.log(`/Âº Hola soy $&#123;this.name&#125; Âº/`);
          &#125;

          const Â·greetEder = @greet.bind(Ã§user1);
          const Â·greetIker = @greet.bind(Ã§user2);

          Â·greetEder();
          â‹— /Âº "Hola soy Eder Âº/
        
          Â·greetIker();
          â‹— /Âº "Hola soy Iker Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="FunciÃ³n constructora" codeText="">
      <ChaptrSubSect h4Title="CreaciÃ³n de la funciÃ³n" codeText="">
        <p class="chaptrSubSect__p">La funciÃ³n constructora es nombrada con la <mark>primera letra en mayÃºsculas</mark>, y pasamos los parÃ¡metros entre parÃ©ntesis que en el objeto serÃ¡n las propiedades</p>
        <pre class="chaptrSubSect__console wScript">
          function @Car(#make, #model, #year) &#123;
            this.â€¢make = #make;
            this.â€¢model = #model;
            this.â€¢year = #year;
          &#125;;</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="CreaciÃ³n de objetos con" codeText="new">
        <p class="chaptrSubSect__p">Asignamos a una variable el resultado de ejecutar la funciÃ³n constructora, pasÃ¡ndole los argumentos que serÃ¡n los valores de las propiedades ya predefinidas usando el operador <code>new</code></p>
        <pre class="chaptrSubSect__console wScript">
          function @Car(#make, #model, #year) &#123;
            this.â€¢make = #make;
            this.â€¢model = #model;
            this.â€¢year = #year;
          &#125;;

          /* MÃ©todo compartido por todas las futuras instancias de Car */
          @Car.Âªprototype.Âªstart = @function() &#123;
            console.log(`$&#123;this.make&#125; $&#123;this.model&#125; arranca ğŸš—`);
          &#125;;

          const Â·myCar = new @Car('Nissan', '/Âº GT-R Âº/', Â¬2024);
          const Â·anotherCar = new @Car('Ford', '/Âº RS-Cosworth Âº/', Â¬2000);

          console.log(Â·myCar);
          â‹— /Âº &#123; make: 'Nissan', model: "GT-R", year: 2024 &#125; Âº/

          console.log(Â·anotherCar);
          â‹— /Âº &#123; make: 'Ford', model: "RS-Cosworth", year: 2000 &#125; Âº/

          Â·myCar.Âªstart();
          â‹— /Âº "Nissan GT-R arranca ğŸš—" Âº/

          Â·anotherCar.Âªstart();
          â‹— /Âº "Ford RS-Cosworth arranca ğŸš—" Âº/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Cada vez que llamamos a la funciÃ³n con <code>new</code>, se crea un nuevo objeto <b>vacio</b> y se asigna a la variable.</li>
          <li class="chaptrSubSectUl__li">Asigna ese nuevo objeto creado al <code>this</code> dentro de la funciÃ³n.</li>
          <li class="chaptrSubSectUl__li">AÃ±ade la propiedad <code>prototype</code> de la funciÃ³n al objeto (para heredar mÃ©todos si los hay).</li>
          <li class="chaptrSubSectUl__li">Devuelve ese objeto automÃ¡ticamente aunque no uses <code>return</code>.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Constructor modo test" codeText="new.target">
        <p class="chaptrSubSect__p">En funciones constructoras, si olvidas usar <code>new</code>, la funciÃ³n puede no comportarse como esperas, porque <code>this</code> no apuntarÃ¡ a un nuevo objeto, sino al contexto global o <code>undefined</code> en modo estricto</p>
        <p class="chaptrSubSect__p">Usar <code>new.target</code> permite verificar si una funciÃ³n ha sido llamada correctamente con <code>new</code>. Si no ha sido llamada con <code>new</code>, se puede corregir el error automÃ¡ticamente, como en el ejemplo que vemos</p>
        <pre class="chaptrSubSect__console wScript">
          function @Jugador(#name) &#123;
            if (!Ã§new.â€¢target) &#123;                   
              return new @Jugador(#name);     /*/Âº Si se olvidÃ³ new, lo aplicamos automÃ¡ticamente Âº/*/
              console.log('/Âº Se olvidÃ³ usar new, corrigiendo...Âº/');
            &#125;
            console.log('/Âº Constructor llamado correctamente con new Âº/');
            this.â€¢name = #name;
          &#125;;

          const Â·lateralIzq = @Jugador('Ã‰der');          /*/Âº Olvidamos usar new Âº/*/
          â‹— /Âº Se olvidÃ³ usar new, corrigiendo...Âº/

          const Â·delantero = new @Jugador('Iker');       /*/Âº Usamos new correctamente Âº/*/
          â‹— /Âº Constructor llamado correctamente con new Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="MÃ©todos en el constructor" codeText="">
        <p class="chaptrSubSect__p">Podemos agregar a <code>this</code> no sÃ³lo propiedades, sino tambiÃ©n mÃ©todos</p>
        <pre class="chaptrSubSect__console wScript">
          function @Jugador(#name) &#123;
            this.â€¢name = #name;
            this.â€¢greet = @function() &#123;
              console.log(`/Âº Hola soy $&#123;this.name&#125; Âº/`);
            &#125;;
          &#125;;

          const Â·lateralIzq = new @Jugador('Ã‰der');
          const Â·delantero = new @Jugador('Iker');

          Â·lateralIzq.Âªgreet();
          â‹— /Âº "Hola soy Ã‰der" Âº/

          Â·delantero.Âªgreet();
          â‹— /Âº "Hola soy Iker" Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="ConversiÃ³n a primitivo" codeText="">
      <ChaptrSubSect h4Title="to array con" codeText=".keys">
        <p class="chaptrSubSect__p">Devuelve un array de propiedades. Los mÃ©todos <code>Object.*</code> devuelven arrays de objetos â€œrealesâ€, no solo un iterable</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§user = &#123;
            name: 'Ã‰der',
            age: Â¬4,
          &#125;;
        
          const Ã§userKeys = Object.Âªkeys(Ã§user);

          console.log(Ã§userKeys);
          â‹— /Âº ["name", "age"] Âº/
        </pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="to array con" codeText=".values">
        <p class="chaptrSubSect__p">Devuelve un array de valores. Los mÃ©todos <code>Object.*</code> devuelven arrays de objetos â€œrealesâ€, no solo un iterable</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§user = &#123;
            name: 'Ã‰der',
            age: Â¬4,
          &#125;;

          const Ã§userValues = Object.Âªvalues(Ã§user);

          console.log(Ã§userValues);
          â‹— /Âº ["Ã‰der", 4] Âº/
        </pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="to array con" codeText=".entries">
        <p class="chaptrSubSect__p">Devuelve un array de pares propiedad/valor. Los mÃ©todos <code>Object.*</code> devuelven arrays de objetos â€œrealesâ€, no solo un iterable</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§user = &#123;
            name: 'Ã‰der',
            age: Â¬4,
          &#125;;
        
          const Ã§userEntries = Object.Âªentries(Ã§user);

          console.log(Ã§userEntries);
          â‹— /Âº [["name", "Ã‰der"], ["age", 4]] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="from array to object" codeText=".fromEntries">
        <p class="chaptrSubSect__p">Los objetos carecen de muchos mÃ©todos que existen para los arrays, (map,filter y otros), si queremos aplicarlos, entonces podemos usar <code>Object.entries</code> para convertir los pares propiedad/valor en un array, seguido de <code>Object.fromEntries</code> para transformarlo de nuevo en un objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§bagShop = &#123;
            banana: Â¬3,
            burguer: Â¬2,
            kiwi: Â¬3,
          &#125;;
        
          /* Convertimos los entries a un array de arrays */
          const Â·entriesBagShop = Object.Âªentries(Ã§bagShop);
          console.log(Â·entriesBagShop);
          â‹— /Âº [["banana", 3], ["burguer", 2], ["kiwi", 3]] Âº/

          /* Aplicamos un map para incrementar el doble cada valor */
          const Â·doubledEntriesBagShop = Â·entriesBagShop.Âªmap(([#key, #value]) =&gt; [#key, #value * Â¬2]);
          console.log(Â·doubledEntriesBagShop);
          â‹— /Âº [["banana", 6], ["burguer", 4], ["kiwi", 6]] Âº/

          /* Convertimos el array modificado de nuevo a un objeto */
          const Â·updatedBagShop = Object.ÂªfromEntries(Â·doubledEntriesBagShop);
          console.log(Â·updatedBagShop);
          â‹— /Âº &#123; banana: 6, burguer: 4, kiwi: 6 &#125; Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="Symbol">
      <ChaptrSubSect h4Title="CreaciÃ³n y asignaciÃ³n" codeText="">
        <p class="chaptrSubSect__p">Permite crear valores Ãºnicos e inmutables. Son ideales para definir propiedades "ocultas" o no enumerables, o mÃ©todos en objetos sin generar conflictos con otros nombres de propiedades</p>
        <p class="chaptrSubSect__p">Los <code>Symbols</code> son valores primitivos Ãºnicos. No puedes crear uno con new <code>Symbol()</code>, y si intentas concatenarlo con una cadena, obtendrÃ¡s un error</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·id = @Symbol();
        
          console.log(Â·id);
          â‹— /Âº Symbol() Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Symbols con" codeText="description">
        <p class="chaptrSubSect__p">Cuando creas un <code>Symbol</code> usando <code>Symbol('description')</code>, la cadena proporcionada como argumento se convierte en una etiqueta descriptiva que sirve principalmente para facilitar la depuraciÃ³n (mostrar en consola o logs) y asignarles un significado humano comprensible</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·symb1 = @Symbol('passFacebook');
          const Â·symb2 = @Symbol('passFacebook');

          console.log(Â·symb1 === Â·symb2);
          â‹— /Âº false Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="AÃ±adir a un objeto literal" codeText="">
        <p class="chaptrSubSect__p">Usando la notacion de corchetes <code>[]</code></p>
        <pre class="chaptrSubSect__console wScript">
          const Â·dni = @Symbol('dniNumber');

          const Ã§user = &#123;
            name: 'Iker',
            [Â·dni]: Â¬555555,
          &#125;;

          console.log(Ã§user);
          â‹— /Âº &#123; name: 'Iker', Symbol(dniNumber): 555555 &#125; Âº/</pre>
        <p class="chaptrSubSect__p">Al usar el sÃ­mbolo <code>dni</code> entre corchetes como clave en el objeto, se estÃ¡ creando una propiedad que no colisiona con otras propiedades del objeto y que no es accesible a travÃ©s de mÃ©todos convencionales como <code>Object.keys()</code>. De esta manera, la propiedad <code>dni</code> no aparecerÃ¡ cuando iteres sobre el objeto o cuando imprimas sus propiedades.</p>
        <p class="chaptrSubSect__p">El objeto <code>user</code> tendrÃ¡ una propiedad <code>name</code> accesible de manera normal, pero la propiedad que almacena el valor <code>555555</code> estÃ¡ protegida usando el sÃ­mbolo, lo que asegura que no sea fÃ¡cilmente accesible o manipulada desde el exterior del objeto</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·dni = @Symbol('dniNumber');

          const Ã§user = &#123;
            name: 'Iker',
            [Â·dni]: Â¬555555,
          &#125;;

          Ã§user.â€¢dni = Â¬123456;               /*/Âº No afecta al sÃ­mbolo Âº/*/
          console.log(Ã§user);
          â‹— /Âº &#123; name: 'Iker', dni: 123456, Symbol(dniNumber): 555555 &#125; Âº/

          Ã§user[Â·dni] = Â¬888888;          /*/Âº Modifica el sÃ­mbolo Âº/*/
          console.log(Ã§user);
          â‹— /Âº &#123; name: 'Iker', dni: 123456, Symbol(dniNumber): 888888 &#125; Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="AÃ±adir a un objeto creado" codeText="">
        <p class="chaptrSubSect__p">Usando la notacion de corchetes <code>[]</code></p>
        <pre class="chaptrSubSect__console wScript">
          const Â·dni = @Symbol('dniNumber');

          const Ã§user = &#123;
            name: 'Iker',
          &#125;;

          Ã§user[Â·dni] = Â¬888888;
          console.log(Ã§user);
          â‹— /Âº &#123; name: 'Iker', Symbol(dniNumber): 888888 &#125; Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Symbols globales" codeText="Symbol.for()">
        <p class="chaptrSubSect__p"><code>Symbol.for(key)</code> busca en un registro global de Symbols utilizando una clave especÃ­fica <code>(key)</code></p>
        <p class="chaptrSubSect__p">Si el <code>Symbol</code> con esa clave ya existe en el registro global, lo devuelve</p>
        <p class="chaptrSubSect__p">Si no existe, lo crea y lo almacena en ese registro global, de modo que pueda ser <mark>reutilizado</mark> en <mark>cualquier parte</mark> del cÃ³digo que acceda a esa misma clave</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·globalSym1 = @Symbol.for('mySymbolDesc');
          const Â·globalSym2 = @Symbol.for('mySymbolDesc');

          console.log(Â·globalSym1 === Â·globalSym2);
          â‹— /Âº true Âº/</pre>
        <p class="chaptrSubSect__p">Ejemplo paso a paso</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos un Symbol global */
          const Â·globalSym = @Symbol.for('user');

          /* Crear un objeto usando ese Symbol global como clave */
          const Ã§user = &#123;
            name: 'Iker',
            [#globalSym]: Â¬555555
          &#125;;

          console.log(Ã§user[@Symbol.for('user')]);
          â‹— 555555</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Tomar el nombre desde un global" codeText="Symbol.keyFor()">
        <p class="chaptrSubSect__p">Para devolver el nombre de un global symbol</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos un Symbol global */
          const Â·globalSym = @Symbol.for('mySymbolDesc');

          /* Tomar el nombre de un global symbol */
          const Â·nameFromGlobalSym = @Symbol.ÂªkeyFor(Â·globalSym);

          console.log(Â·nameFromGlobalSym);
          â‹— /Âº 'mySymbolDesc' Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Diferencias entre normales y globales" codeText="">
        <p class="chaptrSubSect__p"><code>Symbol()</code> Siempre crea un <code>Symbol</code> Ãºnico y no es accesible globalmente, incluso si usas la misma descripciÃ³n</p>
        <p class="chaptrSubSect__p"><code>Symbol.for()</code> Crea o recupera un <code>Symbol</code> del registro global, permitiendo que el <code>Symbol</code> sea compartido en diferentes partes del programa usando la misma clave</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·sym1 = @Symbol('desc');
          const Â·sym2 = @Symbol('desc');

          console.log(Â·sym1 === Â·sym2);
          â‹— /Âº false Âº/

          const Â·globalSym1 = @Symbol.for('desc2');
          const Â·globalSym2 = @Symbol.for('desc2');

          console.log(Â·globalSym1 === Â·globalSym2);
          â‹— /Âº true Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="ConversiÃ³n a primitivo" codeText="Symbol.toPrimitive">
        <p class="chaptrSubSect__p">Es un <code>Symbol</code> incorporado en JavaScript que se usa como clave especial en los objetos. Al implementar una funciÃ³n con <code>Symbol.toPrimitive</code>, le puedes decir a JavaScript cÃ³mo convertir un objeto a un valor primitivo cuando se necesita</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Ã§obj[@Symbol.ÂªtoPrimitive](#hint);
        </pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><code>obj</code>: Es el objeto al que quieres definir la conversiÃ³n.</li>
          <li class="chaptrSubSectUl__li"><code>Symbol.toPrimitive</code>: Es la propiedad especial que le dice a JavaScript cÃ³mo convertir este objeto a un valor primitivo.</li>
          <li class="chaptrSubSectUl__li"><code>hint</code>: Es un argumento que le dice al mÃ©todo en quÃ© tipo primitivo se espera convertir el objeto. Los posibles valores de hint son:</li>
          <li class="chaptrSubSectUl__li--sub"><code>string</code>: JavaScript espera que el objeto se convierta en un string.</li>
          <li class="chaptrSubSectUl__li--sub"><code>number</code>: JavaScript espera que el objeto se convierta en un nÃºmero.</li>
          <li class="chaptrSubSectUl__li--sub"><code>default</code>: No estÃ¡ claro si JavaScript espera un string o un nÃºmero, pero en este caso debes decidir cuÃ¡l devolver.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          const Ã§user = &#123;
            name: 'Ã‰der',
            age: Â¬4,
            [@Symbol.ÂªtoPrimitive](#hint) &#123;
              if (#hint === 'string') &#123;
                return this.â€¢name;
              &#125;
              if (#hint === 'number') &#123;
                return this.â€¢age;
              &#125;
              return this.â€¢age;   /*/Âº default Âº/*/
            &#125;,
          &#125;;

          console.log(@String(Ã§user));
          â‹— /Âº sugerencia: string Âº/
          â‹— /Âº 'Ã‰der' Âº/

          console.log(@Number(Ã§user));
          â‹— /Âº sugerencia: number Âº/
          â‹— /Âº 4 Âº/

          console.log(Ã§user + Â¬4);
          â‹— /Âº sugerencia: default Âº/
          â‹— /Âº 8 Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="ConversiÃ³n a primitivo alternativa" codeText="">
        <p class="chaptrSubSect__p">Proporcionan una forma alternativa â€œal viejo estiloâ€ de implementar la conversiÃ³n</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§user = &#123;
            name: 'Ã‰der',
            age: Â¬4,

            @toString() &#123;    /* para sugerencia string */
              return this.â€¢name;
            &#125;,

            @valueOf() &#123;    /* para sugerencia number o default */
              return this.â€¢age;
            &#125;,

          &#125;;

          console.log(@String(Ã§user));
          â‹— /Âº sugerencia: string Âº/
          â‹— /Âº 'Ã‰der' Âº/

          console.log(@Number(Ã§user));
          â‹— /Âº sugerencia: number Âº/
          â‹— /Âº 4 Âº/

          console.log(Ã§user + Â¬4);
          â‹— /Âº sugerencia: default Âº/
          â‹— /Âº 8 Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_11" nextPage="/lessons/lesson_15"/>
</MainLayout>


<!-- 
&lt;&gt;
()&#123;&#125;
ï¹›ï¹œ    Llaves no estiladas
ï¹•     2 puntos no estilizados
ÂªmÃ©todos
â€¢parametro
Â·variable
#variable en Func/if/for
Ã§Objetos
â‹— âˆResultado
@funcion()
Â¬numbers
objProperty:
ÂºobjProperty
/* comentario */
'/Âº modo texto quita span Âº/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">
ï¼ƒ
-->
