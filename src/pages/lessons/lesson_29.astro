---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>

  <LssnArt artClass="lssn__29" h2Title="Generadores & Iteracción" slot="mainContent">
    <ChaptrSect h3Title="Generadores" codeText="">
      <ChaptrSubSect h4Title="Funciones generadoras" codeText="">
        <p class="chaptrSubSect__p">Las funciones generadoras en JavaScript son funciones especiales que permiten pausar y reanudar su ejecución, devolviendo valores intermedios en el proceso. Esto es útil cuando queremos producir una serie de valores bajo demanda, sin generar todos a la vez, como una secuencia infinita de números o un flujo de datos que llega en partes</p>
        <p class="chaptrSubSect__p">Una función generadora se define con el símbolo <code>*</code> después de la palabra <code>function</code></p>
        <pre class="chaptrSubSect__console wScript">
          ªfunction* @nombreFuncionGeneradora() &#123;
            /*/º cuerpo de la función º/*/
          &#125;;
        </pre>
        <p class="chaptrSubSect__p">Dentro de estas funciones, utilizamos la palabra clave <code>yield</code> en lugar de <code>return</code> para devolver <mark>valores intermedios</mark>. Cada vez que la función "cede" un valor con <code>yield</code>, su ejecución se pausa en ese punto</p>
        <pre class="chaptrSubSect__console wScript">
          ªfunction* @generatorSequence() &#123;
            yield ¬1;
            yield ¬2;
            return ¬3;
          &#125;;
        
          let ·generator = @generatorSequence();

          console.log(·generator);    ⋗ /º [object Generator] º/</pre>
        <p class="chaptrSubSect__p">Cuando se invoca una función de este tipo, no ejecuta su código, sino que devuelve un objeto especial, llamado <mark>objeto generador</mark>, para gestionar la ejecución</p>
        <p class="chaptrSubSect__p">El método principal de un generador es <code>next()</code>. Cuando se lo llama, se ejecuta hasta el siguiente <code>yield</code>. Luego, la ejecución de la función se detiene y el <code>&lt;value&gt;</code> obtenido se devuelve al código externo</p>
        <pre class="chaptrSubSect__console wScript">
          ªfunction* @generatorSequence() &#123;
            yield ¬1;
            yield ¬2;
            return ¬3;
          &#125;;
        
          let ·generator = @generatorSequence();

          let ·one = ·generator.ªnext();
          console.log(·one);    ⋗ /º &#123;value: 1, done: false&#125; º/

          let ·two = ·generator.ªnext();
          console.log(·two);    ⋗ /º &#123;value: 2, done: false&#125; º/
          
          let ·three = ·generator.ªnext();
          console.log(·three);    ⋗ /º &#123;value: 3, done: true&#125; º/
        
          let ·another = ·generator.ªnext();
          console.log(·another);    ⋗ /º &#123;value: undefined, done: true&#125; º/</pre>
        <p class="chaptrSubSect__p">Si querriamos acceder directamente al valor usariamos <code>generator.next().value</code></p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Generadores son iterables" codeText="">
        <p class="chaptrSubSect__p">Podemos recorrer sus valores usando <code>for..of</code> que es mucho más cómodo que usar <code>generator.next().value</code></p>
        <pre class="chaptrSubSect__console wScript">
          ªfunction* @generatorSequence() &#123;
            yield ¬1;
            yield ¬2;
            return ¬3;
          &#125;;
        
          let ·generator = @generatorSequence();

          for(let #value of @generator) &#123;
            console.log(#value);
          &#125;

          ⋗ /º 1 º/
          ⋗ /º 2 º/</pre>
        <p class="chaptrSubSect__p">Pero hay un problema, no muestra <code>3</code>, esto se debe a que <code>for..of</code> ignora el último <code>value</code>, cuando <code>done: true</code>. Por lo tanto, si queremos que todos los resultados se muestren con <code>for..of</code>, debemos devolverlos con <mark>todos</mark> con <code>yield</code></p>
        <p class="chaptrSubSect__p">Como los generadores son iterables, podemos llamar a todas las funciones relacionadas, por ejemplo, la sintaxis de propagación <code>...</code></p>
        <pre class="chaptrSubSect__console wScript">
          ªfunction* @generatorSequence() &#123;
            yield ¬1;
            yield ¬2;
            return ¬3;
          &#125;;
        
          let ·sequence = [¬0, ...@generatorSequence()];

          console.log(·sequence);         ⋗ /º [0, 1, 2, 3] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Generador para iterables" codeText="">
        <p class="chaptrSubSect__p">En otra lección creamos un objeto iterable <code>range</code> que retornaba values <code>from..to</code></p>
        <pre class="chaptrSubSect__console wScript">
          let çrange = &#123;
            from: ¬1,
            to: ¬5,

            [çSymbol.•iterator]() &#123;
              return &#123;
                  current: this.from,
                  last: this.•to,

                  ªnext() &#123;
                      if(this.•current &lt;= this.•last)&#123;
                          return &#123;done: false, value: this.•current++&#125;;
                      &#125; else &#123;
                          return &#123;done: true&#125;;
                      &#125;
                    &#125;
                &#125;
            &#125;
          &#125;

          console.log([...çrange]);       ⋗ /º [1, 2, 3, 4, 5] º/</pre>
        <p class="chaptrSubSect__p">Podemos utilizar una función generadora para la iteración proporcionándola como <code>Symbol.iterator</code>. Este es el mismo range, pero mucho más compacto</p>
        <pre class="chaptrSubSect__console wScript">
          let çrange = &#123;
            from: ¬1,
            to: ¬5,

            *[çSymbol.•iterator]() &#123;
              for(let  #value = this.from; #value &lt;= this.•to; #value++) &#123;
                yield #value;
              &#125;
            &#125;
          &#125;;

          console.log([...çrange]);        ⋗ /º [1, 2, 3, 4, 5] º/</pre>
        <p class="chaptrSubSect__p">Eso funciona, porque <code>range[Symbol.iterator]()</code> ahora devuelve un <mark>generador</mark>, y los métodos de generador son exactamente lo que espera <code>for..of</code>; tiene un método <code>.next()</code>, que devuelve valores en la forma <code>&#123;value: ..., done: true/false&#125;</code></p>
        <p class="chaptrSubSect__p">La variante con un generador es mucho más concisa que el código iterable original, y mantiene la misma funcionalidad.</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Composición del generador" codeText="">
        <p class="chaptrSubSect__p">La composición del generador es una característica especial de los generadores que permite “incrustar” generadores entre sí de forma transparente</p>
        <pre class="chaptrSubSect__console wScript">
          ªfunction* @genSeq(#start, #end) &#123;
            for(let #i = #start; #i &lt;= #end; #i++) &#123;
              yield #i;
            &#125;
          &#125;;</pre>
        <p class="chaptrSubSect__p">Ahora nos gustaría reutilizarlo para generar una secuencia más compleja</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Primero, dígitos 0..9 (con códigos de caracteres 48…57)</li>
          <li class="chaptrSubSectUl__li">Seguido de letras mayúsculas del alfabeto A..Z (códigos de caracteres 65…90)</li>
          <li class="chaptrSubSectUl__li">Seguido de letras del alfabeto en minúscula a..z (códigos de carácter 97…122)</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          ªfunction* @genSeq(#start, #end) &#123;
            for(let #i = #start; #i &lt;= #end; #i++) &#123;
              yield #i;
            &#125;
          &#125;;

          ªfunction* @genPassCodes() &#123;
            yield* @genSeq(¬48, ¬57);
            yield* @genSeq(¬65, ¬90);
            yield* @genSeq(¬97, ¬122);
          &#125;;

          let ·str = '';

          for(let #code of @genPassCodes()) &#123;
            ·str += çString.ªfromCharCode(#code);
          &#125;;

          console.log(·str);
          ⋗ /º 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz º/</pre>
        <p class="chaptrSubSect__p">El resultado es el mismo que si insertamos el código de los generadores anidados</p>
        <pre class="chaptrSubSect__console wScript">
          ªfunction* @genSeq(#start, #end) &#123;
            for(let #i = #start; #i &lt;= #end; #i++) &#123;
              yield #i;
            &#125;
          &#125;;

          ªfunction* @genAlphaNum() &#123;
            for(let #i = ¬48; #i &lt;= ¬57; #i++) yield #i;
            for(let #i = ¬65; #i &lt;= ¬90; #i++) yield #i;
            for(let #i = ¬97; #i &lt;= ¬122; #i++) yield #i;
          &#125;;

          let ·str = '';

          for(let #code of @genAlphaNum()) &#123;
            ·str += çString.ªfromCharCode(#code);
          &#125;;

          console.log(·str);
          ⋗ /º 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Doble sentido" codeText="yield">
        <p class="chaptrSubSect__p">No solo devuelve el resultado al exterior, sino que también puede pasar el valor dentro del generador. Para hacerlo, deberíamos llamar a <code>generator.next (arg)</code>, con un argumento. Ese argumento se convierte en el resultado de <code>yield</code></p>
        <pre class="chaptrSubSect__console wScript">
          ªfunction* @gen() &#123;
            let ·result = yield '/º 2 + 2 = ? º/';
            console.log(·result);
          &#125;;

          let ·generator = @gen();
          let ·question = ·generator.ªnext().•value;
          ·generator.ªnext(¬4);        ⋗ /º 4 º/     /*/º &#123;done: true&#125; º/*/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Iter/Gen async" codeText="">
      <ChaptrSubSect h4Title="Iteradores asíncronos" codeText="">
        <p class="chaptrSubSect__p">La iteración asincrónica es necesaria cuando los valores vienen asincrónicamente: después de setTimeout u otra clase de retraso. El caso más común es un objeto que necesita hacer un pedido sobre la red para enviar el siguiente valor</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Usa <code>Symbol.asyncIterator</code> en lugar de <code>Symbol.iterator</code>.</li>
          <li class="chaptrSubSectUl__li">El método <code>next()</code> debe devolver una promesa (a ser cumplida con el siguiente valor) y la palabra clave <code>async</code> lo maneja, nosotros simplemente hacemos <code>async next()</code>.</li>
          <li class="chaptrSubSectUl__li">Para iterar sobre tal objeto, debemos usar un bucle <code>for await (let item of iterable)</code>.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          let çrange = &#123;
            from: ¬1,
            to: ¬5,

            [çSymbol.•asyncIterator]() &#123;
              return &#123;
                  current: this.from,
                  last: this.•to,

                  async ªnext() &#123;
                      await new çPromise(@resolve =&gt; @setTimeout(@resolve, ¬1000));

                      if(this.•current &lt;= this.•last)&#123;
                          return &#123;done: false, value: this.•current++&#125;;
                      &#125; else &#123;
                          return &#123;done: true&#125;;
                      &#125;
                    &#125;
                &#125;;
            &#125;
          &#125;;

          (async () =&gt; &#123;
            for await (let #value of çrange) &#123;
              console.log(#value);
            &#125;
          &#125;)()

          ⋗ /º 1 º/
          ⋗ /º 2 º/
          ⋗ /º 3 º/
          ⋗ /º 4 º/
          ⋗ /º 5 º/</pre>
        <p class="chaptrSubSect__p">En resumen: los iteradores asíncronos nos permiten recorrer datos que llegan de forma retrasada, como respuestas de red o streams, usando el mismo estilo de bucle <code>for...of</code>, pero con la palabra clave <code>await</code></p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Generadores asíncronos" codeText="">
        <p class="chaptrSubSect__p">Cuando queremos hacer un objeto que genere una secuencia de valores asincrónicamente, podemos usar un generador asincrónico. La sintaxis es simple,  anteponga <code>async</code> a <code>function*</code>. Esto hace al generador asincrónico, y entonce usamos <code>for await (...)</code> para iterarlo</p>
        <pre class="chaptrSubSect__console wScript">
          async ªfunction* @genSeq(#start, #end) &#123;
            for (let #i = #start; #i &lt;= #end; #i++) &#123;
              await new çPromise(@resolve =&gt; @setTimeout(@resolve, ¬1000));
              yield #i;
            &#125;
          &#125;

          (async () =&gt; &#123;
            let çgenerator = @genSeq(¬1, ¬5);
            for await (let #value of @generator) &#123;
              console.log(#value);
            &#125;
          &#125;)();

          ⋗ /º 1 º/
          ⋗ /º 2 º/
          ⋗ /º 3 º/
          ⋗ /º 4 º/
          ⋗ /º 5 º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Ejemplo real" codeText="">
        <p class="chaptrSubSect__p">Muchos servicios en línea entregan datos paginados, por ejemplo, GitHub nos permite recuperar commits de la misma manera paginada</p>
        <pre class="chaptrSubSect__console wScript">
          async ªfunction* @fetchCommits(#repo) &#123;
            let ·url = `/º https://api.github.com/repos/$&#123;repo&#125;/commits º/`;

            while(#url) &#123;
              const çresponse = await fetch(#url, &#123;
                headers: &#123;'/º User-Agent º/': '/º Our script º/'&#125;,
              &#125;);

              const body = await çresponse.ªjson();

              let çnextPage = çresponse.•headers.get('/º Link º/').ªmatch(/&lt;(.*?)&gt;;·rel='next'/);
              çnextPage = çnextPage?.[¬1];
              #url = çnextPage;

              for(let #commit of body) &#123;
                yield #commit;
              &#125;
            &#125;;
          &#125;;

          (async () =&gt; &#123;
            let ·count = ¬0;

            for await (const #commit of @fetchCommits('/º javascript-tutorial/en.javascript.info º/')) &#123;
              console.log(#commit.•author.•login);
              if(++·count == ¬20) &#123;
                break;
              &#125;
            &#125;
          &#125;)();

          ⋗ /º ❷ smith558 º/
          ⋗ /º wjw020206 º/
          ⋗ /º ❹ smith558 º/
          ⋗ /º rahulrao0209 º/
          ⋗ /º iliakan º/
          ⋗ /º Paramesh-T-S º/
          ⋗ /º ❷ dangerman º/
          ⋗ /º smith558 º/
          ⋗ /º ❺ iliakan º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_24" nextPage="/lessons/lesson_30"/>
</MainLayout>




<!-- 
&lt;&gt;          < > no estilados
&#123;&#125;      {} no estilados
()&#123;&#125;    ( ) { } no estilados
﹛﹜              { } Llaves no estilados
﹕                : 2 puntos no estilados
＃                # Rejilla no estilada

ªmétodos
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">

-->
