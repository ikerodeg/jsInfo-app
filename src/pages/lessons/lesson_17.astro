---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__17" h2Title="Maps" slot="mainContent">
    <ChaptrSect h3Title="Qué es un" codeText="Map">
      <ChaptrSubSect h4Title="Características principales de un" codeText="Map()">
        <p class="chaptrSubSect__p">Un <code>Map</code> es una estructura de datos incorporada en JavaScript que permite almacenar pares clave → valor (key → value). A diferencia de los objetos <code>&#123;&#125;</code>, las claves de un <code>Map</code> pueden ser de cualquier tipo, no solo cadenas o símbolos</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><b>Estructura ordenada:</b> Los elementos se mantienen en el orden en que fueron insertados. (Esto no ocurre de forma garantizada con las propiedades de los objetos, aunque en la práctica moderna sí se respetan parcialmente los órdenes).</li>
          <li class="chaptrSubSectUl__li"><b>Cualquier tipo puede ser clave:</b> Puedes usar números, objetos, funciones, booleanos, etc.</li>
          <li class="chaptrSubSectUl__li"><b>Claves únicas:</b> Cada clave en un <code>Map</code> debe ser única. Si intentas agregar una clave que ya existe, el valor asociado se actualizará.</li>
          <li class="chaptrSubSectUl__li"><b>Propiedad size:</b> Los <code>Map</code> son redimensionables automáticamente y tienen una propiedad incorporada llamada <code>size</code> que te permite obtener el número de pares clave-valor almacenados en el <code>Map</code>.</li>
          <li class="chaptrSubSectUl__li"><b>Mejor rendimiento para grandes conjuntos de datos:</b> En general, los <code>Map</code> pueden ofrecer un mejor rendimiento que los objetos cuando se trabaja con grandes cantidades de datos debido a su implementación interna optimizada para operaciones de inserción y búsqueda.</li>
        </ul>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Creación de un" codeText="Map">
      <ChaptrSubSect h4Title="Utilizando su constructor" codeText="new Map()">
        <p class="chaptrSubSect__p">La única forma de crear un <code>Map</code> es usando su constructor, <mark>no existe la forma literal</mark> como en los objetos</p>
        <pre class="chaptrSubSect__console wScript">
          const ·myMap = new Map();

          console.log(·myMap);
          ⋗ /º Map(0) &#123;size: 0&#125; º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Agregar elementos a un" codeText="Map">
      <ChaptrSubSect h4Title="Utilizando su constructor" codeText="new Map()">
        <p class="chaptrSubSect__p">Cuando creamos un <code>Map</code>, podemos pasarle un <code>array</code> de arrays, donde cada subarray contiene un par clave → valor. Es una forma rápida de inicializar un <code>Map</code> con valores desde el principio.</p>
        <pre class="chaptrSubSect__console wScript">
          const çmyMap = new Map([
            ['name', 'Éder'],
            ['age', ¬4],
            [true, 'booleano'],
            [¬404, false],
          ]);

          console.log(çmyMap);
          ⋗ /º Map(4) &#123; º/
            /º 'name' =&gt; 'Éder', º/
            /º 'age' =&gt; 4, º/
            /º true =&gt; 'booleano', º/
            /º 404 =&gt; false º/
          /º &#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Utilizando el método" codeText=".set()">
        <p class="chaptrSubSect__p">El método <code>.set(clave, valor)</code> permite agregar un nuevo elemento al <code>Map</code> o actualizarlo si la clave ya existe.</p>
        <pre class="chaptrSubSect__console wScript">
          const çlateralDerecho = new Map();

          çlateralDerecho.set('name', 'Éder');

          console.log(çlateralDerecho);
          ⋗ /º Map(1) &#123; 'name' =&gt; 'Éder' &#125; º/</pre>
          <p class="chaptrSubSect__p">El método <code>.set()</code> devuelve el propio <code>Map</code>, lo que permite encadenar varias llamadas consecutivas. Podemos usar el encadenamiento para añadir varios valores a la vez</p>
          <pre class="chaptrSubSect__console wScript">
            const çlateralDerecho = new Map();

            çlateralDerecho
              .set('name', 'Éder')
              .set('age', ¬5)             /*/º No poner ; durante el encadenamiento º/*/
              .set('foot', 'right');

            console.log(çlateralDerecho);
            ⋗ /º Map(3) &#123; º/
              /º 'name' =&gt; 'Éder', º/
              /º 'age' =&gt; 5, º/
              /º 'foot' =&gt; 'right' º/
            /º &#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Array como argumento a" codeText="new Map()">
        <p class="chaptrSubSect__p">Podemos pasar un array de arrays con pares clave/valor al constructor <code>new Map()</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çeder = [
            ['name', 'Éder'],
            ['age', ¬5],
            ['foot', 'right']
          ];

          const çlateralDerecho = new Map(çeder);
          
          console.log(çlateralDerecho);
          ⋗ /º Map(3) &#123; º/
            /º 'name' =&gt; 'Éder', º/
            /º 'age' =&gt; 5, º/
            /º 'foot' =&gt; 'right' º/
          /º &#125; º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Acceso a elementos" codeText="">
      <ChaptrSubSect h4Title="Devuelve el value de key con" codeText=".get()">
        <p class="chaptrSubSect__p">El método <code>.get(key)</code> devuelve el valor asociado a la clave especificada. Si la clave no existe, devuelve <code>undefined</code>. A diferencia de los objetos, en los <code>Map</code> las claves no se convierten en cadenas automáticamente. Esto significa que puedes usar claves de cualquier tipo: números, booleanos, objetos, funciones, etc</p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Creamos un Map vacio º/*/
          const çtestMap = new Map();

          /*/º Agregamos elementos con diferentes tipos de claves º/*/
          çtestMap
            .set('descrip', 'allTypeKeysMap')
            .set(true, ¬1)
            .set(¬404, false);

          /*/º Accedemos a los valores º/*/
          console.log(çtestMap.get('descrip'));     ⋗ /º "allTypeKeysMap" º/
          console.log(çtestMap.get(true));          ⋗ /º 1 º/
          console.log(çtestMap.get(¬404));          ⋗ /º false º/

          /*/º Verificamos los tipos º/*/
          console.log(typeof çtestMap.get('descrip'));    ⋗ /º string º/
          console.log(typeof çtestMap.get(true));         ⋗ /º number º/
          console.log(typeof çtestMap.get(¬404));         ⋗ /º boolean º/

          /*/º Intentamos acceder a una clave que no existe º/*/
          console.log(çtestMap.get('noExiste'));       ⋗ /º undefined º/
          </pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Existencia claves" codeText="">
      <ChaptrSubSect h4Title="Verifica si existe una clave con" codeText=".has()">
        <p class="chaptrSubSect__p">El método <code>.has(key)</code> verifica si una clave específica existe dentro del <code>Map</code>. Devuelve un booleano</p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Creamos un Map º/*/
          const çlateralDerecho = new Map();

          /*/º Agregamos elementos º/*/
          çlateralDerecho
            .set('name', 'Éder')
            .set('age', ¬5)
            .set('academyPlayer', true);

          /*/º Verificamos la existencia de claves º/*/
          console.log(çlateralDerecho.has('academyPlayer'));       ⋗ /º true º/
          console.log(çlateralDerecho.has('hasContract'));   ⋗ /º false º/</pre>
        <p class="chaptrSubSect__p">Recuerda que <code>.has(key)</code> solo verifica la existencia de la clave, no su valor</p>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Eliminar elementos" codeText="">
      <ChaptrSubSect h4Title="Elimina elemento con clave con" codeText=".delete()">
        <p class="chaptrSubSect__p">El método <code>.delete(key)</code> elimina del <code>Map</code> el elemento que tenga esa clave. Devuelve un booleano</p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Creamos un Map º/*/
          const çlateralDerecho = new Map();

          /*/º Agregamos elementos º/*/
          çlateralDerecho
            .set('name', 'Éder')
            .set('age', ¬5)
            .set('academyPlayer', true);

          /*/º Eliminamos un elemento por su clave º/*/
          çlateralDerecho.ªdelete('academyPlayer');
          /*/º o tambien podemos verficar el retorno de .delete() º/*/
          console.log(çlateralDerecho.ªdelete('age'));             ⋗ /º true º/

          /*/º Verificamos que se eliminó º/*/
          console.log(çlateralDerecho.ªdelete('hasContract'));      ⋗ /º false º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Vaciar el Map" codeText="">
      <ChaptrSubSect h4Title="Vacia completamente con" codeText=".clear()">
        <p class="chaptrSubSect__p">Vacía por completo el Map de elementos</p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Creamos un Map º/*/
          const çlateralDerecho = new Map();

          /*/º Agregamos elementos º/*/
          çlateralDerecho
            .set('name', 'Éder')
            .set('age', ¬5)
            .set('academyPlayer', true);

          /*/º Vaciamos el Map º/*/
          çlateralDerecho.ªclear();

          /*/º Verificamos que se vació º/*/
          console.log(çlateralDerecho);       ⋗ /º Map(0) &#123;&#125; º/
          console.log(çlateralDerecho.ªsize);  ⋗ /º 0 º/</pre>
        <p class="chaptrSubSect__p"><code>.clear()</code> no devuelve ningún valor (su retorno es <code>undefined</code>). El <code>Map</code> sigue existiendo en memoria, solo se eliminan sus pares clave → valor. Puedes seguir reutilizando la misma variable para agregar nuevos elementos</p>
        <pre class="chaptrSubSect__console wScript">
          çlateralDerecho.set('position', 'Defensa');
          console.log(çlateralDerecho);     ⋗ /º Map(1) &#123;'position' =&gt; 'Defensa'&#125; º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Verificar tamaño" codeText="">
      <ChaptrSubSect h4Title="El método" codeText="size">
        <p class="chaptrSubSect__p">Para verificar el tamaño de un <code>Map</code> se usa el método<code>size</code></p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Creamos un Map º/*/
          const çlateralDerecho = new Map();

          /*/º Agregamos elementos º/*/
          çlateralDerecho
            .set('name', 'Éder')
            .set('age', ¬5)
            .set('academyPlayer', true);

          /*/º Verificamos el tamaño del Map º/*/
          console.log(çlateralDerecho.ªsize);       ⋗ /º 3 º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Iterando un Map" codeText="">
      <ChaptrSubSect h4Title="Opciones de iteración" codeText="">
        <p class="chaptrSubSect__p">Podemos iterar sobre un <code>Map</code> de diferentes maneras</p>
        <ul class="chaptrSubSect__list">
          <li class="chaptrSubSectUl__li">Iterando directamente sobre el <code>Map</code> con el ciclo <code>for(of)</code>.</li>
          <li class="chaptrSubSectUl__li">Usando un método para obtener un MapIterator.</li>
          <li class="chaptrSubSectUl__li">Usando un método para obtener un MapIterator y después convertirlo a un <code>Array</code>.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".keys()">
        <p class="chaptrSubSect__p">Tenemos 2 opciones usando el método <code>.keys()</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çbagShop = new Map([
            ['uvas', ¬1],
            ['kiwis', ¬2],
            ['peras', ¬3],
            ['manzanas', ¬4]
          ]);

          /*/º Opción 1: Obtener un array de claves con Array.from() º/*/
          const ·keysArray = Array.from(çbagShop.ªkeys());
          console.log(·keysArray);
          ⋗ /º ['uvas', 'kiwis', 'peras', 'manzanas'] º/

          /*/º Opción 2: Obtenemos el iterable de claves directamente º/*/
          const ·keysMapIterator = çbagShop.ªkeys();
          console.log(·keysMapIterator);
          ⋗ /º MapIterator &#123;'uvas', 'kiwis', 'peras', 'manzanas'&#125; º/

          /*/º  Opción 3: Iteramos con el ciclo for(of) º/*/
          for(let ·key of çbagShop.ªkeys()) &#123;
            console.log(·key);
          &#125;
          ⋗ /º uvas º/ 
            /º kiwis º/ 
            /º peras º/ 
            /º manzanas º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".values()">
        <p class="chaptrSubSect__p">Devuelve un objeto iterable con los valores de cada elemento del <code>Map</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çbagShop = new Map([
            ['uvas', ¬1],
            ['kiwis', ¬2],
            ['peras', ¬3],
            ['manzanas', ¬4]
          ]);

          /*/º Opción 1: Obtener un array de valores con Array.from() º/*/
          const ·valuesArray = Array.from(çbagShop.ªvalues());
          console.log(·valuesArray);
          ⋗ /º [1, 2, 3, 4] º/

          /*/º Opción 2: Obtenemos el iterable de valores directamente º/*/
          const ·valuesMapIterator = çbagShop.ªvalues();
          console.log(·valuesMapIterator);
          ⋗ /º MapIterator &#123;1, 2, 3, 4&#125; º/

          /*/º  Opción 3: Iteramos con el ciclo for(of) º/*/
          for(let ·value of çbagShop.ªvalues()) &#123;
            console.log(·value);
          &#125;
          ⋗ /º 1 º/ 
            /º 2 º/ 
            /º 3 º/ 
            /º 4 º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".entries()">
        <p class="chaptrSubSect__p">Devuelve un objeto iterable con los pares claves/valores de cada elemento del <code>Map</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çbagShop = new Map([
            ['uvas', ¬1],
            ['kiwis', ¬2],
            ['peras', ¬3],
            ['manzanas', ¬4]
          ]);

          /*/º Opción 1: Obtener un array de arrays clave/valor con Array.from() º/*/
          const ·entriesArray = Array.from(çbagShop.ªentries());
          console.log(·entriesArray);
          ⋗ /º [['uvas', 1], ['kiwis', 2], ['peras', 3], ['manzanas', 4]] º/

          /*/º Opción 2: Obtenemos el iterable de clave/valor directamente º/*/
          const ·entriesMapIterator = çbagShop.ªentries();
          console.log(·entriesMapIterator);
          ⋗ /º MapIterator &#123;['uvas', 1], ['kiwis', 2], ['peras', 3], ['manzanas', 4]&#125; º/

          /*/º  Opción 3: Iteramos con el ciclo for(of) º/*/
          for(let ·entry of çbagShop.ªentries()) &#123;
            console.log(·entry);
          &#125;
          ⋗ /º ['uvas', 1] º/ 
            /º ['kiwis', 2] º/ 
            /º ['peras', 3] º/ 
            /º ['manzanas', 4] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Usando directamente" codeText=".forEach()">
        <p class="chaptrSubSect__p">El método <code>.forEach()</code> permite recorrer directamente todos los elementos de un <code>Map</code>. No devuelve un iterable, sino que ejecuta una función <code>callback</code> una vez por cada elemento del <code>Map</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çbagShop = new Map([
            ['uvas', ¬1],
            ['kiwis', ¬2],
            ['peras', ¬3],
            ['manzanas', ¬4]
          ]);
          
          /*/º Iteramos directamente con método forEach() º/*/
          çbagShop.forEach((#value, #key) =&gt; &#123;
            console.log(#key, #value);
          &#125;);
          ⋗ /º 'uvas' 1 º/ 
            /º 'kiwis' 2 º/ 
            /º 'peras' 3 º/ 
            /º 'manzanas' 4 º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Conversiones" codeText="">
      <ChaptrSubSect h4Title="De Objeto a Map con" codeText=".Object.entries()">
        <p class="chaptrSubSect__p">Convierte un objeto a <code>Map</code> transformando sus propiedades en pares [clave, valor]</p>
        <pre class="chaptrSubSect__console wScript">
          const çbagShop = &#123;
            uvas: ¬1,
            kiwis: ¬2,
            peras: ¬3,
            manzanas: ¬4
          &#125;;

          const çbagShopMap = new Map(Object.ªentries(çbagShop));

          console.log(çbagShopMap);
          ⋗ /º Map(4) º/
            /º [[Entries]] º/
            /º 0: &#123;'uvas' =&gt; 1&#125; º/
            /º 1: &#123;'kiwis' =&gt; 2&#125; º/
            /º 2: &#123;'peras' =&gt; 3&#125; º/
            /º 3: &#123;'manzanas' =&gt; 4&#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="De Map a Objeto con" codeText=".Object.fromEntries()">
        <p class="chaptrSubSect__p">Convierte un <code>Map</code> a un objeto plano</p>
        <pre class="chaptrSubSect__console wScript">
          const çbagShop = new Map([
            ['uvas', ¬1],
            ['kiwis', ¬2],
            ['peras', ¬3],
            ['manzanas', ¬4]
          ]);

          const çbagShopObj = Object.ªfromEntries(çbagShop);

          console.log(çbagShopObj);          
          ⋗ /º &#123;uvas: 1, kiwis: 2, peras: 3, manzanas: 4&#125; º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="De Map a Array" codeText="">
        <p class="chaptrSubSect__p">Convierte un <code>Map</code> en un array de pares [clave, valor] con <code>Array.from()</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çbagShop = new Map([
            ['uvas', ¬1],
            ['kiwis', ¬2],
            ['peras', ¬3],
            ['manzanas', ¬4]
          ]);

          const ·bagShopArr = Array.from(çbagShop);

          console.log(·bagShopArr);
          ⋗ /º [['uvas', 1], ['kiwis', 2], ['peras', 3], ['manzanas', 4]] º/</pre>
        <p class="chaptrSubSect__p">Convierte un <code>Map</code> en un array de pares [clave, valor] con <code>...spread</code></p>
        <pre class="chaptrSubSect__console wScript">
          const çbagShop = new Map([
            ['uvas', ¬1],
            ['kiwis', ¬2],
            ['peras', ¬3],
            ['manzanas', ¬4]
          ]);

          const ·bagShopArr = [...çbagShop];

          console.log(·bagShopArr);
          ⋗ /º [['uvas', 1], ['kiwis', 2], ['peras', 3], ['manzanas', 4]] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="De Array a Map con" codeText="new Map()">
        <p class="chaptrSubSect__p">Podemos pasar un array de arrays con pares clave/valor al constructor <code>new Map()</code></p>
        <pre class="chaptrSubSect__console wScript">
          const ·bagShopArr = [
            ['uvas', ¬1],
            ['kiwis', ¬2],
            ['peras', ¬3],
            ['manzanas', ¬4]
          ];

          const çbagShopMap = new Map(·bagShopArr);

          console.log(çbagShopMap);
          ⋗ /º Map(4) º/
              /º [[Entries]] º/
              /º 0: &#123;'uvas' =&gt; 1&#125; º/
              /º 1: &#123;'kiwia' =&gt; 2&#125; º/
              /º 2: &#123;'peras' =&gt; 3&#125; º/
              /º 3: &#123;'manzanas' =&gt; 4&#125; º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_16" nextPage="/lessons/lesson_18"/>
</MainLayout>




<!-- 
&lt;&gt;
()&#123;&#125;
﹛﹜    Llaves no estiladas
﹕     2 puntos no estilizados
ªmétodos
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ ∞Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">
＃
-->
