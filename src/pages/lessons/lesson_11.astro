---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__11" h2Title="Arrays" slot="mainContent">
    <ChaptrSect h3Title="Creación de arrays" codeText="">
      <ChaptrSubSect h4Title="Notación corchetes" codeText="[]" hint="#métodoRecomendada">
        <p class="chaptrSubSect__p">Es la forma <mark>recomendada</mark></p>
        <pre class="chaptrSubSect__console wScript">
          let ·numbers = [¬1, ¬2, ¬3, ¬4, ¬5];</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Contructor de arrays" codeText="new" hint="#noRecomendada">
        <p class="chaptrSubSect__p">Se utiliza para crear instancias de arrays, no es <mark>nada recomendable</mark>. Los únicos usos serían crear un array vacio con un tamaño específico, y crear un array dinámicamente</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creado dinámicamente */
          let ·arrWithContent = new Array(¬5, ¬4, ¬3, ¬2, ¬1);
          console.log(·arrWithContent);
          ⋗ [5, 4, 3, 2, 1]

          /*/º Array vacio con x posiciones º/*/
          let ·arrWithSize = new Array(¬5);
          console.log(·arrWithSize);
          ⋗ /º[ &lt;5 empty items&gt; ] º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Acceso a elementos" codeText="[]">
      <ChaptrSubSect h4Title="Notación corchetes" codeText="[]">
        <p class="chaptrSubSect__p">Poniendo la posición que ocupa en el array entre corchetes</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];

          console.log(·fruits[¬0]);
          ⋗ "kiwi"

          console.log(·fruits[¬2]);
          ⋗ "uva"</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Agregar elementos" codeText="">
      <ChaptrSubSect h4Title="Notación de corchete" codeText="[]" hint="#mejorPerformance #añadeEnPosicionDada">
        <p class="chaptrSubSect__p">Agrega elementos poniendo la posición entre corchetes. <mark>Mejor performance</mark> de todos porque no desplaza elementos ni otra operación.</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = [ 'kiwi', 'piña', 'uva' ];
          ·fruits[¬3] = 'pera';

          console.log(·fruits);
          ⋗ /º ['kiwi', 'piña', 'uva', 'pera'] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".push()" hint="#añadeAlFinal #segundoMejorPerformance">
        <p class="chaptrSubSect__p">Agrega elementos <mark>al final</mark> del array. Tiene la segunda mejor performance porque solo añade al final sin desplazar ningun otro</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];
          ·fruits.ªpush('pera');

          console.log(·fruits);
          ⋗ /º ['kiwi', 'piña', 'uva', 'pera'] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".unshift()" hint="#añadeAlPrincipio">
        <p class="chaptrSubSect__p">Agrega elementos <mark>al principio</mark> del array. Tercera mejor performance porque al agregar al inicio tiene que desplazar todos los elementos hacia el final</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];
          ·fruits.ªunshift('pera');

          console.log(·fruits);
          ⋗ /º ['pera', 'kiwi', 'piña', 'uva'] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".splice()" hint="#añadeEnPosicionDada #peorPerformance">
        <p class="chaptrSubSect__p">Agrega un elemento en una posición dada. <mark>Peor performance</mark> de todos porque implica multiples operaciones: mover elementos, ajustar tamaño, etc</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];

          ·fruits.ªsplice(¬2, ¬0, '🍏');
          /* /º start, deleteCount, ...items º/*/

          console.log(·fruits);
          ⋗ /º ['kiwi', 'piña', '🍏', 'uva'] º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Sustituir elementos" codeText="">
      <ChaptrSubSect h4Title="Notación de corchete" codeText="[]">
        <p class="chaptrSubSect__p">Sustituye elementos poniendo la posición entre corchetes</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];
          ·fruits[¬1] = '🍍';

          console.log(·fruits);
          ⋗ /º ['kiwi', '🍍', 'uva'] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".splice()">
        <p class="chaptrSubSect__p">Sustituye un elemento en una posición dada</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];

          ·fruits.ªsplice(¬0, ¬1, '🥝');
          /*/º start, deleteCount, ...items º/*/

          console.log(·fruits);
          ⋗ /º ['🥝', 'piña', 'uva'] º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Eliminar elementos" codeText="">
      <ChaptrSubSect h4Title="El método" codeText=".pop()" hint="#extraeRetornaUltimoElemento">
        <p class="chaptrSubSect__p">Extrae un elemento del final y lo devuelve</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];
          let ·extracted = ·fruits.ªpop();

          console.log(·fruits);
          ⋗ /º ['kiwi', 'piña'] º/

          console.log(·extracted);
          ⋗ /º ['uva'] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".shift()" hint="#extraeRetornaPrimerElemento">
        <p class="chaptrSubSect__p">Extrae un elemento del inicio y lo devuelve</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];
          let ·extracted = ·fruits.ªshift();

          console.log(·fruits);
          ⋗ /º ['piña', 'uva'] º/

          console.log(·extracted);
          ⋗ "kiwi"</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".splice()" hint="#extraeRetornaElementoPosicionDada">
        <p class="chaptrSubSect__p">Elimina un elemento (y su posición) en una posición dada</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];
          let ·extracted = ·fruits.ªsplice(¬1, ¬1);
          /*/º start, deleteCount, ...items º/*/

          console.log(·fruits);
          ⋗ /º ['kiwi', 'uva'] º/

          console.log(·extracted);
          ⋗ "piña"</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="La orden" codeText="delete" hint="#borraValorDejaEspacio">
        <p class="chaptrSubSect__p">Borra el valor, dejandolo vacio, pero el espacio del elemento todavía sigue y pasa a ser <code>undefined</code></p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['kiwi', 'piña', 'uva'];
          delete ·fruits[¬1];

          console.log(·fruits);
          ⋗ /º ['kiwi', vacío, 'uva'] º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Buscar elementos" codeText="">
      <ChaptrSubSect h4Title="El método" codeText=".find()" hint="#buscaRetornaPrimerElementoCondición">
        <p class="chaptrSubSect__p">Busca el primer elemento en un array que cumpla con una condición específica, y lo retorna</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ªfind(@callback(#element, #index*, #array*), this*);

          /* Ejemplo */
          let ·numbers = [¬8567, ¬4321, ¬7432, ¬5555];
          let ·resultado = ·numbers.ªfind(#num =&gt; #num % ¬2 === ¬0);

          console.log(·resultado);
          ⋗ 7432</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".includes()" hint="#retornaBooleanSiCoincideValor">
        <p class="chaptrSubSect__p">Determina si un array contiene un elemento específico, devolviendo un valor booleano</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ªincludes(#element, #fromIndex*);

          /* Ejemplo */
          let ·numbers = [¬8567, ¬4321, ¬7432, ¬5555];
          let ·resultado = ·numbers.ªincludes(¬4321);

          console.log(·resultado);
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Buscar posición de un elemento" codeText="">
      <ChaptrSubSect h4Title="El método" codeText=".indexOf()" hint="#retornaIndicePrimeraCoincidenciaValor">
        <p class="chaptrSubSect__p">Obtiene el índice de la primera aparición de un elemento y lo retorna, o <code>-1</code> si el elemento no se encuentra. Este método usa igualdad estricta</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ªindexOf(#element, #fromIndex*);

          /* Ejemplo */
          let ·fruits = ['🥝', '🍏', '🍍', '🍌', '🍉'];
          let ·fruitIndex = ·fruits.ªindexOf('🍌');

          console.log(·fruitIndex);
          ⋗ 3</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".lastIndexOf()" hint="#retornaIndiceUltimaCoincidenciaValor">
        <p class="chaptrSubSect__p">Obtiene el índice de la última aparición de un elemento y lo  retorna, o <code>-1</code> si el elemento no se encuentra</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ªlastIndexOf(#element, #fromIndex*);

          /* Ejemplo */
          let ·fruits = ['🍉', '🍏', '🍉', '🍌', '🍉'];
          let ·fruitIndex = ·fruits.ªlastIndexOf('🍉');

          console.log(·fruitIndex);
          ⋗ 4</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".findIndex()" hint="#retornaIndicePrimeraCoincidenciaCallback">
        <p class="chaptrSubSect__p">Obtiene el indice del primer elemento de un array que satisface una condición proporcionada en forma de una función de prueba o callback</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ªfindIndex(@callback(#element, #index*, #array*) #this*;

          /* Ejemplo */
          let ·nums = [¬1, ¬3, ¬6, ¬7, ¬9, ¬10];
          let ·coincidence = ·nums.ªfindIndex(#num =&gt; #num % ¬2 === ¬0);

          console.log(·coincidence);
          ⋗ 2</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Longitud de un array" codeText="">
      <ChaptrSubSect h4Title="El método" codeText=".length" hint="#retornaTotalElementos">
        <p class="chaptrSubSect__p">Devuelve la cantidad de elementos en un array. La cuenta total de elementos en el array es su longitud, no su index</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['🥝', '🍏', '🍍', '🍌', '🍉'];

          console.log(·fruits.length);
          ⋗ 5</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Info de un Array" codeText="">
      <ChaptrSubSect h4Title="La orden" codeText=".typeof">
        <p class="chaptrSubSect__p"><b>NO</b> ayuda a distinguir un objeto de un array</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['🥝', '🍏', '🍍', '🍌', '🍉'];

          console.log(typeof ·fruits);
          ⋗ /º "object" º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText="Array.isArray()">
        <p class="chaptrSubSect__p">Devuelve <code>true</code> si el valor es un array y <code>false</code> si no lo es</p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['🥝', '🍏', '🍍', '🍌', '🍉'];

          console.log(Array.ªisArray(·fruits));
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".constructor.name" hint="#métodoRecomendado">
        <p class="chaptrSubSect__p">Nos dice realmente que tipo es, <mark>el recomendado</mark></p>
        <pre class="chaptrSubSect__console wScript">
          let ·fruits = ['🥝', '🍏', '🍍', '🍌', '🍉'];

          console.log(·fruits.constructor.•name);
          ⋗ /º "Array" º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Vaciar/truncar un array" codeText="">
      <ChaptrSubSect h4Title="Truncar array con" codeText=".length">
        <p class="chaptrSubSect__p">Si la incrementamos manualmente, se añaden elementos vacios. Si la decrementamos, el array se trunca</p>
        <pre class="chaptrSubSect__console wScript">
          let ·numbers = [¬1, ¬2, ¬3, ¬4, ¬5];
          ·numbers.length = ¬2;

          console.log(·numbers);
          ⋗ /º [1, 2] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Vaciar array con" codeText=".length">
        <p class="chaptrSubSect__p">La forma más simple de limpiar un array es igualar a <code>0</code> la propiedad <code>length</code></p>
        <pre class="chaptrSubSect__console wScript">
          let ·numbers = [¬1, ¬2, ¬3, ¬4, ¬5];
          ·numbers.length = ¬0;

          console.log(·numbers);
          ⋗ /º [] º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Unir/combinar arrays" codeText="">
      <ChaptrSubSect h4Title="El método" codeText=".concat()">
        <p class="chaptrSubSect__p">Combina dos o más arrays en uno nuevo. No muta los arrays originales</p>
        <pre class="chaptrSubSect__console wScript">
          let ·ceroAlDos = [¬0, ¬1, ¬2];
          let ·tresAlCinco = [¬3, ¬4, ¬5];
          let ·seisAlOcho = [¬6, ¬7, ¬8];
          let ·ceroAlOcho = ·ceroAlDos.ªconcat(·tresAlCinco, ·seisAlOcho);

          console.log(·ceroAlOcho);
          ⋗ /º [0, 1, 2, 3, 4, 5, 6, 7, 8] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El operador" codeText="...spread">
        <p class="chaptrSubSect__p">Combina dos o más arrays en uno nuevo. No muta los arrays originales</p>
        <pre class="chaptrSubSect__console wScript">
          let ·ceroAlDos = [¬0, ¬1, ¬2];
          let ·tresAlCinco = [¬3, ¬4, ¬5];
          let ·seisAlOcho = [¬6, ¬7, ¬8];
          let ·ceroAlOcho = [...·ceroAlDos, ...·tresAlCinco, ...·seisAlOcho];

          console.log(·ceroAlOcho);
          ⋗ /º [0, 1, 2, 3, 4, 5, 6, 7, 8] º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Ordenar array" codeText="">
      <ChaptrSubSect h4Title="El método" codeText=".sort()" hint="#ordenaOrdenAlfabético">
        <p class="chaptrSubSect__p">Se utiliza para ordenar los elementos de un array. Este método <mark>modifica</mark> el array. Por defecto, ordena los elementos del array como cadenas de texto en orden alfabético ascendente</p>
        <pre class="chaptrSubSect__console wScript">
          let ·numbers = [¬5, ¬3, ¬1, ¬4, ¬2];
          
          /* De mayor a menor */
          ·numbers.ªsort();
          console.log(·numbers);
          ⋗ /º [1, 2, 3, 4, 5] º/
        
          /* De menor a mayor */
          ·numbers.ªsort((#a, #b) =&gt; #b - #a);
          console.log(·numbers);
          ⋗ /º [5, 4, 3, 2, 1] º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Invertir array" codeText="">
      <ChaptrSubSect h4Title="El método" codeText=".reverse()" hint="#invierteArrayNoOrdena">
        <p class="chaptrSubSect__p">Este método <mark>invierte</mark> (sólo le da la vuelta) los elementos en el array original. Lo <mark>muta</mark> pero <mark>no lo ordena</mark></p>
        <pre class="chaptrSubSect__console wScript">
          let ·nums = [¬1, ¬2, ¬3, ¬4, ¬5];

          ·nums.ªreverse();
          console.log(·nums);
          ⋗ /º [5, 4, 3, 2, 1] º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Métodos de array" codeText="">
      <ChaptrSubSect h4Title="El método" codeText=".filter()" hint="#retornaArrayElementosCondición">
        <p class="chaptrSubSect__p">Devuelve un array filtrando elementos que cumplan con una cierta condición</p>
        <pre class="chaptrSubSect__console wScript">
          let ·nums = [¬1, ¬2, ¬3, ¬4, ¬5];
          let ·mayoresTres = ·nums.ªfilter(#num =&gt; #num &gt; ¬3);

          console.log(·mayoresTres);
          ⋗ /º [4, 5] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".map()" hint="#operaCadaElemento #retornaArrayElementosCondición">
        <p class="chaptrSubSect__p"><mark>Opera</mark> sobre cada elemento del array existente y ejecuta una función callback para cada uno. Devuelve un array con los elementos encontrados que cumplen la condición</p>
        <pre class="chaptrSubSect__console wScript">
          let ·nums = [¬1, ¬2, ¬3, ¬4, ¬5];
          let ·result = ·nums.ªmap(#num =&gt; #num * ¬10);

          console.log(·result);
          ⋗ /º [10, 20, 30, 40, 50] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".reduce()" hint="#reduceElementosArrayaUno #malaPerformance">
        <p class="chaptrSubSect__p">Se utiliza para reducir los elementos de un array a un solo valor. Este método toma una función callback como primer argumento y un valor inicial como segundo argumento</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Según dos conocidos ingenieros de Google, <mark>evita usar</mark> <code>reduce</code>. Tiene poca legibilidad y mala performance</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /º Array.reduce(callback((acumu, actualValue, index, arrayOrigin), acumuStart); º/

          /* Ejemplo */
          let ·nums = [¬1, ¬2, ¬3, ¬4, ¬5];
          let ·result = ·nums.ªreduce((#acumu, #actualValue) =&gt; #acumu + #actualValue;);

          console.log(·result);
          ⋗ 15</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>1ª iteración:</strong></li>
          <li class="chaptrSubSectUl__li--sub"><code>acumu</code> = 1 (primer elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub"><code>actualValue</code> = 2 (segundo elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub">Operación= 1 + 2 = 3.</li>
          <li class="chaptrSubSectUl__li--sub">Nuevo valor de <code>acumu</code> = 3.</li>
          <li class="chaptrSubSectUl__li"><strong>2ª iteración:</strong></li>
          <li class="chaptrSubSectUl__li--sub"><code>acumu</code> = 3 (resultado de la primera iteración).</li>
          <li class="chaptrSubSectUl__li--sub"><code>actualValue</code> = 3 (tercer elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub">Operación= 3 + 3 = 6.</li>
          <li class="chaptrSubSectUl__li--sub">Nuevo valor de <code>acumu</code> = 6.</li>
          <li class="chaptrSubSectUl__li"><strong>3ª iteración:</strong></li>
          <li class="chaptrSubSectUl__li--sub"><code>acumu</code> = 6 (resultado de la segunda iteración).</li>
          <li class="chaptrSubSectUl__li--sub"><code>actualValue</code> = 4 (cuarto elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub">Operación= 6 + 4 = 10.</li>
          <li class="chaptrSubSectUl__li--sub">Nuevo valor de <code>acumu</code> = 10.</li>
          <li class="chaptrSubSectUl__li"><strong>4ª iteración:</strong></li>
          <li class="chaptrSubSectUl__li--sub"><code>acumu</code> = 10 (resultado de la tercera iteración).</li>
          <li class="chaptrSubSectUl__li--sub"><code>actualValue</code> = 5 (cuarto elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub">Operación= 10 + 5 = 10.</li>
          <li class="chaptrSubSectUl__li--sub">Nuevo valor de <code>acumu</code> = 15.</li>
          <li class="chaptrSubSectUl__li">Resultado final = 15.</li>
        </ul>
        <p class="chaptrSubSect__p">Recomendado usar en: Suma, producto o reducción a un solo valor, contar elementos cumpliendo una condicion, agrupación de datos, aplanar arrays anidados</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".every()" hint="#retornaBooleanTodosElementosCondición">
        <p class="chaptrSubSect__p">Verifica si <mark>todos</mark> los elementos de un array cumplen una condición determinada. Si <mark>todos</mark> los elementos pasan la prueba <mark>retorna</mark> <code>true</code>, si algún elemento no pasa la prueba detiene la ejecución y <mark>retorna</mark> <code>false</code></p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /º Array.every(callback((element, index*, arrayOrigin*), this*); º/

          /* Ejemplo */
          let ·colors = ['red', 'green', 'blue', 'white'];
          let ·result = ·colors.ªevery(#element =&gt; #element.length &gt; ¬2);

          console.log(·result);
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".some()" hint="#retornaBooleanUnElementoCondición">
        <p class="chaptrSubSect__p">Verifica si al menos <mark>uno</mark> de los elementos del array cumple con la condición especificada en la función de callback que se pasa como argumento</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /º Array.every(callback((element, index*, arrayOrigin*), this*); º/

          /* Ejemplo */
          let ·colors = ['red', 'green', 'blue', 'white'];
          let ·result = ·colors.ªsome(#element =&gt; #element === 'blue');

          console.log(·result);
           ⋗ /º true º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".fill()" hint="#rellenaArrayValorEnPosiciónDada">
        <p class="chaptrSubSect__p">Es utilizado para llenar todos los elementos de un array con un valor estático desde una posición de inicio hasta una posición de fin especificada. Este método <mark>modifica</mark> el array original</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /º Array.fill(newValue, start*, end*); º/

          /* Ejemplo */
          let ·nums = [¬1, ¬2, ¬3, ¬4, ¬5];
          ·nums.ªfill('👑', ¬1, ¬4);

          console.log(·nums);
          ⋗ /º [1, '👑', '👑', '👑', 5] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".copyWithin()" hint="#copiaParteArrayDentroArray">
        <p class="chaptrSubSect__p">Copia una parte de un array a otra ubicación dentro del mismo array, sin modificar su tamaño. Esto significa que toma elementos de un rango del array y los pega en otra posición dentro del mismo array, sobrescribiendo los elementos existentes. Este método no agrega ni elimina elementos del array, simplemente cambia sus posiciones</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /º Array.copyWithin(target, start*, end*); º/

          /* Ejemplo */
          let ·vocals = ['a', 'e', 'i', 'o', 'u'];
          ·vocals.ªcopyWithin(¬2, ¬0, ¬2);

          console.log(·vocals);
          ⋗ /º ['a', 'e', 'a', 'e', 'u'] º/
          
          /*/º "target" Empieza a pegar desde la posicion 2 incluida = i º/*/
          /*/º "start" Empieza a copiar desde la posicion 0 incluida = a º/*/
          /*/º "end" Termina de copiar desde la posicion 2 no incluida = e º/*/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><code>target</code> es el indice donde comienza a pegar.</li>   
          <li class="chaptrSubSectUl__li"><code>start</code> es el indice desde el que empieza a copiar.</li>   
          <li class="chaptrSubSectUl__li"><code>end</code> es el indice hasta el que copia <mark>no incluido</mark>.</li>   
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".flat()" hint="#retornaArrayAplanado">
        <p class="chaptrSubSect__p">Se utiliza para aplanar arrays anidados. Este método crea una nueva matriz con todos los elementos de sub-array concatenados en ella de manera recursiva hasta la profundidad especificada</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /º Array.flat(depth*); º/

          /* Ejemplo */
          let ·numbers = [¬1, ¬2, [¬3, ¬4, [¬5, ¬6]]];
          let ·plainNumbers = ·numbers.ªflat(Infinity);

          console.log(·plainNumbers);
          ⋗ /º [1, 2, 3, 4, 5] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".flatMap()" hint="#1ºMap2ºFlat #operaCadaElementoAplana">
        <p class="chaptrSubSect__p">Es una combinación de los métodos <code>map()</code> y <code>flat()</code>. Este método se utiliza para aplanar un array a un nivel de profundidad y luego aplicar una función a cada elemento del array aplanado. Es equivalente a ejecutar primero <code>map()</code> y luego <code>flat()</code> de <mark>profundidad 1</mark> en un array, pero es ligeramente más eficiente que llamar a estos dos métodos por separado</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /º Array.flatMap(callback(element, index*, array*), this*); º/

          /* Ejemplo */
          const ·cart = [
          &#123; verduras: ¬2, items: ['lechuga', 'puerros'] &#125;,
          &#123; frutas: ¬2, items: ['uvas', 'kiwis'] &#125;,
          &#123; bebidas: ¬1, items: ['vino'] &#125;
        ];
        
        const ·allProducts = ·cart.ªflatMap(#section =&gt; #section.•items);
        
        console.log(·allProducts);
        ⋗ /º ['lechuga', 'puerros', 'uvas', 'kiwis', 'vino'] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".Array.from()" hint="#retornaArrayDeIterableoCadena">
        <p class="chaptrSubSect__p">Crea un Array a partir de un <mark><b>objeto iterable o similar a un array</b></mark>. Este método es muy útil cuando se necesita convertir datos que no son un array (como un conjunto de nodos del DOM o una cadena de texto) en un array</p>
        <pre class="chaptrSubSect__console wScript">
          const ·cadena = 'olaqase';
          const ·cadenaToArray = Array.from(·cadena);

          console.log(·cadenaToArray);
          ⋗ /º ['o', 'l', 'a', 'q', 'a', 's', 'e'] º/
        
          const ·allDivs = document.querySelectorAll('div');
          console.log(·allDivs);
          ⋗ /º [div.box-1, div.box-2, div.box-3] (Objeto arrayLike) º/

          const ·allDivsToArray = Array.from(·allDivs);
          console.log(·allDivsToArray);
          ⋗ /º["div.box-1", "div.box-2", "div.box-3"]º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".Array.of()" hint="#retornaArrayDeElementos">
        <p class="chaptrSubSect__p">Se utiliza para crear un nuevo arreglo con una cantidad variable de elementos, independientemente de su tipo</p>
        <pre class="chaptrSubSect__console wScript">
          const ·str = 'Hola';
          const ·num = ¬5;
          const ·char = '$';
          const ·bool = true;
          const ·empt = null;

          const ·newArr = Array.ªof(·str, ·num, ·char, ·bool, ·empt);
          console.log(·newArr);
          ⋗ /º['Hola', 5, '$', true, null]º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".keys()" hint="#retornaIteradorClavesIndices">
        <p class="chaptrSubSect__p">Devuelve un nuevo objeto <mark>iterador</mark> de Array que contiene las claves para cada índice en el array</p>
        <pre class="chaptrSubSect__console wScript">
          const ·fruits = ['apple', 'kiwi', 'orange', 'banana'];

          const ·newIterator = ·fruits.ªkeys();
          console.log(·newIterator);
          ⋗ /ºObject [Array Iterator] &#123;__proto__ &#123; next: ƒ next() &#125;&#125;º/
        
          const ·newArray = Array.from(·newIterator);
          console.log(·newArray);
          ⋗ /º[0, 1, 2, 3]º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".values()" hint="#retornaIteradorValoresIndices">
        <p class="chaptrSubSect__p">Devuelve un nuevo objeto <mark>iterador</mark> de Array que contiene los valores para cada índice en el array. Este método es útil cuando quieres convertir un objeto iterable en un array para poder usar los métodos de array en él. Por ejemplo, si tienes un objeto <mark>NodeList</mark></p>
        <pre class="chaptrSubSect__console wScript">
          /* html */
          /º &lt;p&gt;1&lt;/p&gt; º/
          /º &lt;p&gt;2&lt;/p&gt; º/
          /º &lt;p&gt;3&lt;/p&gt; º/
          /º &lt;p&gt;4&lt;/p&gt; º/
          /º &lt;p&gt;5&lt;/p&gt; º/

          /* js*/
          const ·allP = document.querySelectorAll('p');
          const ·arrPValues = ·allP.ªvalues();    /*/º array de elementos &lt;p&gt; º/*/
          
          for (const #p of ·arrPValues)&#123;     /*/º necesitamos entrar(iterar) en cada &lt;p&gt; º/*/
            console.log(#p.•textContent)
          &#125;
          
          ⋗ /º "1" º/
          ⋗ /º "2" º/
          ⋗ /º "3" º/
          ⋗ /º "4" º/
          ⋗ /º "5" º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".entries()" hint="#retornaArrayArrays[Clave,Valor]">
        <p class="chaptrSubSect__p">Devuelve un nuevo objeto <mark>iterador</mark> de Array que contiene pares clave/valor para cada índice en el array. En otras palabras, genera un array de arrays, donde cada array interno tiene dos elementos: el primer elemento es el índice y el segundo elemento es el valor en ese índice</p>
          <pre class="chaptrSubSect__console wScript">
            /* html */
            /º &lt;p&gt;'uno'&lt;/p&gt; º/
            /º &lt;p&gt;'dos'&lt;/p&gt; º/
            /º &lt;p&gt;'tres'&lt;/p&gt; º/
            /º &lt;p&gt;'cuatro'&lt;/p&gt; º/
            /º &lt;p&gt;'cinco'&lt;/p&gt; º/
  
            /* js*/
            /*/º NodeList de los &lt;p&gt; º/*/
            const ·allP = document.querySelectorAll('p');

            /*/º Convertimos a array para usar .entries() º/*/
            const ·pArray = Array.from(·allP);
            
            /*/º Usamos .entries() para obtener array de arrays [índice, elemento] º/*/
            const ·entries = ·pArray.ªentries();
            
            /*/º Iteramos sobre los pares [índice, elemento] º/*/
            for (const [#index, #p] of ·entries) &#123;
              console.log(`/ºÍndice: $&#123;#index&#125; → Texto: $&#123;#p.•textContent&#125;º/`);
            &#125;
            
            ⋗ /º "Índice: 1 → 'uno'" º/
            ⋗ /º "Índice: 2 → 'dos'" º/
            ⋗ /º "Índice: 3 → 'tres'" º/
            ⋗ /º "Índice: 4 → 'cuatro'" º/
            ⋗ /º "Índice: 5 → 'cinco'" º/
          
          </pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Bucles de array" codeText="">
      <ChaptrSubSect h4Title="El bucle" codeText=".forEach()">
        <p class="chaptrSubSect__p">Itera sobre cada elemento del array existente y ejecuta una función para cada uno. A diferencia de <code>map()</code> o <code>filter()</code>, <code>forEach()</code> <mark>no devuelve un nuevo arreglo</mark> ni modifica el arreglo original, y tampoco pueden ser usadas las sentencias <code>break</code> o <code>return</code>. Sólo sirve para mostrar el resultado no para asignarlo a una variable por ejemplo</p>
        <pre class="chaptrSubSect__console">
          <span class="key">const</span> <span class="var">numbers</span> <span class="opera">=</span> <span class="warp">[<span class="nums">1, 2, 3, 4, 5</span>]</span>;

          <span class="var">numbers</span><span class="dot">.</span><span class="meth">forEach</span><span class="warp">(<span class="params">num</span> <span class="opera">⇒</span> &#123
            <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">num</span> <span class="opera">*</span> <span class="nums">2</span>)</span>;
          &#125)</span>;

          <span class="result">2 4 6 8 10</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El bucle" codeText="while()">
        <p class="chaptrSubSect__p">Es especialmente útil cuando no sabes cuántas veces necesitas que se ejecute el ciclo. Puedes usarlo cuando estás esperando a que se complete una acción específica, como esperar a que un usuario ingrese información válida</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">num</span> <span class="opera">=</span> <span class="nums">5</span>;

          <span class="key">while</span> <span class="warp">(<span class="var">num</span> <span class="opera">&lt;</span> <span class="num">10</span>) &#123;
            <span class="var">num</span><span class="opera">++</span>;
            <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">num</span>)</span>;
          &#125;</span>;

          <span class="result">6 7 8 9</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El bucle" codeText="for()">
        <p class="chaptrSubSect__p">Es recomendable usarlo cuando conocemos la cantidad de veces que queremos que se ejecute un bloque de código. Es especialmente útil para recorrer arrays y objetos, realizar operaciones repetitivas un número específico de veces, o cuando necesitamos un contador dentro del bucle</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">numbers</span> <span class="opera">=</span> <span class="warp">[<span class="nums">1, 2, 3, 4, 5</span>]</span>;

          <span class="key">for</span> <span class="warp">(<span class="key">let</span> <span class="params">index</span> <span class="opera">=</span> <span class="nums">0</span>; <span class="params">index</span> <span class="opera">&lt;</span> <span class="var">numbers</span><span class="dot">.</span><span class="meth">length</span>; <span class="params">index</span> <span class="opera">++</span>) &#123;
            <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">numbers</span><span class="warp">[<span class="params">index</span>]</span>)</span>;
          &#125;</span>;

          <span class="result">1 2 3 4 5</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El bucle" codeText="for(of)">
        <p class="chaptrSubSect__p">Se recomienda usar cuando necesitas trabajar con los valores de un objeto iterable, como un array o una cadena, y no te importa el índice de los elementos. Este ciclo es más sencillo y legible cuando no necesitas trabajar con el índice, a diferencia del ciclo <code>for()</code> tradicional o el método <code>forEach()</code></p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">numbers</span> <span class="opera">=</span> <span class="warp">[<span class="nums">1, 2, 3, 4, 5</span>]</span>;

          <span class="key">for</span> <span class="warp">(<span class="params">number</span> <span class="key">of</span> <span class="var">numbers</span>) &#123;
            <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="params">number</span>)</span>;
          &#125;</span>;

          <span class="result">1 2 3 4 5</span></pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Conversión a" codeText="String">
      <ChaptrSubSect h4Title="El método" codeText=".join()">
        <p class="chaptrSubSect__p">Se utiliza para unir todos los elementos de un array en una sola cadena de texto. Por defecto, separa los elementos con comas. Sin embargo, puedes especificar un separador diferente pasándolo como argumento al método</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">presentacionArr</span> <span class="opera">=</span> <span class="warp">['Me', 'llamo', 'Eder']</span>;
          <span class="key">let</span> <span class="var">myNewString</span> <span class="opera">=</span> <span class="var">presentacionArr</span><span class="dot">.</span><span class="meth">join</span><span class="warp">(' ')</span>;
          
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">myNewString</span>)</span>;
          <span class="result">'Me llamo Eder'</span>

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="key">typeof</span> <span class="var">myNewString</span>)</span>;
          <span class="result">String</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="La función" codeText="String()">
        <p class="chaptrSubSect__p">Los arrays tienen su propia implementación del método <code>String()</code> que devuelve un lista de elementos separados por coma</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">presentacionArr</span> <span class="opera">=</span> <span class="warp">['Me', 'llamo', 'Eder']</span>;
          <span class="key">let</span> <span class="var">myNewString</span> <span class="opera">=</span> <span class="func">String</span><span class="warp">(<span class="var">presentacionArr</span>)</span>;
          
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">myNewString</span>)</span>;
          <span class="result">'Me,llamo,Eder'</span>

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="key">typeof</span> <span class="var">myNewString</span>)</span>;
          <span class="result">String</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".toString()">
        <p class="chaptrSubSect__p">Convierte un array en una cadena lista de elementos separados por coma</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">presentacionArr</span> <span class="opera">=</span> <span class="warp">['Me', 'llamo', 'Eder']</span>;
          <span class="key">let</span> <span class="var">myNewString</span> <span class="opera">=</span> <span class="var">presentacionArr</span><span class="dot">.</span><span class="meth">toString</span><span class="warp">()</span>;
          
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">myNewString</span>)</span>;
          <span class="result">'Me,llamo,Eder'</span>

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="key">typeof</span> <span class="var">myNewString</span>)</span>;
          <span class="result">String</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".toLocaleString()">
        <p class="chaptrSubSect__p">Se utiliza para convertir un array en una cadena de texto, utilizando las convenciones de formato de la localización</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">presentacionArr</span> <span class="opera">=</span> <span class="warp">['Me', 'llamo', 'Eder']</span>;
          <span class="key">let</span> <span class="var">myNewString</span> <span class="opera">=</span> <span class="var">presentacionArr</span><span class="dot">.</span><span class="meth">toLocaleString</span><span class="warp">('es-ES')</span>;
          
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">myNewString</span>)</span>;
          <span class="result">'Me,llamo,Eder'</span>

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="key">typeof</span> <span class="var">myNewString</span>)</span>;
          <span class="result">String</span></pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Comparación de arrays" codeText="">
      <ChaptrSubSect h4Title="Los métodos" codeText="short() + every()">
        <p class="chaptrSubSect__p">Para comparar arrays de <mark>elementos primitivos</mark> (números, cadenas de texto, etc.)</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">myArr1</span> <span class="opera">=</span> <span class="warp">[<span class="args">'uno', <span class="nums">1</span>, 'dos', <span class="nums">2</span>, <span class="key">true</span></span>]</span>;
          <span class="key">let</span> <span class="var">myArr2</span> <span class="opera">=</span> <span class="warp">[<span class="args"><span class="key">true</span>, <span class="nums">2</span>, 'dos', <span class="nums">1</span>, 'uno'</span>]</span>;

          <span class="key">function</span> <span class="func">comparaArr</span><span class="warp">(<span class="params">array1, array2</span>) &#123;</span>
              <span class="commnt">Ordenamos los arrays</span>
              <span class="params">array1</span><span class="dot">.</span><span class="meth">sort</span><span class="warp">()</span>;
              <span class="params">array2</span><span class="dot">.</span><span class="meth">sort</span><span class="warp">()</span>;

              <span class="commnt">Comprobamos longitud</span>
              <span class="key">if</span> <span class="warp">(<span class="params">array1</span><span class="dot">.</span><span class="meth">length</span> <span class="opera">≢</span> <span class="params">array2</span><span class="dot">.</span><span class="meth">length</span>) &#123;</span>
                <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="args">'Los arrays NO tienen la misma longitud'</span>);
                <span class="key">return</span>;
              &#125;</span>;

              <span class="commnt">Comprobamos cada elemento en cada posicion</span>
              <span class="key">let</span> <span class="var">sonIguales</span> <span class="opera">=</span> <span class="params">array1</span><span class="dot">.</span><span class="meth">every</span><span class="warp">((<span class="params">element, index</span>) <span class="opera">⇒</span> &#123;</span>
                <span class="key">let</span> <span class="var">igualdad <span class="opera">=</span> <span class="params">element</span> <span class="opera">≡</span> <span class="params">array2</span><span class="warp">[<span class="params">index</span>]</span></span>;
                <span class="commnt">Si es true lo almacenara en "igualdad"</span> 
                <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(
                  <span class="args">`Posición $&#123;<span class="params">index</span>&#125;: $&#123;<span class="params">element</span>&#125; <span class="opera">≡</span> $&#123;<span class="params">array2<span class="warp">[<span class="params">index</span>]</span></span>&#125; <span class="opera">⇒</span> 
                $&#123;<span class="var">igualdad</span> <span class="opera">?</span> 'true' <span class="opera">:</span> 'false'&#125;`</span>
                )</span>;
                <span class="commnt">Si igualdad es true devuelve lo primero,
                //Si no, devuelve lo segundo</span>
                <span class="key">return</span> <span class="var">igualdad</span>;
              <span class="warp">&#125;)</span></span>;

              <span class="key">if</span> <span class="warp">(<span class="var">sonIguales</span>) &#123;
                <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span>(<span class="args">'Misma longitud y elementos!'</span>);
              &#125;;
              
            &#125;</span>;

          <span class="func">comparaArr</span><span class="warp">(<span class="var">myArr1, myArr2</span>)</span>;  
          <span class="result">Posición 0: 1 === 1 ⇒ true
            Posición 1: 2 === 2 ⇒ true
            Posición 2: dos === dos ⇒ true
            Posición 3: true === true ⇒ true
            Posición 4: uno === uno ⇒ true
            Misma longitud y elementos!</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText="JSON.stringify()">
        <p class="chaptrSubSect__p">Para comparar arrays de <mark>elementos primitivos</mark> (números, cadenas de texto, etc.)</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">myArr1</span> <span class="opera">=</span> <span class="warp">[<span class="args">'uno', <span class="nums">1</span>, 'dos', <span class="nums">2</span>, <span class="key">true</span></span>]</span>;
          <span class="key">let</span> <span class="var">myArr2</span> <span class="opera">=</span> <span class="warp">[<span class="args"><span class="key">true</span>, <span class="nums">2</span>, 'dos', <span class="nums">1</span>, 'uno'</span>]</span>;

          <span class="key">function</span> <span class="func">comparaArr</span><span class="warp">(<span class="params">array1, array2</span>) &#123;</span>
              <span class="commnt">Ordenamos los arrays</span>
              <span class="params">array1</span><span class="dot">.</span><span class="meth">sort</span><span class="warp">()</span>;
              <span class="params">array2</span><span class="dot">.</span><span class="meth">sort</span><span class="warp">()</span>;

              <span class="key">if</span> <span class="warp">(<span class="obj">JSON</span><span class="dot">.</span><span class="meth">stringify</span>(<span class="params">array1</span>) <span class="opera">===</span> <span class="obj">JSON</span><span class="dot">.</span><span class="meth">stringify</span>(<span class="params">array2</span>)) &#123;
                <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="args">'Son iguales'</span>)</span>;
              &#125; <span class="key">else</span> &#123;
              <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="args">'No son iguales'</span>)</span>;
              &#125;
            &#125;</span>;

          <span class="func">comparaArr</span><span class="warp">(<span class="var">myArr1, myArr2</span>)</span>;  
          <span class="result">Son iguales</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Iterando el array con" codeText="for()">
        <p class="chaptrSubSect__p">Para comparar arrays de <mark>elementos primitivos</mark> (números, cadenas de texto, etc.)</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">myArr1</span> <span class="opera">=</span> <span class="warp">[<span class="args">'uno', <span class="nums">1</span>, 'dos', <span class="nums">2</span>, <span class="key">true</span></span>]</span>;
          <span class="key">let</span> <span class="var">myArr2</span> <span class="opera">=</span> <span class="warp">[<span class="args"><span class="key">true</span>, <span class="nums">2</span>, 'dos', <span class="nums">1</span>, 'uno'</span>]</span>;

          <span class="key">function</span> <span class="func">comparaArr</span><span class="warp">(<span class="params">array1, array2</span>) &#123;</span>
              <span class="commnt">Ordenamos los arrays</span>
              <span class="params">array1</span><span class="dot">.</span><span class="meth">sort</span><span class="warp">()</span>;
              <span class="params">array2</span><span class="dot">.</span><span class="meth">sort</span><span class="warp">()</span>;

              <span class="commnt">Comprobamos longitud</span>
              <span class="key">if</span> <span class="warp">(<span class="params">array1</span><span class="dot">.</span><span class="meth">length</span> <span class="opera">≢</span> <span class="params">array2</span><span class="dot">.</span><span class="meth">length</span>) &#123;</span>
                <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="args">'Los arrays NO tienen la misma longitud'</span>);
                <span class="key">return</span>;
              &#125;</span>;

              <span class="commnt">Comprobamos cada elemento en cada posicion</span>
              <span class="key">for</span> <span class="warp">(<span class="key">let</span> <span class="params">index</span> <span class="opera">=</span> <span class="nums">0</span>; <span class="params">index</span> <span class="opera">&lt;</span> <span class="params">array1</span><span class="dot">.</span><span class="meth">length</span>; <span class="params">index</span><span class="opera">++</span>) &#123;</span>
                <span class="key">if</span><span class="warp">(<span class="params">array1</span>[<span class="params">index</span>] <span class="opera">!==</span> <span class="params">array2</span>[<span class="params">index</span>]) &#123;</span>
                  <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="args">'En la posición $&#123;<span class="params">index</span>&#125; no coinciden'</span>)</span>;
                  <span class="key">return</span>;
                <span class="warp">&#125;;
              &#125;</span></span>;

              <span class="commnt">Si llegamos aquí, todos los elementos son iguales</span>
              <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="args">'Misma longitud y elementos!'</span>);
            &#125;</span>;

          <span class="func">comparaArr</span><span class="warp">(<span class="var">myArr1, myArr2</span>)</span>;  
          <span class="result">Misma longitud y elementos!</span></pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Copia de arrays" codeText="">
      <ChaptrSubSect h4Title="Con el método" codeText=".slice()">
        <p class="chaptrSubSect__p">Se utiliza para seleccionar una parte de un array y devolverla como un nuevo array. Este método <mark>no modifica el original</mark></p>
        <pre class="chaptrSubSect__console">
          <span class="commnt">Sintaxis</span>
          <span class="var">Array</span><span class="dot">.</span><span class="meth">slice</span><span class="warp">(<span class="params">inicio, fin</span>)</span>;

          <span class="commnt">Ejemplo</span>
          <span class="key">let</span> <span class="var">numbers</span> <span class="opera">=</span> <span class="warp">[<span class="nums">1, 2, 3, 4, 5</span>]</span>;
          <span class="key">let</span> <span class="var">result</span> <span class="opera">=</span> <span class="var">numbers</span><span class="dot">.</span><span class="meth">slice</span><span class="warp">(<span class="nums">3</span>)</span>;

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">result</span>)</span>
          <span class="result">[4, 5]</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Con el operador" codeText="...spread">
        <p class="chaptrSubSect__p">Para copiar un array <mark>plano</mark> podemos usar el <code>spread</code> operator</p>
        <pre class="chaptrSubSect__console">
          <span class="key">const</span> <span class="var">colors</span> <span class="opera">=</span> <span class="warp">[<span class="args">'red', 'blue', 'green'</span>]</span>;
          <span class="key">const</span> <span class="var">copyColors</span> <span class="opera">=</span> <span class="warp">[<span class="dot">...</span><span class="var">colors</span>]</span>;

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">copyColors</span>)</span>
          <span class="result">['red', 'blue', 'green']</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Con el método" codeText=".concat()">
        <p class="chaptrSubSect__p">Para copiar un array <mark>plano</mark></p>
        <pre class="chaptrSubSect__console">
          <span class="key">const</span> <span class="var">colors</span> <span class="opera">=</span> <span class="warp">[<span class="args">'red', 'blue', 'green'</span>]</span>;
          <span class="key">const</span> <span class="var">copyColors</span> <span class="opera">=</span> <span class="warp">[]</span><span class="dot">.</span><span class="warp">(<span class="var">colors</span>)</span>;

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">copyColors</span>)</span>
          <span class="result">['red', 'blue', 'green']</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Con el método" codeText="Array.from()">
        <p class="chaptrSubSect__p">Para copiar un array <mark>plano</mark></p>
        <pre class="chaptrSubSect__console">
          <span class="key">const</span> <span class="var">colors</span> <span class="opera">=</span> <span class="warp">[<span class="args">'red', 'blue', 'green'</span>]</span>;
          <span class="key">const</span> <span class="var">copyColors</span> <span class="opera">=</span> <span class="obj">Array</span><span class="dot">.</span><span class="meth">from</span><span class="warp">(<span class="var">colors</span>)</span>;

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">copyColors</span>)</span>
          <span class="result">['red', 'blue', 'green']</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Con los métodos" codeText="JSON.parse() + JSON.stringify()">
        <p class="chaptrSubSect__p">Para hacer una copia <mark>profunda</mark> de una array</p>
        <pre class="chaptrSubSect__console">
          <span class="key">const</span> <span class="var">colors</span> <span class="opera">=</span> <span class="warp">[<span class="args">'red', 'blue', 'green'</span>]</span>;
          <span class="key">const</span> <span class="var">copyColors</span> <span class="opera">=</span> <span class="obj">JSON</span><span class="dot">.</span><span class="meth">parse</span><span class="warp">(<span class="obj">JSON</span><span class="dot">.</span><span class="meth">stringify</span><span class="warp">(<span class="var">colors</span>)</span>)</span>;

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">copyColors</span>)</span>
          <span class="result">['red', 'blue', 'green']</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Con el operador" codeText="structuredClone()">
        <p class="chaptrSubSect__p">Para hacer una copia <mark>profunda</mark> y así no romper la referencia del original</p>
        <pre class="chaptrSubSect__console">
          <span class="key">const</span> <span class="var">colors</span> <span class="opera">=</span> <span class="warp">[<span class="args">'red', 'blue', 'green'</span>]</span>;
          <span class="key">const</span> <span class="var">copyColors</span> <span class="opera">=</span> <span class="func">structuredClone</span><span class="warp">(<span class="var">colors</span>)</span>;

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">copyColors</span>)</span>
          <span class="result">['red', 'blue', 'green']</span></pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Destructuring de arrays" codeText="">
      <ChaptrSubSect h4Title="Asignación desestructurante" codeText="">
        <p class="chaptrSubSect__p">La asignación desestructurante es una sintaxis especial que nos permite “desempaquetar” arrays u objetos en varias variables, porque a veces es más conveniente</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> <span class="var">myArr</span> <span class="opera">=</span> <span class="warp">['Eder', 'Rod'];
          <span class="key">let</span> [<span class="var">firstName, surName</span>]</span> <span class="opera">=</span> <span class="var">myArr</span>;
          <span class="commnt">firstName = myArr[0]</span>
          <span class="commnt">surName = myArr[1]</span>

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">firstName</span>)</span>;  
          <span class="result">'Eder'</span>
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">surName</span>)</span>;    
          <span class="result">'Rod'</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El parámetro" codeText="...rest">
        <p class="chaptrSubSect__p">En general, si el array es mayor que la lista de la izquierda, los ítems extras son omitidos, si queremos también obtener todo lo que sigue, podemos agregarle un parámetro que obtiene “el resto” usando puntos suspensivos <code>…</code> con lo que se guardará en la variable <code>rest</code> un array con los valores que "restan"</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> [<span class="var">one, two, <span class="dot">...</span><span class="key">rest</span></span>]</span> <span class="opera">=</span> <span class="warp">[<span class="nums">1, 2, 3, 4, 5</span>]</span>;

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">one</span>)</span>;  
          <span class="result">1</span>
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">two</span>)</span>;    
          <span class="result">2</span>
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">rest</span>)</span>;    
          <span class="result">[3, 4, 5]</span>
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">rest</span><span class="warp">[<span class="nums">2</span>]</span>)</span>;    
          <span class="result">5</span></pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Valores predeterminados" codeText="">
        <p class="chaptrSubSect__p">Si queremos un valor “predeterminado” para reemplazar el valor faltante, podemos proporcionarlo utilizando <code>=</code>. Los valores predeterminados pueden ser expresiones más complejas e incluso llamadas a función, que serán evaluadas sólo si el valor no ha sido proporcionado</p>
        <pre class="chaptrSubSect__console">
          <span class="key">let</span> [<span class="var">name, surname <span class="opera">=</span> <span class="args">'Nieve'</span></span>]</span> <span class="opera">=</span> <span class="warp">[<span class="args">'Éder', 'Rod'</span>]</span>;

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">name</span>)</span>;  
          <span class="result">'Éder'</span>
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">surname</span>)</span>;    
          <span class="result">Rod</span>

          <span class="key">let</span> [<span class="var">name, surname <span class="opera">=</span> <span class="args">'Nieve'</span></span>]</span> <span class="opera">=</span> <span class="warp">[<span class="args">'Iker'</span>]</span>;

          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">name</span>)</span>;  
          <span class="result">'Iker'</span>
          <span class="obj">console</span><span class="dot">.</span><span class="meth">log</span><span class="warp">(<span class="var">surname</span>)</span>;    
          <span class="result">Nieve</span></pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_10" nextPage="/lessons/lesson_12"/>
</MainLayout>



<!-- 
&lt;&gt;
&#123;&#125;
()&#123;&#125;
﹛﹜    Llaves no estiladas
﹕     2 puntos no estilizados
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ ∞Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<img class="chaptrSubSect__img" src=`${ruta}img13.webp` alt="captura del evento">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li"></li>
＃
-->