---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__11" h2Title="Arrays" slot="mainContent">
    <ChaptrSect h3Title="CreaciÃ³n de arrays" codeText="">
      <ChaptrSubSect h4Title="NotaciÃ³n corchetes" codeText="[]" hint="#mÃ©todoRecomendada">
        <p class="chaptrSubSect__p">Es la forma <mark>recomendada</mark></p>
        <pre class="chaptrSubSect__console wScript">
          let Â·numbers = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Contructor de arrays" codeText="new" hint="#noRecomendada">
        <p class="chaptrSubSect__p">Se utiliza para crear instancias de arrays, no es <mark>nada recomendable</mark>. Los Ãºnicos usos serÃ­an crear un array vacio con un tamaÃ±o especÃ­fico, y crear un array dinÃ¡micamente</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creado dinÃ¡micamente */
          let Â·arrWithContent = new Array(Â¬5, Â¬4, Â¬3, Â¬2, Â¬1);
          console.log(Â·arrWithContent);
          â‹— [5, 4, 3, 2, 1]

          /*/Âº Array vacio con x posiciones Âº/*/
          let Â·arrWithSize = new Array(Â¬5);
          console.log(Â·arrWithSize);
          â‹— /Âº[ &lt;5 empty items&gt; ] Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Acceso a elementos" codeText="[]">
      <ChaptrSubSect h4Title="NotaciÃ³n corchetes" codeText="[]">
        <p class="chaptrSubSect__p">Poniendo la posiciÃ³n que ocupa en el array entre corchetes</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];

          console.log(Â·fruits[Â¬0]);
          â‹— "kiwi"

          console.log(Â·fruits[Â¬2]);
          â‹— "uva"</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Agregar elementos" codeText="">
      <ChaptrSubSect h4Title="NotaciÃ³n de corchete" codeText="[]" hint="#mejorPerformance #aÃ±adeEnPosicionDada">
        <p class="chaptrSubSect__p">Agrega elementos poniendo la posiciÃ³n entre corchetes. <mark>Mejor performance</mark> de todos porque no desplaza elementos ni otra operaciÃ³n.</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = [ 'kiwi', 'piÃ±a', 'uva' ];
          Â·fruits[Â¬3] = 'pera';

          console.log(Â·fruits);
          â‹— /Âº ['kiwi', 'piÃ±a', 'uva', 'pera'] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".push()" hint="#aÃ±adeAlFinal #segundoMejorPerformance">
        <p class="chaptrSubSect__p">Agrega elementos <mark>al final</mark> del array. Tiene la segunda mejor performance porque solo aÃ±ade al final sin desplazar ningun otro</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];
          Â·fruits.Âªpush('pera');

          console.log(Â·fruits);
          â‹— /Âº ['kiwi', 'piÃ±a', 'uva', 'pera'] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".unshift()" hint="#aÃ±adeAlPrincipio">
        <p class="chaptrSubSect__p">Agrega elementos <mark>al principio</mark> del array. Tercera mejor performance porque al agregar al inicio tiene que desplazar todos los elementos hacia el final</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];
          Â·fruits.Âªunshift('pera');

          console.log(Â·fruits);
          â‹— /Âº ['pera', 'kiwi', 'piÃ±a', 'uva'] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".splice()" hint="#aÃ±adeEnPosicionDada #peorPerformance">
        <p class="chaptrSubSect__p">Agrega un elemento en una posiciÃ³n dada. <mark>Peor performance</mark> de todos porque implica multiples operaciones: mover elementos, ajustar tamaÃ±o, etc</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];

          Â·fruits.Âªsplice(Â¬2, Â¬0, 'ğŸ');
          /* /Âº start, deleteCount, ...items Âº/*/

          console.log(Â·fruits);
          â‹— /Âº ['kiwi', 'piÃ±a', 'ğŸ', 'uva'] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".toSpliced()" hint="#aÃ±adeEnPosicionDadaNoMuta #peorPerformance">
        <p class="chaptrSubSect__p">Agrega un elemento en una posiciÃ³n dada. <mark>Peor performance</mark> de todos porque implica multiples operaciones: mover elementos, ajustar tamaÃ±o, etc. No muta el array original.</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];

          Â·fruits.ÂªtoSpliced(Â¬2, Â¬0, 'ğŸ');
          /* /Âº start, deleteCount, ...items Âº/*/

          console.log(Â·fruits);
          â‹— /Âº ['kiwi', 'piÃ±a', 'ğŸ', 'uva'] Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Sustituir elementos" codeText="">
      <ChaptrSubSect h4Title="NotaciÃ³n de corchete" codeText="[]">
        <p class="chaptrSubSect__p">Sustituye elementos poniendo la posiciÃ³n entre corchetes</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];
          Â·fruits[Â¬1] = 'ğŸ';

          console.log(Â·fruits);
          â‹— /Âº ['kiwi', 'ğŸ', 'uva'] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".splice()">
        <p class="chaptrSubSect__p">Sustituye un elemento en una posiciÃ³n dada</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];

          Â·fruits.Âªsplice(Â¬0, Â¬1, 'ğŸ¥');
          /*/Âº start, deleteCount, ...items Âº/*/

          console.log(Â·fruits);
          â‹— /Âº ['ğŸ¥', 'piÃ±a', 'uva'] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".toSpliced()">
        <p class="chaptrSubSect__p">Sustituye un elemento en una posiciÃ³n dada, no muta el array original</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];

          Â·fruits.ÂªtoSpliced(Â¬0, Â¬1, 'ğŸ¥');
          /*/Âº start, deleteCount, ...items Âº/*/

          console.log(Â·fruits);
          â‹— /Âº ['ğŸ¥', 'piÃ±a', 'uva'] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".with()">
        <p class="chaptrSubSect__p">Permite reemplazar un elemento en una posiciÃ³n especÃ­fica de un array, sin modificar el original, devolviendo un nuevo array con el cambio aplicado. Recomendado si actualizas un solo elemento por Ã­ndice</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];

          Â·fruits.Âªwith(Â¬0, 'ğŸ¥');
          /*/Âº index, newValue Âº/*/

          console.log(Â·fruits);
          â‹— /Âº ['ğŸ¥', 'piÃ±a', 'uva'] Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Eliminar elementos" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".pop()" hint="#extraeRetornaUltimoElemento">
        <p class="chaptrSubSect__p">Extrae un elemento del final y lo devuelve</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];
          let Â·extracted = Â·fruits.Âªpop();

          console.log(Â·fruits);
          â‹— /Âº ['kiwi', 'piÃ±a'] Âº/

          console.log(Â·extracted);
          â‹— /Âº ['uva'] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".shift()" hint="#extraeRetornaPrimerElemento">
        <p class="chaptrSubSect__p">Extrae un elemento del inicio y lo devuelve</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];
          let Â·extracted = Â·fruits.Âªshift();

          console.log(Â·fruits);
          â‹— /Âº ['piÃ±a', 'uva'] Âº/

          console.log(Â·extracted);
          â‹— "kiwi"</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".splice()" hint="#extraeRetornaElementoPosicionDada">
        <p class="chaptrSubSect__p">Elimina un elemento (y su posiciÃ³n) en una posiciÃ³n dada</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];
          let Â·extracted = Â·fruits.Âªsplice(Â¬1, Â¬1);
          /*/Âº start, deleteCount, ...items Âº/*/

          console.log(Â·fruits);
          â‹— /Âº ['kiwi', 'uva'] Âº/

          console.log(Â·extracted);
          â‹— "piÃ±a"</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".toSpliced()" hint="#extraeRetornaElementoPosicionDadaNoMuta">
        <p class="chaptrSubSect__p">Elimina un elemento (y su posiciÃ³n) en una posiciÃ³n dada, no muta el array original</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];
          let Â·extracted = Â·fruits.ÂªtoSpliced(Â¬1, Â¬1);
          /*/Âº start, deleteCount, ...items Âº/*/

          console.log(Â·fruits);
          â‹— /Âº ['kiwi', 'uva'] Âº/

          console.log(Â·extracted);
          â‹— "piÃ±a"</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="La orden" codeText="delete" hint="#borraValorDejaEspacio">
        <p class="chaptrSubSect__p">Borra el valor, dejandolo vacio, pero el espacio del elemento todavÃ­a sigue y pasa a ser <code>undefined</code></p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['kiwi', 'piÃ±a', 'uva'];
          delete Â·fruits[Â¬1];

          console.log(Â·fruits);
          â‹— /Âº ['kiwi', vacÃ­o, 'uva'] Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Buscar elementos" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".find()" hint="#buscaRetornaPrimerElementoCondiciÃ³n">
        <p class="chaptrSubSect__p">Busca el primer elemento en un array que cumpla con una condiciÃ³n especÃ­fica, y lo retorna</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.Âªfind(@callback(#element, #index*, #array*), this*);

          /* Ejemplo */
          let Â·numbers = [Â¬8567, Â¬4321, Â¬7432, Â¬5555];
          let Â·resultado = Â·numbers.Âªfind(#num =&gt; #num % Â¬2 === Â¬0);

          console.log(Â·resultado);
          â‹— 7432</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".includes()" hint="#retornaBooleanSiCoincideValor">
        <p class="chaptrSubSect__p">Determina si un array contiene un elemento especÃ­fico, devolviendo un valor booleano</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.Âªincludes(#element, #fromIndex*);

          /* Ejemplo */
          let Â·numbers = [Â¬8567, Â¬4321, Â¬7432, Â¬5555];
          let Â·resultado = Â·numbers.Âªincludes(Â¬4321);

          console.log(Â·resultado);
          â‹— /Âº true Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".findLast()" hint="#buscaRetornaPrimerElementoCondiciÃ³nDesdeElFinal">
        <p class="chaptrSubSect__p">Encuentra el primer elemento que cumple una condiciÃ³n, buscando desde el Ãºltimo elemento hacia el primero</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ÂªfindLast(@callback(#element, #index*, #array*), this*);

          /* Ejemplo */
          let Â·numbers = [Â¬8560, Â¬4321, Â¬7432, Â¬5555];
          let Â·resultado = Â·numbers.ÂªfindLast(#num =&gt; #num % Â¬2 === Â¬0);

          console.log(Â·resultado);
          â‹— 7432</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Agrupacion de elementos" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText="Object.groupBy()" hint="#agrupaPorCondiciÃ³nNoMuta">
        <p class="chaptrSubSect__p">Agrupa los elementos de un array en un objeto, donde cada clave es el resultado de la funciÃ³n de agrupamiento y los valores son arrays de los elementos correspondientes</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Object.ÂªgroupBy(#iterator, @callbackFn(#element, #index*, #array*), this*);</pre>

        <pre class="chaptrSubSect__console wScript">
          /* Ejemplo 1*/
          const Â·nums = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5, Â¬6];

          const Â·numsByCat = Object.@groupBy(Â·nums, #num =&gt; #num % Â¬2 === Â¬0 ? 'par' : 'impar');

          console.log(Â·numsByCat);
          â‹— /Âº &#123; Âº/
            /Âº"par": [Â¬2, Â¬4, Â¬6], Âº/
           /Âº "impar": [Â¬1, Â¬3, Â¬5] Âº/
          /Âº &#125; Âº/
        </pre>

        <pre class="chaptrSubSect__console wScript">
          /* Ejemplo 2*/
          const Â·productos = [
            &#123; name: 'Leche', cat: 'lÃ¡cteos' &#125;,
            &#123; name: 'Queso', cat: 'lÃ¡cteos' &#125;,
            &#123; name: 'Manzana', cat: 'frutas' &#125;,
            &#123; name: 'PlÃ¡tano', cat: 'frutas' &#125;
          ];

          const Â·productsByCat = Object.@groupBy(Â·productos, #producto =&gt; #producto.â€¢cat);

          console.log(Â·productsByCat);
          â‹— /Âº &#123; Âº/
            /Âº"lÃ¡cteos": [ Âº/
             /Âº &#123; name: "Leche", cat: "lÃ¡cteos" &#125;, Âº/
             /Âº &#123; name: "Queso", cat: "lÃ¡cteos" &#125; Âº/
            /Âº], Âº/
           /Âº frutas: [ Âº/
             /Âº &#123; name: "Manzana", cat: "frutas" &#125;, Âº/
             /Âº &#123; name: "PlÃ¡tano", cat: "frutas" &#125; Âº/
            /Âº ] Âº/
          /Âº &#125; Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Buscar posiciÃ³n de un elemento" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".indexOf()" hint="#retornaIndicePrimeraCoincidenciaValor">
        <p class="chaptrSubSect__p">Obtiene el Ã­ndice de la primera apariciÃ³n de un elemento y lo retorna, o <code>-1</code> si el elemento no se encuentra. Este mÃ©todo usa igualdad estricta</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ÂªindexOf(#element, #fromIndex*);

          /* Ejemplo */
          let Â·fruits = ['ğŸ¥', 'ğŸ', 'ğŸ', 'ğŸŒ', 'ğŸ‰'];
          let Â·fruitIndex = Â·fruits.ÂªindexOf('ğŸŒ');

          console.log(Â·fruitIndex);
          â‹— 3</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".lastIndexOf()" hint="#retornaIndiceUltimaCoincidenciaValor">
        <p class="chaptrSubSect__p">Obtiene el Ã­ndice de la Ãºltima apariciÃ³n de un elemento y lo  retorna, o <code>-1</code> si el elemento no se encuentra</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ÂªlastIndexOf(#element, #fromIndex*);

          /* Ejemplo */
          let Â·fruits = ['ğŸ‰', 'ğŸ', 'ğŸ‰', 'ğŸŒ', 'ğŸ‰'];
          let Â·fruitIndex = Â·fruits.ÂªlastIndexOf('ğŸ‰');

          console.log(Â·fruitIndex);
          â‹— 4</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".findIndex()" hint="#retornaIndicePrimeraCoincidenciaCallback">
        <p class="chaptrSubSect__p">Obtiene el indice del primer elemento de un array que satisface una condiciÃ³n proporcionada en forma de una funciÃ³n de prueba o callback</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ÂªfindIndex(@callback(#element, #index*, #array*) #this*;

          /* Ejemplo */
          let Â·nums = [Â¬1, Â¬3, Â¬6, Â¬7, Â¬9, Â¬10];
          let Â·coincidence = Â·nums.ÂªfindIndex(#num =&gt; #num % Â¬2 === Â¬0);

          console.log(Â·coincidence);
          â‹— 2</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".findLastIndex()" hint="#retornaIndicePrimeraCoincidenciaCallbackNoMuta">
        <p class="chaptrSubSect__p">Obtiene el indice del ultimo elemento de un array que satisface una condiciÃ³n proporcionada en forma de una funciÃ³n de prueba o callback. No modifica el array original</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Array.ÂªfindLastIndex(@callback(#element, #index*, #array*) #this*;

          /* Ejemplo */
          let Â·nums = [Â¬1, Â¬3, Â¬6, Â¬7, Â¬9, Â¬10];
          let Â·coincidence = Â·nums.ÂªfindLastIndex(#num =&gt; #num % Â¬2 === Â¬0);

          console.log(Â·coincidence);
          â‹— 4</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Longitud de un array" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".length" hint="#retornaTotalElementos">
        <p class="chaptrSubSect__p">Devuelve la cantidad de elementos en un array. La cuenta total de elementos en el array es su longitud, no su index</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['ğŸ¥', 'ğŸ', 'ğŸ', 'ğŸŒ', 'ğŸ‰'];

          console.log(Â·fruits.length);
          â‹— 5</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Info de un Array" codeText="">
      <ChaptrSubSect h4Title="La orden" codeText=".typeof">
        <p class="chaptrSubSect__p"><b>NO</b> ayuda a distinguir un objeto de un array</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['ğŸ¥', 'ğŸ', 'ğŸ', 'ğŸŒ', 'ğŸ‰'];

          console.log(typeof Â·fruits);
          â‹— /Âº "object" Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText="Array.isArray()">
        <p class="chaptrSubSect__p">Devuelve <code>true</code> si el valor es un array y <code>false</code> si no lo es</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['ğŸ¥', 'ğŸ', 'ğŸ', 'ğŸŒ', 'ğŸ‰'];

          console.log(Array.ÂªisArray(Â·fruits));
          â‹— /Âº true Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".constructor.name" hint="#mÃ©todoRecomendado">
        <p class="chaptrSubSect__p">Nos dice realmente que tipo es, <mark>el recomendado</mark></p>
        <pre class="chaptrSubSect__console wScript">
          let Â·fruits = ['ğŸ¥', 'ğŸ', 'ğŸ', 'ğŸŒ', 'ğŸ‰'];

          console.log(Â·fruits.constructor.â€¢name);
          â‹— /Âº "Array" Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Vaciar/truncar un array" codeText="">
      <ChaptrSubSect h4Title="Truncar array con" codeText=".length">
        <p class="chaptrSubSect__p">Si la incrementamos manualmente, se aÃ±aden elementos vacios. Si la decrementamos, el array se trunca</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·numbers = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];
          Â·numbers.length = Â¬2;

          console.log(Â·numbers);
          â‹— /Âº [1, 2] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Vaciar array con" codeText=".length">
        <p class="chaptrSubSect__p">La forma mÃ¡s simple de limpiar un array es igualar a <code>0</code> la propiedad <code>length</code></p>
        <pre class="chaptrSubSect__console wScript">
          let Â·numbers = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];
          Â·numbers.length = Â¬0;

          console.log(Â·numbers);
          â‹— /Âº [] Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Unir/combinar arrays" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".concat()">
        <p class="chaptrSubSect__p">Combina dos o mÃ¡s arrays en uno nuevo. No muta los arrays originales</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·ceroAlDos = [Â¬0, Â¬1, Â¬2];
          let Â·tresAlCinco = [Â¬3, Â¬4, Â¬5];
          let Â·seisAlOcho = [Â¬6, Â¬7, Â¬8];
          let Â·ceroAlOcho = Â·ceroAlDos.Âªconcat(Â·tresAlCinco, Â·seisAlOcho);

          console.log(Â·ceroAlOcho);
          â‹— /Âº [0, 1, 2, 3, 4, 5, 6, 7, 8] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El operador" codeText="...spread">
        <p class="chaptrSubSect__p">Combina dos o mÃ¡s arrays en uno nuevo. No muta los arrays originales</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·ceroAlDos = [Â¬0, Â¬1, Â¬2];
          let Â·tresAlCinco = [Â¬3, Â¬4, Â¬5];
          let Â·seisAlOcho = [Â¬6, Â¬7, Â¬8];
          let Â·ceroAlOcho = [...Â·ceroAlDos, ...Â·tresAlCinco, ...Â·seisAlOcho];

          console.log(Â·ceroAlOcho);
          â‹— /Âº [0, 1, 2, 3, 4, 5, 6, 7, 8] Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Ordenar array" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".sort()" hint="#ordenaOrdenAlfabÃ©tico">
        <p class="chaptrSubSect__p">Se utiliza para ordenar los elementos de un array. Este mÃ©todo <mark>modifica</mark> el array. Por defecto, ordena los elementos del array como cadenas de texto en orden alfabÃ©tico ascendente</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·numbers = [Â¬5, Â¬3, Â¬1, Â¬4, Â¬2];
          
          /* De mayor a menor */
          Â·numbers.Âªsort();
          console.log(Â·numbers);
          â‹— /Âº [1, 2, 3, 4, 5] Âº/
        
          /* De menor a mayor */
          Â·numbers.Âªsort((#a, #b) =&gt; #b - #a);
          console.log(Â·numbers);
          â‹— /Âº [5, 4, 3, 2, 1] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".toSorted()" hint="#ordenaOrdenAlfabÃ©ticoNoMutaArray">
        <p class="chaptrSubSect__p">Se utiliza para ordenar los elementos de un array. Este mÃ©todo <mark>no modifica</mark> el array original. Por defecto, ordena los elementos del array como cadenas de texto en orden alfabÃ©tico ascendente</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·numbers = [Â¬5, Â¬3, Â¬1, Â¬4, Â¬2];
          
          /* De mayor a menor */
          let Â·sortedAsc = Â·numbers.ÂªtoSorted();
          console.log(Â·sortedAsc);
          â‹— /Âº [1, 2, 3, 4, 5] Âº/

          /* De menor a mayor */
          let Â·sortedDesc = Â·numbers.ÂªtoSorted((#a, #b) =&gt; #b - #a);
          console.log(Â·sortedDesc);
          Â·numbers.Âªsort();
          console.log(Â·numbers);
          â‹— /Âº [1, 2, 3, 4, 5] Âº/
        
          /* De menor a mayor */
          Â·numbers.Âªsort((#a, #b) =&gt; #b - #a);
          console.log(Â·numbers);
          â‹— /Âº [5, 4, 3, 2, 1] Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Invertir array" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".reverse()" hint="#invierteArrayNoOrdena">
        <p class="chaptrSubSect__p">Este mÃ©todo <mark>invierte</mark> (sÃ³lo le da la vuelta) los elementos en el array original. Lo <mark>muta</mark> pero <mark>no lo ordena</mark></p>
        <pre class="chaptrSubSect__console wScript">
          let Â·nums = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];

          Â·nums.Âªreverse();
          console.log(Â·nums);
          â‹— /Âº [5, 4, 3, 2, 1] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".toReversed()" hint="#invierteArrayNoOrdenaNoMuta">
        <p class="chaptrSubSect__p">Este mÃ©todo <mark>invierte</mark> (sÃ³lo le da la vuelta a modo espejo) los elementos en el array original. <mark>No muta</mark> y <mark>no lo ordena</mark></p>
        <pre class="chaptrSubSect__console wScript">
          let Â·nums = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];

          let Â·reversed = Â·nums.ÂªtoReversed();
          console.log(Â·reversed);
          â‹— /Âº [5, 4, 3, 2, 1] Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="MÃ©todos de array" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".filter()" hint="#retornaArrayElementosCondiciÃ³n">
        <p class="chaptrSubSect__p">Devuelve un array filtrando elementos que cumplan con una cierta condiciÃ³n</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·nums = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];
          let Â·mayoresTres = Â·nums.Âªfilter(#num =&gt; #num &gt; Â¬3);

          console.log(Â·mayoresTres);
          â‹— /Âº [4, 5] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".map()" hint="#operaCadaElemento #retornaArrayElementosCondiciÃ³n">
        <p class="chaptrSubSect__p"><mark>Opera</mark> sobre cada elemento del array existente y ejecuta una funciÃ³n callback para cada uno. Devuelve un array con los elementos encontrados que cumplen la condiciÃ³n</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·nums = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];
          let Â·result = Â·nums.Âªmap(#num =&gt; #num * Â¬10);

          console.log(Â·result);
          â‹— /Âº [10, 20, 30, 40, 50] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".reduce()" hint="#reduceElementosArrayaUno #malaPerformance">
        <p class="chaptrSubSect__p">Se utiliza para reducir los elementos de un array a un solo valor. Este mÃ©todo toma una funciÃ³n callback como primer argumento y un valor inicial como segundo argumento</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">SegÃºn dos conocidos ingenieros de Google, <mark>evita usar</mark> <code>reduce</code>. Tiene poca legibilidad y mala performance</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /Âº Array.reduce(callback((acumu, actualValue, index, arrayOrigin), acumuStart); Âº/

          /* Ejemplo */
          let Â·nums = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];
          let Â·result = Â·nums.Âªreduce((#acumu, #actualValue) =&gt; #acumu + #actualValue;);

          console.log(Â·result);
          â‹— 15</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>1Âª iteraciÃ³n:</strong></li>
          <li class="chaptrSubSectUl__li--sub"><code>acumu</code> = 1 (primer elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub"><code>actualValue</code> = 2 (segundo elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub">OperaciÃ³n= 1 + 2 = 3.</li>
          <li class="chaptrSubSectUl__li--sub">Nuevo valor de <code>acumu</code> = 3.</li>
          <li class="chaptrSubSectUl__li"><strong>2Âª iteraciÃ³n:</strong></li>
          <li class="chaptrSubSectUl__li--sub"><code>acumu</code> = 3 (resultado de la primera iteraciÃ³n).</li>
          <li class="chaptrSubSectUl__li--sub"><code>actualValue</code> = 3 (tercer elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub">OperaciÃ³n= 3 + 3 = 6.</li>
          <li class="chaptrSubSectUl__li--sub">Nuevo valor de <code>acumu</code> = 6.</li>
          <li class="chaptrSubSectUl__li"><strong>3Âª iteraciÃ³n:</strong></li>
          <li class="chaptrSubSectUl__li--sub"><code>acumu</code> = 6 (resultado de la segunda iteraciÃ³n).</li>
          <li class="chaptrSubSectUl__li--sub"><code>actualValue</code> = 4 (cuarto elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub">OperaciÃ³n= 6 + 4 = 10.</li>
          <li class="chaptrSubSectUl__li--sub">Nuevo valor de <code>acumu</code> = 10.</li>
          <li class="chaptrSubSectUl__li"><strong>4Âª iteraciÃ³n:</strong></li>
          <li class="chaptrSubSectUl__li--sub"><code>acumu</code> = 10 (resultado de la tercera iteraciÃ³n).</li>
          <li class="chaptrSubSectUl__li--sub"><code>actualValue</code> = 5 (cuarto elemento del array).</li>
          <li class="chaptrSubSectUl__li--sub">OperaciÃ³n= 10 + 5 = 10.</li>
          <li class="chaptrSubSectUl__li--sub">Nuevo valor de <code>acumu</code> = 15.</li>
          <li class="chaptrSubSectUl__li">Resultado final = 15.</li>
        </ul>
        <p class="chaptrSubSect__p">Recomendado usar en: Suma, producto o reducciÃ³n a un solo valor, contar elementos cumpliendo una condicion, agrupaciÃ³n de datos, aplanar arrays anidados</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".every()" hint="#retornaBooleanTodosElementosCondiciÃ³n">
        <p class="chaptrSubSect__p">Verifica si <mark>todos</mark> los elementos de un array cumplen una condiciÃ³n determinada. Si <mark>todos</mark> los elementos pasan la prueba <mark>retorna</mark> <code>true</code>, si algÃºn elemento no pasa la prueba detiene la ejecuciÃ³n y <mark>retorna</mark> <code>false</code></p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /Âº Array.every(callback((element, index*, arrayOrigin*), this*); Âº/

          /* Ejemplo */
          let Â·colors = ['red', 'green', 'blue', 'white'];
          let Â·result = Â·colors.Âªevery(#element =&gt; #element.length &gt; Â¬2);

          console.log(Â·result);
          â‹— /Âº true Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".some()" hint="#retornaBooleanUnElementoCondiciÃ³n">
        <p class="chaptrSubSect__p">Verifica si al menos <mark>uno</mark> de los elementos del array cumple con la condiciÃ³n especificada en la funciÃ³n de callback que se pasa como argumento</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /Âº Array.every(callback((element, index*, arrayOrigin*), this*); Âº/

          /* Ejemplo */
          let Â·colors = ['red', 'green', 'blue', 'white'];
          let Â·result = Â·colors.Âªsome(#element =&gt; #element === 'blue');

          console.log(Â·result);
           â‹— /Âº true Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".fill()" hint="#rellenaArrayValorEnPosiciÃ³nDada">
        <p class="chaptrSubSect__p">Es utilizado para llenar todos los elementos de un array con un valor estÃ¡tico desde una posiciÃ³n de inicio hasta una posiciÃ³n de fin especificada. Este mÃ©todo <mark>modifica</mark> el array original</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /Âº Array.fill(newValue, start*, end*); Âº/

          /* Ejemplo */
          let Â·nums = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];
          Â·nums.Âªfill('ğŸ‘‘', Â¬1, Â¬4);

          console.log(Â·nums);
          â‹— /Âº [1, 'ğŸ‘‘', 'ğŸ‘‘', 'ğŸ‘‘', 5] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".copyWithin()" hint="#copiaParteArrayDentroArray">
        <p class="chaptrSubSect__p">Copia una parte de un array a otra ubicaciÃ³n dentro del mismo array, sin modificar su tamaÃ±o. Esto significa que toma elementos de un rango del array y los pega en otra posiciÃ³n dentro del mismo array, sobrescribiendo los elementos existentes. Este mÃ©todo no agrega ni elimina elementos del array, simplemente cambia sus posiciones</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /Âº Array.copyWithin(target, start*, end*); Âº/

          /* Ejemplo */
          let Â·vocals = ['a', 'e', 'i', 'o', 'u'];
          Â·vocals.ÂªcopyWithin(Â¬2, Â¬0, Â¬2);

          console.log(Â·vocals);
          â‹— /Âº ['a', 'e', 'a', 'e', 'u'] Âº/
          
          /*/Âº "target" Empieza a pegar desde la posicion 2 incluida = i Âº/*/
          /*/Âº "start" Empieza a copiar desde la posicion 0 incluida = a Âº/*/
          /*/Âº "end" Termina de copiar desde la posicion 2 no incluida = e Âº/*/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><code>target</code> es el indice donde comienza a pegar.</li>   
          <li class="chaptrSubSectUl__li"><code>start</code> es el indice desde el que empieza a copiar.</li>   
          <li class="chaptrSubSectUl__li"><code>end</code> es el indice hasta el que copia <mark>no incluido</mark>.</li>   
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".flat()" hint="#retornaArrayAplanado">
        <p class="chaptrSubSect__p">Se utiliza para aplanar arrays anidados. Este mÃ©todo crea una nueva matriz con todos los elementos de sub-array concatenados en ella de manera recursiva hasta la profundidad especificada</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /Âº Array.flat(depth*); Âº/

          /* Ejemplo */
          let Â·numbers = [Â¬1, Â¬2, [Â¬3, Â¬4, [Â¬5, Â¬6]]];
          let Â·plainNumbers = Â·numbers.Âªflat(Infinity);

          console.log(Â·plainNumbers);
          â‹— /Âº [1, 2, 3, 4, 5] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".flatMap()" hint="#1ÂºMap2ÂºFlat #operaCadaElementoAplana">
        <p class="chaptrSubSect__p">Es una combinaciÃ³n de los mÃ©todos <code>map()</code> y <code>flat()</code>. Este mÃ©todo se utiliza para aplanar un array a un nivel de profundidad y luego aplicar una funciÃ³n a cada elemento del array aplanado. Es equivalente a ejecutar primero <code>map()</code> y luego <code>flat()</code> de <mark>profundidad 1</mark> en un array, pero es ligeramente mÃ¡s eficiente que llamar a estos dos mÃ©todos por separado</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          /Âº Array.flatMap(callback(element, index*, array*), this*); Âº/

          /* Ejemplo */
          const Â·cart = [
          &#123; verduras: Â¬2, items: ['lechuga', 'puerros'] &#125;,
          &#123; frutas: Â¬2, items: ['uvas', 'kiwis'] &#125;,
          &#123; bebidas: Â¬1, items: ['vino'] &#125;
        ];
        
        const Â·allProducts = Â·cart.ÂªflatMap(#section =&gt; #section.â€¢items);
        
        console.log(Â·allProducts);
        â‹— /Âº ['lechuga', 'puerros', 'uvas', 'kiwis', 'vino'] Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".Array.from()" hint="#retornaArrayDeIterableoCadena">
        <p class="chaptrSubSect__p">Crea un Array a partir de un <mark><b>objeto iterable o similar a un array</b></mark>. Este mÃ©todo es muy Ãºtil cuando se necesita convertir datos que no son un array (como un conjunto de nodos del DOM o una cadena de texto) en un array</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·cadena = 'olaqase';
          const Â·cadenaToArray = Array.from(Â·cadena);

          console.log(Â·cadenaToArray);
          â‹— /Âº ['o', 'l', 'a', 'q', 'a', 's', 'e'] Âº/
        
          const Â·allDivs = document.querySelectorAll('div');
          console.log(Â·allDivs);
          â‹— /Âº [div.box-1, div.box-2, div.box-3] (Objeto arrayLike) Âº/

          const Â·allDivsToArray = Array.from(Â·allDivs);
          console.log(Â·allDivsToArray);
          â‹— /Âº["div.box-1", "div.box-2", "div.box-3"]Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".Array.of()" hint="#retornaArrayDeElementos">
        <p class="chaptrSubSect__p">Se utiliza para crear un nuevo arreglo con una cantidad variable de elementos, independientemente de su tipo</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·str = 'Hola';
          const Â·num = Â¬5;
          const Â·char = '$';
          const Â·bool = true;
          const Â·empt = null;

          const Â·newArr = Array.Âªof(Â·str, Â·num, Â·char, Â·bool, Â·empt);
          console.log(Â·newArr);
          â‹— /Âº['Hola', 5, '$', true, null]Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".keys()" hint="#retornaIteradorClavesIndices">
        <p class="chaptrSubSect__p">Devuelve un nuevo objeto <mark>iterador</mark> de Array que contiene las claves para cada Ã­ndice en el array</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·fruits = ['apple', 'kiwi', 'orange', 'banana'];

          const Â·newIterator = Â·fruits.Âªkeys();
          console.log(Â·newIterator);
          â‹— /ÂºObject [Array Iterator] &#123;__proto__ &#123; next: Æ’ next() &#125;&#125;Âº/
        
          const Â·newArray = Array.from(Â·newIterator);
          console.log(Â·newArray);
          â‹— /Âº[0, 1, 2, 3]Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".values()" hint="#retornaIteradorValoresIndices">
        <p class="chaptrSubSect__p">Devuelve un nuevo objeto <mark>iterador</mark> de Array que contiene los valores para cada Ã­ndice en el array. Este mÃ©todo es Ãºtil cuando quieres convertir un objeto iterable en un array para poder usar los mÃ©todos de array en Ã©l. Por ejemplo, si tienes un objeto <mark>NodeList</mark></p>
        <pre class="chaptrSubSect__console wScript">
          /* html */
          /Âº &lt;p&gt;1&lt;/p&gt; Âº/
          /Âº &lt;p&gt;2&lt;/p&gt; Âº/
          /Âº &lt;p&gt;3&lt;/p&gt; Âº/
          /Âº &lt;p&gt;4&lt;/p&gt; Âº/
          /Âº &lt;p&gt;5&lt;/p&gt; Âº/

          /* js*/
          const Â·allP = document.querySelectorAll('p');
          const Â·arrPValues = Â·allP.Âªvalues();    /*/Âº array de elementos &lt;p&gt; Âº/*/
          
          for (const #p of Â·arrPValues)&#123;     /*/Âº necesitamos entrar(iterar) en cada &lt;p&gt; Âº/*/
            console.log(#p.â€¢textContent)
          &#125;
          
          â‹— /Âº "1" Âº/
          â‹— /Âº "2" Âº/
          â‹— /Âº "3" Âº/
          â‹— /Âº "4" Âº/
          â‹— /Âº "5" Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".entries()" hint="#retornaArrayArrays[Clave,Valor]">
        <p class="chaptrSubSect__p">Devuelve un nuevo objeto <mark>iterador</mark> de Array que contiene pares clave/valor para cada Ã­ndice en el array. En otras palabras, genera un array de arrays, donde cada array interno tiene dos elementos: el primer elemento es el Ã­ndice y el segundo elemento es el valor en ese Ã­ndice</p>
          <pre class="chaptrSubSect__console wScript">
            /* html */
            /Âº &lt;p&gt;'uno'&lt;/p&gt; Âº/
            /Âº &lt;p&gt;'dos'&lt;/p&gt; Âº/
            /Âº &lt;p&gt;'tres'&lt;/p&gt; Âº/
            /Âº &lt;p&gt;'cuatro'&lt;/p&gt; Âº/
            /Âº &lt;p&gt;'cinco'&lt;/p&gt; Âº/
  
            /* js*/
            /*/Âº NodeList de los &lt;p&gt; Âº/*/
            const Â·allP = document.querySelectorAll('p');

            /*/Âº Convertimos a array para usar .entries() Âº/*/
            const Â·pArray = Array.from(Â·allP);
            
            /*/Âº Usamos .entries() para obtener array de arrays [Ã­ndice, elemento] Âº/*/
            const Â·entries = Â·pArray.Âªentries();
            
            /*/Âº Iteramos sobre los pares [Ã­ndice, elemento] Âº/*/
            for (const [#index, #p] of Â·entries) &#123;
              console.log(`/ÂºÃndice: $&#123;#index&#125; â†’ Texto: $&#123;#p.â€¢textContent&#125;Âº/`);
            &#125;
            
            â‹— /Âº "Ãndice: 1 â†’ 'uno'" Âº/
            â‹— /Âº "Ãndice: 2 â†’ 'dos'" Âº/
            â‹— /Âº "Ãndice: 3 â†’ 'tres'" Âº/
            â‹— /Âº "Ãndice: 4 â†’ 'cuatro'" Âº/
            â‹— /Âº "Ãndice: 5 â†’ 'cinco'" Âº/
          
          </pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Bucles de array" codeText="">
      <ChaptrSubSect h4Title="El bucle" codeText=".forEach()">
        <p class="chaptrSubSect__p">Itera sobre cada elemento del array existente y ejecuta una funciÃ³n para cada uno. A diferencia de <code>map()</code> o <code>filter()</code>, <code>forEach()</code> <mark>no devuelve un nuevo arreglo</mark> ni modifica el arreglo original, y tampoco pueden ser usadas las sentencias <code>break</code> o <code>return</code>. SÃ³lo sirve para mostrar el resultado no para asignarlo a una variable por ejemplo</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·numbers = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];

          Â·numbers.forEach(#num =&gt; &#123;
            console.log(#num * Â¬10);
          &#125;);

          â‹— /Âº 10 Âº/
          â‹— /Âº 20 Âº/
          â‹— /Âº 30 Âº/
          â‹— /Âº 40 Âº/
          â‹— /Âº 50 Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El bucle" codeText="while()">
        <p class="chaptrSubSect__p">Es especialmente Ãºtil cuando no sabes cuÃ¡ntas veces necesitas que se ejecute el ciclo. Puedes usarlo cuando estÃ¡s esperando a que se complete una acciÃ³n especÃ­fica, como esperar a que un usuario ingrese informaciÃ³n vÃ¡lida</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·count = Â¬0;
          const Â·max = Â¬5;

          while (Â·count &lt; Â·max) &#123;
            console.log(Â·count);
            Â·count++;
          &#125;

          â‹— /Âº 0 Âº/
          â‹— /Âº 1 Âº/
          â‹— /Âº 2 Âº/
          â‹— /Âº 3 Âº/
          â‹— /Âº 4 Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El bucle" codeText="for()">
        <p class="chaptrSubSect__p">Es recomendable usarlo cuando conocemos la cantidad de veces que queremos que se ejecute un bloque de cÃ³digo. Es especialmente Ãºtil para recorrer arrays y objetos, realizar operaciones repetitivas un nÃºmero especÃ­fico de veces, o cuando necesitamos un contador dentro del bucle</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·numbers = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];

          for (let Â·i = Â¬0; Â·i &lt; Â·numbers.length; Â·i++) &#123;
            console.log(Â·numbers[Â·i]);
          &#125;

          â‹— /Âº 1 Âº/
          â‹— /Âº 2 Âº/
          â‹— /Âº 3 Âº/
          â‹— /Âº 4 Âº/
          â‹— /Âº 5 Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El bucle" codeText="for(of)">
        <p class="chaptrSubSect__p">Se recomienda usar cuando necesitas trabajar con los valores de un objeto iterable, como un array o una cadena, y no te importa el Ã­ndice de los elementos. Este ciclo es mÃ¡s sencillo y legible cuando no necesitas trabajar con el Ã­ndice, a diferencia del ciclo <code>for()</code> tradicional o el mÃ©todo <code>forEach()</code></p>
        <pre class="chaptrSubSect__console wScript">
          let Â·numbers = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];

          for (let #num of Â·numbers) &#123;
            console.log(#num);
          &#125;

          â‹— /Âº 1 Âº/
          â‹— /Âº 2 Âº/
          â‹— /Âº 3 Âº/
          â‹— /Âº 4 Âº/
          â‹— /Âº 5 Âº/
        </pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="ConversiÃ³n a" codeText="String">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".join()">
        <p class="chaptrSubSect__p">Se utiliza para unir todos los elementos de un array en una sola cadena de texto. Por defecto, separa los elementos con comas. Sin embargo, puedes especificar un separador diferente pasÃ¡ndolo como argumento al mÃ©todo</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·presentacionArr = ['Me', 'llamo', 'Eder'];
          let Â·myNewString = Â·presentacionArr.@join(' ');

          console.log(Â·myNewString);
          â‹— /Âº 'Me llamo Eder' Âº/

          console.log(Â·myNewString.length);
          â‹— /Âº 13 Âº/
          
          console.log(Â·myNewString.â€¢charAt(Â¬0));
          â‹— /Âº 'M' Âº/
          
          console.log(typeof Â·myNewString);
          â‹— /Âº String Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="La funciÃ³n" codeText="String()">
        <p class="chaptrSubSect__p">Los arrays tienen su propia implementaciÃ³n del mÃ©todo <code>String()</code> que devuelve un lista de elementos separados por coma</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·presentacionArr = ['Me', 'llamo', 'Eder'];
          let Â·myNewString = @String(Â·presentacionArr);

          console.log(Â·myNewString);
          â‹— /Âº 'Me,llamo,Eder' Âº/

          console.log(typeof Â·myNewString);
          â‹— /Âº String Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".toString()">
        <p class="chaptrSubSect__p">Convierte un array en una cadena lista de elementos separados por coma</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·presentacionArr = ['Me', 'llamo', 'Eder'];
          let Â·myNewString = Â·presentacionArr.toString();

          console.log(Â·myNewString);
          â‹— /Âº 'Me,llamo,Eder' Âº/

          console.log(typeof Â·myNewString);
          â‹— /Âº String Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El mÃ©todo" codeText=".toLocaleString()">
        <p class="chaptrSubSect__p">Se utiliza para convertir un array en una cadena de texto, utilizando las convenciones de formato de la localizaciÃ³n</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·presentacionArr = ['Me', 'llamo', 'Eder'];
          let Â·myNewString = Â·presentacionArr.@toLocaleString('es-ES');

          console.log(Â·myNewString);
          â‹— /Âº 'Me,llamo,Eder' Âº/

          console.log(typeof Â·myNewString);
          â‹— /Âº String Âº/
        </pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="ComparaciÃ³n de arrays" codeText="">
      <ChaptrSubSect h4Title="El mÃ©todo" codeText="JSON.stringify()">
        <p class="chaptrSubSect__p">Para comparar arrays de <mark>longitud, tipo y valor</mark> (nÃºmeros, cadenas de texto, etc.)</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·firstArray = ['uno', Â¬1, 'dos', Â¬2, true];
          let Â·secondArray = [true, Â¬2, 'dos', Â¬1, 'uno'];

          function @compararArray(#arrayUno, #arrayDos) &#123;
            if (#arrayUno.length !== #arrayDos.length) &#123;
              console.log('/Âº âŒ Distinta longitud! Âº/');
              return;
            &#125;

            let Â·stringArrayUno = #arrayUno.@map(#elemento =&gt; Ã§JSON.@stringify(#elemento)).Âªsort();
            let Â·stringArrayDos = #arrayDos.@map(#elemento =&gt; Ã§JSON.@stringify(#elemento)).Âªsort();

            let Â·sonIguales = Â·stringArrayUno.@every((#elemento, #indice) =&gt; 
              #elemento === Â·stringArrayDos[#indice]
            );

            console.log(Â·sonIguales ? 
              'âœ… Mismos elementos, tipo y valor' : 
              '/Âº âŒ Elementos diferentes Âº/'
            );
            
          &#125;

          @compararArray(Â·firstArray, Â·secondArray);  
          â‹— /Âº âœ… Mismos elementos, tipo y valor Âº/
        </pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Copia de arrays" codeText="">
      <ChaptrSubSect h4Title="Con el operador" codeText="...spread">
        <p class="chaptrSubSect__p">Para copiar un array <mark>plano</mark> podemos usar el <code>spread</code> operator. Es el recomendado</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·colors = ['red', 'blue', 'green'];
          const Â·copyColors = [...Â·colors];

          console.log(Â·copyColors);
          â‹— /Âº['red', 'blue', 'green']Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Con el mÃ©todo" codeText="Array.from()">
        <p class="chaptrSubSect__p">Para copiar un array <mark>plano</mark>. Aunque es mejor usar el <code>spread</code> operator. Donde brilla realmente es al convertir un <mark>array-like</mark> o <mark>iterable</mark> en un array</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·colors = ['red', 'blue', 'green'];
          const Â·copyColors = Array.from(Â·colors);

          console.log(Â·copyColors);
          â‹— /Âº['red', 'blue', 'green']Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Con el operador" codeText="structuredClone()">
        <p class="chaptrSubSect__p">Para hacer una copia <mark>profunda</mark> y asÃ­ no romper la referencia del original</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·original = ['red', 'blue', 'green', ['purple', 'violet']];
          const Â·copyOriginal = @structuredClone(Â·original);

          console.log(Â·copyOriginal);
          â‹— /Âº['red', 'blue', 'green', ['pink', 'violet']]Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Destructuring de arrays" codeText="">
      <ChaptrSubSect h4Title="AsignaciÃ³n desestructurante" codeText="">
        <p class="chaptrSubSect__p">La asignaciÃ³n desestructurante es una sintaxis especial que nos permite â€œdesempaquetarâ€ arrays u objetos en varias variables, porque a veces es mÃ¡s conveniente</p>
        <pre class="chaptrSubSect__console wScript">
          let Â·family = ['Iker', 'Bego', 'Eder'];
          let [Â·me, Â·mother, Â·son] = Â·family;

          console.log(Â·family);   â‹— /Âº ['Iker', 'Bego', 'Eder'] Âº/

          console.log(Â·me);     â‹— /Âº 'Iker' Âº/
          console.log(Â·mother); â‹— /Âº 'Bego' Âº/
          console.log(Â·son);    â‹— /Âº 'Eder' Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El parÃ¡metro" codeText="...rest">
        <p class="chaptrSubSect__p">En general, si el array es mayor que la lista de la izquierda, los Ã­tems extras son omitidos, si queremos tambiÃ©n obtener todo lo que sigue, podemos agregarle un parÃ¡metro que obtiene â€œel restoâ€ usando puntos suspensivos <code>â€¦</code> con lo que se guardarÃ¡ en la variable <code>rest</code> un array con los valores que "restan"</p>
        <pre class="chaptrSubSect__console wScript">
          let [Â·one, Â·two, ...Â·rest] = [Â¬1, Â¬2, Â¬3, Â¬4, Â¬5];

          console.log(Â·one);  
          â‹— 1
          console.log(Â·two);    
          â‹— 2
          console.log(Â·rest);    
          â‹— /Âº[3, 4, 5]Âº/
          console.log(Â·rest[Â¬2]);    
          â‹— 5</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Valores predeterminados" codeText="">
        <p class="chaptrSubSect__p">Si queremos un valor â€œpredeterminadoâ€ para reemplazar el valor faltante, podemos proporcionarlo utilizando <code>=</code>. Los valores predeterminados pueden ser expresiones mÃ¡s complejas e incluso llamadas a funciÃ³n, que serÃ¡n evaluadas sÃ³lo si el valor no ha sido proporcionado</p>
        <pre class="chaptrSubSect__console wScript">
          function @mostrarId([Â·nombre, Â·apellido = 'Desconocido']) &#123;
            console.log(`/Âº Nombre: $&#123;nombre&#125; | Apellido: $&#123;apellido&#125; Âº/`);
          &#125;

          @mostrarId(['Eder', 'Rodriguez']);
          â‹— /Âº Nombre: Eder | Apellido: Rodriguez Âº/

          @mostrarId(['Iker']);
          â‹— /Âº Nombre: Iker | Apellido: Desconocido Âº/
          
          @mostrarId(['Bego', '']); 
          â‹— /Âº Nombre: Bego | Apellido:  Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_13" nextPage="/lessons/lesson_14"/>
</MainLayout>



<!-- 
&lt;&gt;
&#123;&#125;
()&#123;&#125;
ï¹›ï¹œ    Llaves no estiladas
ï¹•     2 puntos no estilizados
â€¢parametro
Â·variable
#variable en Func/if/for
Ã§Objetos
â‹— âˆResultado
@funcion()
Â¬numbers
objProperty:
ÂºobjProperty
/* comentario */
'/Âº modo texto quita span Âº/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<img class="chaptrSubSect__img" src=`${ruta}img13.webp` alt="captura del evento">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li"></li>
ï¼ƒ
-->