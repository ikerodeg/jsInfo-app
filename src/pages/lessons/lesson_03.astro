---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__03" h2Title="Tipos de datos" slot="mainContent">
    <ChaptrSect h3Title="El tipo" codeText="Number">
      <ChaptrSubSect h4Title="Otras formas de escribir número">
        <p class="chaptrSubSect__p">Agregando la letra <code>e</code> y especificando la cantidad de ceros</p>
        <pre class="chaptrSubSect__console wScript">
          console.log(¬1e9);
          ⋗ 1000000000
  
          console.log(¬1e-¬6);
          ⋗ /º 0.000001 º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Redondeo con" codeText="Math">
        <p class="chaptrSubSect__p">Redondea hacia abajo con <code>Math.floor</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(Math.floor(¬5.¬8));
          ⋗ 5</pre>
        <p class="chaptrSubSect__p">Redondea hacia arriba con <code>Math.ceil</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(Math.ceil(¬5.¬3));
          ⋗ 6</pre>
        <p class="chaptrSubSect__p">Redondea hacia el entero más cercano con <code>Math.round</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(Math.round(-¬5.¬4));
          ⋗ /º -5 º/</pre>
        <p class="chaptrSubSect__p">Quita lo que hay detrás del punto sin redondear con <code>Math.trunc</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(Math.trunc(¬5.¬96674));
          ⋗ 5</pre>
        <p class="chaptrSubSect__p">Redondea a dos dígitos tras el punto</p>
        <pre class="chaptrSubSect__console wScript">
          console.log(¬5.¬895641.toFixed(¬2));
          ⋗ /º 5.90 º/</pre>
        <p class="chaptrSubSect__p">Redondea a "n" digitos y lo convierte en un <span class="bttn">string</span> con <code>toFixed(n)</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(¬5.¬895641.toFixed(¬2));
          ⋗ /º "5.90" º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Verificando si NO es del tipo" codeText="Number">
        <p class="chaptrSubSect__p">Convierte el argumento que se le pasa a tipo <span class="bttn">number</span> con <code>isNaN(arg)</code> y después verifica si <mark><b>NO</b></mark> es <code>NaN</code> y devuelve <span class="bttn">boolean</span></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(isNaN(¬5.¬90));
          ⋗ /º false º/
  
          console.log(isNaN('/º 5.90 º/'));
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Verificando si es un número regular con" codeText="isFinite()">
        <p class="chaptrSubSect__p">Convierte a tipo <span class="bttn">number</span> y devuelve <span class="bttn">boolean</span></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(isFinite('15'));
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="La objeto matemático" codeText="Math">
        <p class="chaptrSubSect__p">Devuelve un número decimal aleatorio entre 0 y 1 con <code>Math.random()</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(Math.random());
          ⋗ /º 0.34622279801161526 º/</pre>
        <p class="chaptrSubSect__p">Devuelve el número mayor de entre los dados con <code>Math.max()</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(Math.ªmax(¬3, ¬5, -¬10, ¬0, ¬1));
          ⋗ 5</pre>
        <p class="chaptrSubSect__p">Devuelve el número mayor de entre los dados con <code>Math.min()</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(Math.ªmin(¬3, ¬5, -¬10, ¬0, ¬1));
          ⋗ 1</pre>
        <p class="chaptrSubSect__p">Devuelve un número elevado a otro con <code>Math.pow()</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log(Math.ªpow(¬2, ¬10));
          ⋗ 1024</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="bigInt">
      <ChaptrSubSect h4Title="Valores enteros mayores que" codeText="253^-1">
        <p class="chaptrSubSect__p">Agregando la letra <code>n</code> al final del número entero</p>
        <pre class="chaptrSubSect__console wScript">
          const ·myBigInt1 = ¬12345678901234567890134567890n;</pre>
        <p class="chaptrSubSect__p">Usando el constructor <code>BigInt</code></p>
        <pre class="chaptrSubSect__console wScript">
          const ·myBigInt2 = BigInt('123456789012345678907890n');</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="Infinity">
      <ChaptrSubSect h4Title="Cómo obtenerlo">
        <p class="chaptrSubSect__p">Podemos obtenerlo como resultado de la división por cero o hacemos referencia a él directamente</p>
        <pre class="chaptrSubSect__console wScript">
          console.log(¬1 / ¬0);
          ⋗ /º Infinity º/
  
          console.log(Infinity);
          ⋗ /º Infinity º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="NaN">
      <ChaptrSubSect h4Title="Cómo obtenerlo">
        <p class="chaptrSubSect__p">Es la represantación de un error de cálculo, es el resultado de una operación matemática incorrecta o indefinida</p>
        <pre class="chaptrSubSect__console wScript">
          console.log(¬1 / 'cero');
          ⋗ /º NaN º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="String">
      <ChaptrSubSect h4Title="Tipos de comillas">
        <p class="chaptrSubSect__p">Comillas simples</p>
        <pre class="chaptrSubSect__console wScript">
          let ·single = 'comillas simples';</pre>
        <p class="chaptrSubSect__p">Comillas dobles</p>
        <pre class="chaptrSubSect__console wScript">
          let ·dobles = '"comillas dobles"';</pre>
        <p class="chaptrSubSect__p">Comillas backticks</p>
        <pre class="chaptrSubSect__console wScript">
          let ·backticks = `comillas backticks`;</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Otros caracteres especiales">
        <p class="chaptrSubSect__p">El caracter de escape <code>\</code></p>
        <pre class="chaptrSubSect__console wScript">
          console.log('El nene se llama \'Eder\' ');
          ⋗ El nene se llama "Eder"
  
          console.log('El caracter de escape \\');
          ⋗ El caracter de escape \
  
          console.log('Hola \t Iker');
          ⋗ Hola   Iker
  
          console.log('Hola \n Iker');
          ⋗ Hola
              Iker
  
          console.log('\x7A');
          ⋗ z
  
          console.log('\u&#123;1F60D&#125;');
          ⋗ 😍</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Métodos de" codeText="String">
      <ChaptrSubSect h4Title="El método" codeText=".startsWith()" hint="#empiezaPor #returnBoolean">
        <p class="chaptrSubSect__p">Determina si una cadena de texto comienza con los caracteres de otra cadena especificada, devolviendo <code>true</code> o <code>false</code></p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Me llamo Iker';
          console.log(·myString.startsWith('Me'));
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".endsWith()" hint="#terminaEn #returnBoolean">
        <p class="chaptrSubSect__p">Determina si una cadena de texto termina con los caracteres de otra cadena especificada, devolviendo <code>true</code> o <code>false</code></p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Me llamo Iker';
          console.log(·myString.endsWith('Iker'));
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".includes()" hint="#contiene #returnBoolean">
        <p class="chaptrSubSect__p">Determina si una cadena de texto contiene otra cadena especificada, devolviendo <code>true</code> o <code>false</code></p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Se llama Éder';
          console.log(·myString.ªincludes('Éder'));
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".repeat()" hint="#repiteCadenaXveces #returnCadena">
        <p class="chaptrSubSect__p">Es usado para repetir una cadena de texto un número específico de veces. Devuelve una cadena que contiene las copias especificadas de la cadena original</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Eder';
          console.log(·myString.ªrepeat(¬3));
          ⋗ /º 'EderEderEder' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".split()" hint="#divideCadenaEnArray #conSeparador">
        <p class="chaptrSubSect__p">Divide una cadena de texto en un <mark>array</mark> de subcadenas, basandose en un separador definido. Este separador puede ser una cadena de texto, un carácter o una expresión regular</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Hola mi nombre es Eder.';
          console.log(·myString.ªsplit(' '));
          ⋗ /º ['Hola', 'mi', 'nombre', 'es', 'Eder'] º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".slice()" hint="#extraeSecciónCadena #returnCadena">
        <p class="chaptrSubSect__p">Se utiliza para extraer una sección de una cadena de texto y devuelve una nueva cadena de texto. No modifica la cadena original</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Hola mi nombre es Eder.';
          console.log(·myString.ªslice(¬14, ¬18));
          ⋗ /º 'Eder' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".indexOf()" hint="#buscaPrimeraCoincidencia #returnIndice">
        <p class="chaptrSubSect__p">Se utiliza para buscar la primera aparición de un substring específico dentro de una cadena y devuelve el índice de esa primera aparición</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'dos ojos tres tigres cuatro dedos';
          console.log(·myString.ªindexOf('tres'));
          ⋗ 9</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".lastIndexOf()" hint="#buscaUltimaCoincidencia #returnIndice">
        <p class="chaptrSubSect__p">Se utiliza para obtener la posición de la última ocurrencia de un valor específico en una cadena de texto</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'dos ojos tres tigres tres dedos';
          console.log(·myString.ªlastIndexOf('tres'));
          ⋗ 21</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".substring()" hint="#extraeSubcadenaIndices">
        <p class="chaptrSubSect__p">Se utiliza para extraer una subcadena de una cadena existente. La subcadena se crea a partir de los índices proporcionados como argumentos al método y se devuelve como una nueva cadena</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'dos ojos tres tigres tres dedos';
          console.log(·myString.ªsubstring(¬9, ¬20));
          ⋗ /º 'tres tigres' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".at()" hint="#accedeElementoPorIndice">
        <p class="chaptrSubSect__p">Accede a un elemento específico en una cadena basado en su índice. Permite el uso de índices negativos, puede acceder a elementos desde el final</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Mi nombre es Eder';
          console.log(·myString.ªat(¬13));
          ⋗ /º 'E' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".match()" hint="#buscaPorRegex #returnArrayCoincidencias">
        <p class="chaptrSubSect__p">Se utiliza para buscar una coincidencia entre una cadena y una expresión regular. Este método <mark>devuelve un array</mark> que contiene todas las coincidencias encontradas</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'tres uno tres dos tres cuatro';
          console.log(·myString.ªmatch(/tres/gi));
          ⋗ /º ['tres', 'tres', 'tres'] º/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">El indicador <code>g</code> (de "global") se utiliza para buscar todas las coincidencias en lugar de detenerse en la primera. Si no se utiliza, el método <code>match()</code>  solo devuelve la primera coincidencia encontrada.</li>
          <li class="chaptrSubSectUl__li">El indicador <code>i</code> (de "insensitive") hace que la búsqueda de coincidencias sea insensible a mayúsculas y minúsculas, lo que significa que no diferencia entre letras mayúsculas y minúsculas. Si no se utiliza, la búsqueda será sensible a mayúsculas y minúsculas.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".matchAll()" hint="#returnIteradorCoincidencias #coincidenciaEsObjeto">
        <p class="chaptrSubSect__p">Se utiliza para obtener un <mark>iterador</mark> que contiene todas las coincidencias de una expresión regular en una cadena de texto. Cada coincidencia es un objeto que proporciona información detallada sobre la coincidencia, como el texto coincidente y las capturas de grupos</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Yo tengo 48 años y Eder 4';
          let ·patron = /º /\d+/g; º/
          const ·resultado = ·myString.ªmatchAll(·patron);
  
          Array.from(·resultado).forEach(#elem =&gt; console.log(#elem[¬0]));
          ⋗ /º '48' º/
          ⋗ /º '4' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".replaceAll()" hint="#reemplazaCoincidenciaConCadena">
        <p class="chaptrSubSect__p">Se utiliza para reemplazar todas las apariciones de un substring o una expresión regular en una cadena de texto con otro substring. Este método no modifica la cadena original</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Soy Iker, viva Iker';
          let ·patron = 'Iker';
          let ·reemplazo = 'Eder';
  
          console.log(·myString.replaceAll(·patron, ·reemplazo));
          ⋗ /º 'Soy Eder, viva Eder' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".trim()" hint="#eliminaEspaciosBlancoInicioFin">
        <p class="chaptrSubSect__p">Es usado para eliminar los espacios en blanco al inicio y al final de un string.<mark>No modifica</mark> el string original, devuelve una nueva cadena</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = ' Hola soy Eder ';
          let ·result = ·myString.ªtrim();

          console.log(·result);
          ⋗ /º 'Hola soy Eder' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".trimStart()" hint="#eliminaEspaciosBlancoInicio">
        <p class="chaptrSubSect__p">Se utiliza para eliminar los espacios en blanco al inicio de una cadena de texto</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = ' Hola soy Eder';
          let ·result = ·myString.ªtrimStart();

          console.log(·result);
          ⋗ /º 'Hola soy Eder' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".trimEnd()" hint="#eliminaEspaciosBlancoFinal">
        <p class="chaptrSubSect__p">Se utiliza para eliminar los espacios en blanco al final de una cadena de texto</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Hola soy Eder ';
          let ·result = ·myString.ªtrimEnd();

          console.log(·result);
          ⋗ /º 'Hola soy Eder' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".padStart()" hint="#insertaCadenaEnCadenaLongitudDada">
        <p class="chaptrSubSect__p">Se utiliza para rellenar una cadena con otra cadena (una o más veces, si es necesario) hasta que la cadena resultante alcance una longitud especificada. El relleno se aplica desde el principio de la cadena actual</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Eder';

          console.log(·myString.ªpadStart(¬15, 'Hola q ase'));
          ⋗ /º 'Hola q ase Eder' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".padEnd()" hint="insertaCadenaEnCadenaLongitudDada">
        <p class="chaptrSubSect__p">Se utiliza para rellenar una cadena con otra cadena (una o más veces, si es necesario) hasta que la cadena resultante alcance una longitud especificada. El relleno se aplica desde el final de la cadena actual</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Eder';

          console.log(·myString.ªpadEnd(¬14, '😸'));
          ⋗ /º 'Eder😸😸😸😸😸' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".codePointAt()" hint="#returnValorUnicodePosición">
        <p class="chaptrSubSect__p">Devuelve un número entero no negativo que representa el valor de punto de código Unicode del carácter en la posición especificada en una cadena</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Eder';

          console.log(·myString.codePointAt(¬0));
          ⋗ 100</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".fromCodePoint()" hint="#convierteUnicodeToCadena">
        <p class="chaptrSubSect__p">Convierte una secuencia de puntos de código Unicode en una cadena de texto. Este método es estático, lo que significa que se llama en el constructor de la clase String</p>
        <pre class="chaptrSubSect__console wScript">
          console.log(çString.ªfromCodePoint(¬0x1F300));
          ⋗ '🌀'</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".concat()" hint="#returnNuevaCadenaDeCadenasUnidas">
        <p class="chaptrSubSect__p">Se utiliza para unir dos o más cadenas de texto sin cambiar las cadenas originales y devuelve una nueva cadena de texto</p>
        <pre class="chaptrSubSect__console wScript">
          let ·name1 = 'Eder';
          let ·name2 = 'Iker';

          console.log(·name1.ªconcat(`/º , $&#123;name2&#125; º/`));
          ⋗ /º 'Eder, Iker' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".search()" hint="#returnIndicePrimeraCoincidenciaCadenaEnCadena">
        <p class="chaptrSubSect__p">Se utiliza para buscar una coincidencia entre una expresión regular y la cadena de texto desde la que se llama. Este método devuelve el índice de la primera coincidencia que encuentra</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Hola me llamo Eder y, /º ¿tu? º/';

          console.log(·myString.ªsearch('Eder');
          ⋗ 14</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".charAt()" hint="#returnCaracterCadenaPorIndice">
        <p class="chaptrSubSect__p">Devuelve un carácter de una cadena de texto en una posición específica. Los caracteres se indexan desde la izquierda hacia la derecha, comenzando con 0</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Hola me llamo Eder y, /º ¿tu? º/';

          console.log(·myString.ªcharAt(¬14);
          ⋗ /º 'E' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".charCodeAt()" hint="#returnCódigoUTFPorIndice">
        <p class="chaptrSubSect__p">Devuelve un entero entre 0 y 65535 que representa la unidad de código UTF-16 en el índice proporcionado. Este método se utiliza para obtener el valor Unicode de un carácter en una cadena de texto</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Hola me llamo Eder y, /º ¿tu? º/';

          console.log(·myString.ªcharCodeAt(¬14);
          69</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".toLowerCase()" hint="#convierteCadenaAMinúsculas">
        <p class="chaptrSubSect__p">Convierte todos los caracteres de una cadena a minúsculas</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'OLA Q ASE';

          console.log(·myString.toLowerCase();
          ⋗ /º 'ola q ase' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".toUpperCase()" hint="#convierteCadenaAMayúsculas">
        <p class="chaptrSubSect__p">Convierte todos los caracteres de una cadena a mayúsculas</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'ola q ase';

          console.log(·myString.toUpperCase();
          ⋗ /º 'OLA Q ASE' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".localeCompare()" hint="#comparaOrdenCaracteresCadenas #retornaNúmero">
        <p class="chaptrSubSect__p">Compara la cadena de texto actual con otra cadena de texto y devuelve un número que indica si la cadena de texto actual va antes, después o es igual a la cadena de texto de comparación en el orden alfabético</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString1 = 'manzana';
          let ·myString2 = 'Manzana';

          console.log(·myString1.localeCompare(·myString2);
          ⋗ /º -1 º/</pre>
          <ul class="chaptrSubSect__ul">
            <li class="chaptrSubSectUl__li"><strong>Retorno Negativo:</strong> <code>myString1</code> está antes que <code>myString2</code></li>
            <li class="chaptrSubSectUl__li"><strong>Retorno Cero:</strong> son equivalentes en orden</li>
            <li class="chaptrSubSectUl__li"><strong>Retorno Positivo:</strong> <code>myString1</code> está después que <code>myString2</code></li>
          </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".valueOf()" hint="#returnValorPrimitivoCadena">
        <p class="chaptrSubSect__p">Se utiliza para obtener el valor primitivo de un objeto de cadena. No toma ningún parámetro y devuelve la cadena en sí</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = new @String('ola q ase');

          console.log(·myString.valueOf());
          ⋗ /º 'ola q ase' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText=".length()" hint="#returnNumeroCaracteresEnCadena">
        <p class="chaptrSubSect__p">Devuelve el número de caracteres en una cadena de texto</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Hola me llamo Eder';

          console.log(·myString.length);
          ⋗ 18</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El método" codeText="[pos]" hint="#accedeCaracterConIndice">
        <p class="chaptrSubSect__p">Para acceder a un carácter, se puede usar paréntesis cuadrados <code>[pos]</code> . Este método es el recomendado en vez de <code>.charAt()</code></p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Hola me llamo Eder';

          console.log(·myString[¬0]);
          ⋗ /º 'H' º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Iteración sobre" codeText="String">
      <ChaptrSubSect h4Title="El bucle" codeText="for...">
        <p class="chaptrSubSect__p">El clásico de siempre</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Eder';
  
          for (let #i = ¬0; #i &lt; ·myString.length; #i++)&#123;
            console.log(·myString[#i]);
          &#125;
          
          ⋗ /º 'E' º/
          ⋗ /º 'd' º/
          ⋗ /º 'e' º/
          ⋗ /º 'r' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El bucle" codeText="for...of" hint="*recomendado">
        <p class="chaptrSubSect__p">Fácil y sencillo de usar, uno de los recomendados</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Eder';
  
          for (let #char of ·myString)&#123;
            console.log(#char);
          &#125;

          ⋗ /º 'E' º/
          ⋗ /º 'd' º/
          ⋗ /º 'e' º/
          ⋗ /º 'r' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El bucle" codeText="for...in">
        <p class="chaptrSubSect__p">Este bucle está diseñado para iterar sobre los nombres de las propiedades de un objeto. En el caso de una cadena, itera sobre los índices de los caracteres (que son las propiedades de la cadena)</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Eder';
  
          for (let #char •in ·myString)&#123;
            console.log(·myString[#char]);
          &#125;

          ⋗ /º 'E' º/
          ⋗ /º 'd' º/
          ⋗ /º 'e' º/
          ⋗ /º 'r' º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El bucle" codeText="while">
        <p class="chaptrSubSect__p">Fácil y sencillo de usar, y muy eficiente</p>
        <pre class="chaptrSubSect__console wScript">
          let ·myString = 'Eder';
          let ·char = ¬0;
  
          while (·char &lt; ·myString.length)&#123;
            console.log(·myString[·char]);
            ·char++;
          &#125;

          ⋗ /º 'E' º/
          ⋗ /º 'd' º/
          ⋗ /º 'e' º/
          ⋗ /º 'r' º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="Boolean">
      <ChaptrSubSect h4Title="Sus valores">
        <p class="chaptrSubSect__p">El tipo booleano también llamado lógico, tiene sólo dos valores: <code>true</code> o <code>false</code></p>
        <pre class="chaptrSubSect__console wScript">
          let ·thisIsTrue = true;
  
          let ·thisIsFalse = false;</pre>
        <p class="chaptrSubSect__p">Los valores booleanos también son el resultado de comparaciones</p>
        <pre class="chaptrSubSect__console wScript">
          let ·esMayor = ¬4 &gt; ¬1;
  
          console.log(·esMayor);
          ⋗ /º true º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="null">
      <ChaptrSubSect h4Title="El valor que representa 'nada'">
        <p class="chaptrSubSect__p">No pertenece a ninguno de los tipos descritos anteriormente. En JavaScript, <code>null</code> no es una “referencia a un objeto inexistente” o un “puntero nulo” como en otros lenguajes. Es sólo un valor especial que representa “nada”, “vacío” o “valor desconocido”. Este valor es intencional 100%</p>
        <pre class="chaptrSubSect__console wScript">
          let ·valorVacio = null;
  
          console.log(·valorVacio);
          ⋗ /º null º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="undefined">
      <ChaptrSubSect h4Title="Un tipo 'propio'">
        <p class="chaptrSubSect__p">El valor especial <code>undefined</code> también se distingue hacia un tipo propio, igual que <code>null</code>. El significado de <code>undefined</code> es “valor no asignado”. Si una variable es declarada pero no asignada, entonces su valor es <code>undefined</code></p>
        <pre class="chaptrSubSect__console wScript">
          let ·edad;
  
          console.log(·edad);
          ⋗ /º undefined º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="Object">
      <ChaptrSubSect h4Title="Un tipo 'especial'">
        <p class="chaptrSubSect__p">El tipo <code>object</code> (objeto) es especial. Todos los demás tipos se llaman “primitivos” porque sus valores pueden contener una sola cosa (ya sea una cadena, un número o lo que sea). Por el contrario, los objetos se utilizan para almacenar colecciones de datos y entidades más complejas</p>
        <pre class="chaptrSubSect__console wScript">
          let ·user = &#123;
            name: 'Eder',
            age: ¬4
          &#125;;</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El tipo" codeText="Symbol">
      <ChaptrSubSect h4Title="Un identificador único">
        <p class="chaptrSubSect__p">El tipo <code>Symbol</code> (símbolo) son únicos e inmutableslo que significa que cada símbolo es distinto de otro, incluso si tienen la misma descripción. Los símbolos se utilizan comúnmente como claves de propiedades de objetos para evitar conflictos con otras claves. Tenemos que mencionarlo aquí para una mayor integridad, pero es mejor estudiar este tipo después de los objetos</p>
        <pre class="chaptrSubSect__console wScript">
          let ·mySymbol = @Symbol('descripcion opcional');</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="El operador" codeText="typeof">
      <ChaptrSubSect h4Title="Determinando el tipo">
        <p class="chaptrSubSect__p">Se utiliza para determinar el tipo de un valor o expresión. Es un operador unario, lo que significa que se aplica a un único operando, y devuelve un <code>String</code> que indica el tipo del operando. Soporta 2 tipos de sintaxis</p>
        <pre class="chaptrSubSect__console wScript">
          const ·myVariable = ¬9;

          /* Como operador */
          console.log(typeof ·myVariable);
          ⋗ /º 'number' º/

          /* Como funcion */
          console.log(typeof(·myVariable));
          ⋗ /º 'number' º/
          </pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
  <Footer slot="mainFooter" prevPage="/lessons/lesson_02" nextPage="/lessons/lesson_04"/>
</MainLayout>


<!-- 
&lt;&gt;
&#123;&#125;
()&#123;&#125;
﹛﹜    Llaves no estiladas
﹕     2 puntos no estilizados
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ ∞Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<img class="chaptrSubSect__img" src=`${ruta}img13.webp` alt="captura del evento">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li"></li>
＃
-->