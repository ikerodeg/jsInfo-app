---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__28" h2Title="Async/await" slot="mainContent">
    <ChaptrSect h3Title="Async/await" codeText="">
      <ChaptrSubSect h4Title="Definición" codeText="">
        <p class="chaptrSubSect__p">Con <code>async/await</code>, trabajamos con promesas, pero sin usar <code>.then()</code> y <code>.catch()</code> como métodos, sino a través de una estructura más clara y ordenada</p>
        <p class="chaptrSubSect__p"><code>async</code> se coloca antes de una función para convertirla en una función asíncrona, que permite usar <code>await</code> dentro de ella</p>
        <p class="chaptrSubSect__p"><code>await</code> hace que el código "espere" a que la promesa se resuelva (o rechace) antes de seguir</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Creación" codeText="Async">
        <p class="chaptrSubSect__p"><code>Async</code> se ubica delante de una función y significa solamente una cosa: que <b>la función siempre devolverá una promesa</b>. Otros valores serán envueltos y resueltos en una promesa automáticamente. Vamos a crear una función con <code>async</code> que devuelva una promesa</p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Si se devuelve un valor normal en async º/*/
          async function @saludar1() &#123;
            return `/º Hola! º/`;
          &#125;;

          /* Si necesitamos controlar la ejecucion asyncrona manualmente */
          async function @saludar2() &#123;
            return new çPromise((#resolve) =&gt; &#123;
              @setTimeout(() =&gt; @resolve(`/º Hola después de 1seg! º/`), ¬1000);
            &#125;);
          &#125;

          /*/º setTimeout, timers, listeners, fetch, necesitan ser envueltos en una promesa º/*/
        
          @saludar1().then((#valorResolve) =&gt; &#123;
            console.log(#valorResolve);
          &#125;);

          @saludar2().then((#valorResolve) =&gt; &#123;
            console.log(#valorResolve);
          &#125;);
          ⋗ /º Hola! º/
          ⋗ /º Hola después de 1seg! º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Consumo" codeText="await">
        <p class="chaptrSubSect__p"><code>await</code> solo trabaja dentro de funciones <code>async</code> y hace que JavaScript espere hasta que la promesa responda y devuelve su resultado. Recordemos el ejemplo pasado en el que se consumía la promesa con <code>.then()</code> y ahora vamos a consumir la promesa con <code>await</code></p>
        <pre class="chaptrSubSect__console wScript">
          async function @saludar2() &#123;
            return new çPromise((#resolve) =&gt; &#123;
              @setTimeout(() =&gt; @resolve(`/º Hola después de 1seg! º/`), ¬1000);
            &#125;);
          &#125;

          async function @ejecutaSaludo() &#123;
            let ·valorResolve = @await @saludar2();
            console.log(`/º $&#123;valorResolve&#125; º/`);
          &#125;

          @ejecutaSaludo();
          ⋗ /º Hola después de 1seg! º/</pre>
          <p class="chaptrSubSect__p">Vamos a ver un ejemplo encadenando varias operaciones usando <code>await</code> vs <code>.then()</code> para ver la diferencia en legibilidad</p>
          <pre class="chaptrSubSect__console wScript">
          /*/º Usando .then() º/*/
          function @multiplyBy2(#number) &#123;
            return new çPromise((#resolve) =&gt; &#123;
              @setTimeout(() =&gt; @resolve(#number * ¬2), ¬1000);
            &#125;);
          &#125;;

          @multiplyBy2(¬8)
            .then((·result) =&gt; &#123;
              console.log(`/º Resultado x2: $&#123;·result&#125; º/`);
              return @multiplyBy2(·result);
            &#125;)
            .then((·result) =&gt; &#123;
              console.log(`/º Resultado x4: $&#123;·result&#125; º/`);
              return @multiplyBy2(·result);
            &#125;)
            .then((·result) =&gt; &#123;
              console.log(`/º Resultado x8: $&#123;·result&#125; º/`);
            &#125;);
          ⋗ /º Resultado x2: 16 º/
          ⋗ /º Resultado x4: 32 º/
          ⋗ /º Resultado x8: 64 º/

          /*/º Usando async/await º/*/
          async function @multiplyBy2(#number) &#123;
            return new çPromise((#resolve) =&gt; &#123;
              @setTimeout(() =&gt; @resolve(#number * ¬2), ¬1000);
            &#125;);
          &#125;;

          async function @ejecutaMultiplicacion(#number) &#123;
            let ·result = @await @multiplyBy2(#number);
            console.log(`/º Resultado x2: $&#123;·result&#125; º/`);
            ·result = @await @multiplyBy2(·result);
            console.log(`/º Resultado x4: $&#123;·result&#125; º/`);
            ·result = @await @multiplyBy2(·result);
            console.log(`/º Resultado x8: $&#123;·result&#125; º/`);
          &#125;

          @ejecutaMultiplicacion(¬8);
          ⋗ /º Resultado x2: 16 º/
          ⋗ /º Resultado x4: 32 º/
          ⋗ /º Resultado x8: 64 º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Manejo de errores" codeText="try..catch">
        <p class="chaptrSubSect__p"><code>await</code> solo trabaja dentro de funciones <code>async</code> y hace que JavaScript espere hasta que la promesa responda y devuelve su resultado. Recordemos el ejemplo pasado en el que se consumía la promesa con <code>.then()</code></p>
        <pre class="chaptrSubSect__console wScript">
          async function @multiplyBy2(#number) &#123;
            return new @Promise((#resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                @resolve(#number * ¬2)
              &#125;, ¬1000);
            &#125;);
          &#125;;

          async function @ejecutaMultiplicacion(#number) &#123;
            try&#123;
              let ·result = await @multiplyBy2(#number);
              console.log(`/º Resultado x2: $&#123;·result&#125; º/`);

              ·result = await @multiplyBy2(·result);
              console.log(`/º Resultado x4: $&#123;·result&#125; º/`);

              ·result = await @multiplyBy2(·result);
              console.log(`/º Resultado x8: $&#123;·result&#125; º/`);
              
            &#125; catch(#error)&#123;
              console.ªerror(çerror)
            &#125;
          &#125;

          @ejecutaMultiplicacion(¬8);
          ⋗ /º Resultado x2: 16 º/
          ⋗ /º Resultado x4: 32 º/
          ⋗ /º Resultado x8: 64 º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_27" nextPage="/lessons/lesson_24"/>
</MainLayout>

<!-- 
&lt;&gt;          < > no estilados
()&#123;&#125;    ( ) { } no estilados
﹛﹜              { } Llaves no estilados
﹕                : 2 puntos no estilados
＃                # Rejilla no estilada

ªmétodos
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">

-->
