---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__27" h2Title="Promesas" slot="mainContent">
    <ChaptrSect h3Title="Las Promesas" codeText="">
      <ChaptrSubSect h4Title="DefiniciÃ³n" codeText="">
        <p class="chaptrSubSect__p">Una <span class="bttn">promesa</span> es algo que representa un valor que no estÃ¡ disponible inmediatamente, pero que lo estarÃ¡ en el futuro. Piensa en una promesa como algo que puede cumplirse o fallar, pero que aÃºn no sabes cuÃ¡l serÃ¡ el resultado. En la vida real, serÃ­a como hacer un pedido de comida: no tienes la comida ahora, pero la tendrÃ¡s despuÃ©s (eso sÃ­, podrÃ­a haber un retraso o incluso no llegar).</p>
        <p class="chaptrSubSect__p">Estados de una promesa</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>Pending</strong> cuando la promesa se ha creado, pero aÃºn no se ha resuelto. Como cuando haces el pedido de comida.</li>
          <li class="chaptrSubSectUl__li"><strong>Fulfilled</strong> cuando todo sale bien y obtienes el valor esperado. Como cuando recibes tu comida.</li>
          <li class="chaptrSubSectUl__li"><strong>Rejected</strong> cuando algo saliÃ³ mal y no obtienes el valor esperado. Como cuando te llaman y te dicen que no pueden entregarte la comida.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="CreaciÃ³n con" codeText="new Promise()">
        <p class="chaptrSubSect__p">Para crear una promesa, usamos el constructor <code>new Promise()</code>. Este constructor necesita que se le pase una funciÃ³n (llamada <span class="bttn">executor</span>) que contiene dos <span class="bttn">callbacks</span> como parÃ¡metros</p>
        <p class="chaptrSubSect__p">Cuando creamos la promesa con <code>new Promise()</code> el <span class="bttn">executor</span> corre inmediatamente</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·miPromesa = new @Promise( function @executor( function @siTodoOk, function @siAlgoFalla ) &#123; 
            /* AquÃ­ va el cÃ³digo asÃ­ncrono */
          &#125;);</pre>
        <p class="chaptrSubSect__p">Los <span class="bttn">callback</span> pasados como argumento al <span class="bttn">executor</span> se llaman por convenciÃ³n <code>resolve</code> y <code>reject</code> y se usa la notaciÃ³n de arrow function</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·miPromesa = new @Promise((â€¢resolve, â€¢reject) =&gt; &#123; 
            /* AquÃ­ va el cÃ³digo asÃ­ncrono */
          &#125;);</pre>
        <p class="chaptrSubSect__p">Cuando el <span class="bttn">executor</span> obtiene el resultado (da igual cuando) debe llamar a una de estas dos <span class="bttn">callback</span></p>
        <p class="chaptrSubSect__p">Que son <code>resolve</code> y <code>reject</code>?</p>
        <p class="chaptrSubSect__p"><code>resolve</code> es una funciÃ³n que se llama cuando la tarea asincrÃ³nica se completa con Ã©xito. Su propÃ³sito es "cumplir" la promesa y enviar un valor de Ã©xito, "Todo saliÃ³ bien, aquÃ­ tienes el resultado"</p>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          const Â·miPromesa = new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;   /* â€ */
            @resolve(Â·value); /* â */
          &#125;);</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>â€</strong>: El "executor" <code>() =&gt; &#123;&#125;</code> ejecuta inmediatamente el bloque de cÃ³digo de su interior.</li>
          <li class="chaptrSubSectUl__li"><strong>â</strong>: Cuando se llama a <code>resolve</code> el valor que pasamos entre parÃ©ntesis serÃ¡ el valor que devolverÃ¡ la promesa.</li>
          <li class="chaptrSubSectUl__li"><strong>â‚</strong>: Cambia el estado de la promesa a <code>fullfilled</code>.</li>
        </ul>
        <p class="chaptrSubSect__p"><code>reject</code> (o su nombre descriptivo) es una funciÃ³n que se llama cuando la tarea asincrÃ³nica falla. Su propÃ³sito es "rechazar" la promesa y enviar un mensaje o razÃ³n del fallo, "Algo saliÃ³ mal, no puedo cumplir la promesa".</p>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          const Â·miPromesa = new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;   /* â€ */
              @reject( new Error('/Âº Oooops! Âº/') );  /* â */
            &#125;;</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>â€</strong>: El "executor" <code>() =&gt; &#123;&#125;</code> ejecuta automÃ¡ticamente el bloque de cÃ³digo de su interior.</li>
          <li class="chaptrSubSectUl__li"><strong>â</strong>: Si ocurre un error se llama a "reject" con el objeto Error. El valor de la promesa es el string "Oooops!".</li>
          <li class="chaptrSubSectUl__li"><strong>â‚</strong>: Cambia el estado de la promesa a <code>rejected</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Entonces el executor en algun momento pasa la <span class="bttn">promise</span> a uno de estos dos estados</p>
        <pre class="chaptrSubSect__console wScript">
                                                                         state: 'fullfilled'
                                                  @resolve(Ã§value) =&gt;  result: Ã§value
            state: 'pending'
            result: undefined
                                                  @reject(Ã§error) =&gt;   state: 'rejected'
                                                                        result: Ã§error</pre>
        <p class="chaptrSubSect__p">Entonces, esta serÃ­a una versiÃ³n completa, simulando un cÃ³digo asÃ­ncrono</p>
        <pre class="chaptrSubSect__console wScript">
          console.log('/Âº 1. Creando la promesa Âº/');

          let Â·miPromesa = new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;
            console.log('/Âº 2. Iniciando tarea asÃ­ncrona Âº/');

            @setTimeout(() =&gt; &#123;
              let Â·todoBien = true;  /* /Âº Cambia a false para ver el rechazo Âº/ */

              if (Â·todoBien) &#123;
                @resolve('/Âº 3. âœ” La tarea se completÃ³ con Ã©xito. Âº/');
              &#125; else &#123;
                @reject( new Error('/Âº 3. Oooops! Algo fallÃ³. Âº/') );
              &#125;

            &#125;, Â¬1500);
          &#125;);

          console.log('/Âº 4. Ejecucion de promesa terminada, esperando resultado Âº/');

          â‹— /Âº 1. Creando la promesa Âº/
          â‹— /Âº 2. Iniciando tarea asÃ­ncrona Âº/
          â‹— /Âº 4. Ejecucion de promesa terminada, esperando resultado Âº/
          â‹— /Âº 3. âœ” La tarea se completÃ³ con Ã©xito. Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Consumidores" codeText="then, catch, finally">
        <p class="chaptrSubSect__p">Aprender <span class="bttn">Promesas</span> no es tanto el aprender a crearlas, sino a manejar su resultado. Esto nos servirÃ¡ mas adelante para saber manejar el resultado por ejemplo de <code>fetch</code> que devuelve una promesa</p>
        <p class="chaptrSubSect__p">Un objeto <code>Promise</code> sirve como enlace entre el <span class="bttn">executor</span> y las <strong>funciones consumidoras</strong>, que recibirÃ¡n un resultado o un error. Las <strong>funciones consumidoras</strong> son las que manejan el resultado que el <span class="bttn">executor</span> entrega a travÃ©s de <code>resolve</code> o <code>reject</code>, utilizando los mÃ©todos <code>.then</code> y <code>.catch</code></p>
        <p class="chaptrSubSect__p">El mÃ¡s importante es <code>.then</code></p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          Ã§myPromise.then(
            @function(â€¢onFulfilled?) &#123; /* Maneja resultado exitoso */ &#125;,
            @function(â€¢onRejected?) &#123; /* Maneja error */ &#125;
          );
        
          /* Con arrow functions */
          Ã§myPromise.then(â€¢onFulfilled?, â€¢onRejected?);</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">El primer argumento de <code>.then</code> es una <mark>funciÃ³n</mark> que se ejecuta cuando se resuelve la promesa y recibe el resultado.</li>
          <li class="chaptrSubSectUl__li">El segundo argumento de <code>.then</code> es una <mark>funciÃ³n</mark> que se ejecuta cuando se rechaza la promesa y recibe el error, aunque <mark>no es recomendable</mark> es mejor usar <code>.catch()</code>.</li>
          <li class="chaptrSubSectUl__li"><code>result</code> devuelve el mismo valor que se le pasa a <code>resolve</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Veamos un ejemplo completo</p>
        <pre class="chaptrSubSect__console wScript">
          console.log('/Âº 1. Creando la promesa Âº/');

          let Â·verificarPago = new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;
            console.log('/Âº 2. Verificando estado del pago Âº/');

            @setTimeout(() =&gt; &#123;
              let Â·pagoExitoso = true;  /* /Âº Cambia a false para ver el rechazo Âº/ */

              if (Â·pagoExitoso) &#123;
                @resolve('/Âº 3. âœ” El pago fue exitoso. Âº/');
              &#125; else &#123;
                console.log('/Âº 3. Algo fallÃ³... Âº/');
              &#125;
              
            &#125;, Â¬2000);
          &#125;);

          console.log('/Âº 4. Promesa finalizada Âº/');
        
          Â·verificarPago
            .then((â€¢value) =&gt; &#123;     /* value es el valor pasado a resolve */
              console.log(`/Âº 5. Resultado: $&#123;â€¢value&#125; Âº/`);
          &#125;);

          console.log('/Âº 6. Fin del script Âº/');

          â‹— /Âº 1. Creando la promesa Âº/
          â‹— /Âº 2. Verificando estado del pago Âº/
          â‹— /Âº 4. Promesa finalizada Âº/
          â‹— /Âº 6. Fin del script Âº/
          â‹— /Âº 5. Resultado: 3. âœ” El pago fue exitoso. Âº/</pre>
        <p class="chaptrSubSect__p">DespuÃ©s tenemos <code>.catch</code>. Si la promesa es rechazada, (si <code>reject()</code> es llamado), el bloque <code>.catch()</code> se activa e intercepta y maneja el error</p>
        <pre class="chaptrSubSect__console wScript">
          console.log('/Âº 1. Creando la promesa Âº/');

          let Â·verificarPago = new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;
            console.log('/Âº 2. Verificando estado del pago Âº/');

            @setTimeout(() =&gt; &#123;
              let Â·pagoExitoso = false;  /* /Âº Cambia a false para ver el rechazo Âº/ */

              if (Â·pagoExitoso) &#123;
                @resolve('/Âº 3. âœ” El pago fue exitoso. Âº/');
              &#125; else &#123;
                console.log('/Âº 3. Algo fallÃ³! Âº/');
              &#125;
              
            &#125;, Â¬2000);
          &#125;);

          console.log('/Âº 4. Promesa finalizada Âº/');
        
          Â·verificarPago
            .then((â€¢value) =&gt; &#123;     /* value es el valor pasado a resolve */
              console.log(`/Âº 5. Resultado: $&#123;â€¢value&#125; Âº/`);
          &#125;)
            .catch((â€¢error) =&gt; &#123;    /* error es el valor pasado a reject */
              console.@error(â€¢error.â€¢message);  /* Accedemos al mensaje de error */
          &#125;);

          console.log('/Âº 6. Fin del script Âº/');
        
          â‹— /Âº 1. Creando la promesa Âº/
          â‹— /Âº 2. Verificando estado del pago Âº/
          â‹— /Âº 4. Promesa finalizada Âº/
          â‹— /Âº 6. Fin del script Âº/
          â‹— /Âº 5. Resultado: 3. âœ” Algo fallÃ³! Âº/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">El argumento que recibe <code>.catch()</code> <mark>es el valor que se pasa a</mark> <code>reject()</code>, que en este caso es un objeto <code>Error</code>. El mÃ©todo <code>error.message</code> accede al mensaje <i>"Algo fallÃ³!"</i> que fue especificado en el <code>reject()</code>.</li>
          <li class="chaptrSubSectUl__li">AquÃ­ usamos <code>console.error</code> para mostrar el error en la consola con un mensaje mÃ¡s claro.</li>
          <li class="chaptrSubSectUl__li">Entonces cuando <code>reject()</code> es llamado, el estado de la promesa cambia a <code>rejected</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Por Ãºltimo tenemos <code>.finally()</code>. El bloque <code>.finally()</code> se ejecuta <b>siempre</b>, independientemente de si la promesa fue resuelta con Ã©xito o rechazada. Es Ãºtil para tareas que deben realizarse tanto si el pago fue exitoso como si fallÃ³ (por ejemplo, cerrar una conexiÃ³n, limpiar variables, etc.)</p>
        <pre class="chaptrSubSect__console wScript">
          console.log('/Âº 1. Creando la promesa Âº/');

          let Â·verificarPago = new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;
            console.log('/Âº 2. Verificando estado del pago Âº/');

            @setTimeout(() =&gt; &#123;
              let Â·pagoExitoso = true;  /* /Âº Cambia a false para ver el rechazo Âº/ */

              if (Â·pagoExitoso) &#123;
                @resolve('/Âº 3. âœ” El pago fue exitoso. Âº/');
              &#125; else &#123;
                console.log('/Âº 3. Algo fallÃ³... Âº/');
              &#125;
              
            &#125;, Â¬2000);
          &#125;);

          console.log('/Âº 4. Promesa finalizada Âº/');
        
          Â·verificarPago
            .then((â€¢value) =&gt; &#123;     /* value es el valor pasado a resolve */
              console.log(`/Âº 5. Resultado: $&#123;â€¢value&#125; Âº/`);
          &#125;)
            .catch((â€¢error) =&gt; &#123;    /* error es el valor pasado a reject */
              console.@error(â€¢error.â€¢message);  /* Accedemos al mensaje de error */
          &#125;)
            .finally(() =&gt; &#123;
              console.log('/Âº 6. Proceso finalizado, logout. Âº/');
          &#125;);
          
          console.log('/Âº 7. Fin del script Âº/');

          â‹— /Âº 1. Creando la promesa Âº/
          â‹— /Âº 2. Verificando estado del pago Âº/
          â‹— /Âº 4. Promesa finalizada Âº/
          â‹— /Âº 7. Fin del script Âº/
          â‹— /Âº 5. Resultado: 3. âœ” El pago fue exitoso. Âº/
          â‹— /Âº 6. Proceso finalizado, logout. Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="ExpresiÃ³n de Promesa vs FunciÃ³n" codeText="">
        <p class="chaptrSubSect__p">Una promesa puede ser asignada directamente a una variable (expresiÃ³n de promesa) o crear una funciÃ³n que retorne una promesa. Vamos a explorar ambos enfoques en tÃ©rminos de ventajas, inconvenientes, usos y recomendaciones</p>
        <pre class="chaptrSubSect__console wScript">
          /* ExpresiÃ³n de Promesa */
          const Â·miPromesa = new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;
            @setTimeout(() =&gt; &#123;
              @resolve(Â·value);             /*/Âº o @reject(Â·error); Âº/*/
            &#125;, Â¬1500);
          &#125;);</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">âœ… <strong>Simplicidad:</strong> Es sencillo de escribir si sÃ³lo necesitas ejecutar una promesa una vez en un contexto fijo.</li>
          <li class="chaptrSubSectUl__li">âœ… <strong>Se ejecuta inmediatamente:</strong> La promesa comienza su ejecuciÃ³n en el momento en que se asigna a la variable. No es necesario invocar una funciÃ³n para iniciarla.</li>
          <li class="chaptrSubSectUl__li">âŒ <strong>No reutilizable:</strong> Si necesitas ejecutar esa promesa varias veces, no es posible con una expresiÃ³n de promesa asignada a una variable, porque ya se ha iniciado y finalizado.</li>
          <li class="chaptrSubSectUl__li">âŒ <strong>Menos control:</strong> Dado que la promesa se ejecuta inmediatamente, tienes menos control sobre cuÃ¡ndo empieza la operaciÃ³n asÃ­ncrona.</li>
          <li class="chaptrSubSectUl__li">âŒ <strong>DifÃ­cil de manejar en contextos complejos:</strong> Cuando necesitas manejar promesas con parÃ¡metros variables o lÃ³gica mÃ¡s avanzada, este enfoque se vuelve mÃ¡s limitado.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /* FunciÃ³n que devuelve una Promesa */
          function Â·miPromesa() &#123;
            return new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                @resolve(Â·value);           /*/Âº o @reject(Â·error); Âº/*/
              &#125;, Â¬1500);
            &#125;);
          &#125;</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">âœ… <code>ReutilizaciÃ³n:</code> Puedes invocar la funciÃ³n varias veces y cada vez obtendrÃ¡s una nueva promesa, permitiendo la ejecuciÃ³n repetida de la tarea asÃ­ncrona.</li>
          <li class="chaptrSubSectUl__li">âœ… <code>Control de la ejecuciÃ³n:</code> La promesa no se ejecuta inmediatamente, sino cuando llamas a la funciÃ³n. Esto te permite tener mÃ¡s control sobre cuÃ¡ndo deseas que se inicie la operaciÃ³n asÃ­ncrona.</li>
          <li class="chaptrSubSectUl__li">âœ… <code>ParÃ¡metros:</code> Puedes pasar parÃ¡metros a la funciÃ³n, lo que hace que sea mucho mÃ¡s flexible y adecuada para manejar diferentes entradas.</li>
          <li class="chaptrSubSectUl__li">âœ… <code>EncapsulaciÃ³n:</code> Agrupa el cÃ³digo asÃ­ncrono dentro de una funciÃ³n, lo que ayuda a mantener el cÃ³digo organizado, especialmente en proyectos grandes.</li>
          <li class="chaptrSubSectUl__li">âŒ <code>Puede parecer mÃ¡s complejo:</code> En algunos casos, puede requerir mÃ¡s lÃ­neas de cÃ³digo, aunque esto es mÃ¡s una cuestiÃ³n de estilo y no necesariamente una desventaja significativa.</li>
        </ul>
        <p class="chaptrSubSect__p">Ejemplo completo paso a paso</p>
        <pre class="chaptrSubSect__console wScript">
          function @calcularCuadrado(â€¢numero)&#123;
            return new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;
              console.log(`/Âº Calculando el cuadrado de $&#123;numero&#125;...Âº/`);

              @setTimeout(() =&gt; &#123;
                if(â€¢numero &gt;= Â¬0 )&#123;
                  @resolve(â€¢numero * â€¢numero);
                &#125; else &#123;
                  @reject(Âªnew Error('NÃºmero invalido'));
                &#125;
              &#125;, Â¬1500);
            &#125;);
          &#125;

          /* Reutilizable con diferentes numeros */
          @calcularCuadrado(Â¬3)
            .then((â€¢resultado) =&gt; &#123;
              console.log(`/Âº El cuadrado es: $&#123;resultado&#125; Âº/`);
            &#125;)
            .catch((â€¢error) =&gt; &#123;
              console.Âªerror('Error:', Ã§error.â€¢message);
            &#125;);
          
          â‹— /Âº Calculando el cuadrado de 3...Âº/
          â‹— /Âº El cuadrado es: 9 Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Encadenamiento Promesas" codeText="">
        <p class="chaptrSubSect__p">AsÃ­ encadenamos promesas</p>
        <pre class="chaptrSubSect__console wScript">
          function @inicioDia()&#123;
            return new @Promise((â€¢resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`*** Rutina matinal ***`);
                @resolve();
              &#125;, Â¬1500);
            &#125;);
          &#125;

          function @task1()&#123;
            return new @Promise((â€¢resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Suena el despertador`);
                @resolve();
              &#125;, Â¬2000);
            &#125;);
          &#125;

          function @task2()&#123;
            return new @Promise((â€¢resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Me levanto y voy a mear`);
                @resolve();
              &#125;, Â¬2000);
            &#125;);
          &#125;

          function @task3()&#123;
            return new @Promise((â€¢resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Me visto`);
                @resolve();
              &#125;, Â¬2000);
            &#125;);
          &#125;

          function @task4()&#123;
            return new @Promise((â€¢resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Preparo un cafÃ©`);
                @resolve();
              &#125;, Â¬2000);
            &#125;);
          &#125;

          function @task5()&#123;
            return new @Promise((â€¢resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Mientras bebo el cafÃ© miro el mÃ³vil`);
                @resolve();
              &#125;, Â¬2000);
            &#125;);
          &#125;

          function @task6()&#123;
            return new @Promise((â€¢resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Me voy a trabajar`);
                resolve();
              &#125;, Â¬2000);
            &#125;);
          &#125;

          @inicioDia()
                .then(() =&gt; @task1())
                .then(() =&gt; @task2())
                .then(() =&gt; @task3())
                .then(() =&gt; @task4())
                .then(() =&gt; @task5())
                .then(() =&gt; @task6())
        
          â‹— /Âº *** Rutina matinal *** Âº/
          â‹— /Âº Suena el despertador Âº/
          â‹— /Âº Me levanto y voy a mear Âº/
          â‹— /Âº Me visto Âº/
          â‹— /Âº Preparo un cafÃ© Âº/
          â‹— /Âº Mientras bebo el cafÃ© miro el mÃ³vil Âº/
          â‹— /Âº Me voy a trabajar Âº/</pre>
        <p class="chaptrSubSect__p">A esto se le llama encadenamiento de promesas, y el resultado se va pasando a lo largo de la cadena de controladores</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El ejemplo" codeText="loadScript">
        <p class="chaptrSubSect__p">Imagina que tienes una pÃ¡gina web que, en lugar de cargar todos los scripts al inicio, los carga de manera dinÃ¡mica cuando son necesarios. Por ejemplo, quieres cargar un archivo JavaScript externo solo cuando el usuario realiza cierta acciÃ³n</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos una funciÃ³n que recibe un archivo como argumento */ 
          /* src es la ruta del archivo que queremos cargar */
          function @loadScript(â€¢src) &#123;
            return new @Promise((â€¢resolve, â€¢reject) =&gt; &#123;
              /* Crea un elemento "script" y lo guarda en la variable */
              let Â·script = document.createElement('script');
              /* Asigna el argumento src como propiedad del elemento */
              Ã§script.â€¢src = â€¢src;

              /* Si el script se carga correctamente, resolvemos la promesa */
              /* devolviendo el objeto completo para poder trabajar con Ã©l */
              Ã§script.addEventListener('load', () =&gt; @resolve(Ã§script));

              /* Si hay un error al cargar el script, rechazamos la promesa */
              Ã§script.addEventListener('error', () =&gt; @reject( new Error(`/Âº Error de carga Âº/`)));

              /* AÃ±adimos el script al documento */
              document.â€¢head.append(Ã§script);
            &#125;);
          &#125;

          /* Llamamos a la funciÃ³n pasando como parÃ¡metro un archivo */
          @loadScript('miScript.js')
              .then((â€¢script) =&gt; &#123;
                console.log(`/Âº Script $&#123;Ã§script.â€¢src&#125; cargado! Âº/`);
              &#125;)
              .catch((â€¢error) =&gt; &#123;
                console.â€¢error(Ã§error.â€¢message);
              &#125;);</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Devolviendo promesas" codeText="">
        <p class="chaptrSubSect__p">En un encadenamiento de promesas, cada <code>.then()</code> puede devolver un valor o una nueva promesa. Si devuelve un valor, este se pasa al siguiente <code>.then()</code>. Pero si devuelve una promesa, el siguiente <code>.then()</code> esperarÃ¡ a que esta nueva promesa se resuelva antes de continuar. Esto es Ãºtil cuando tienes operaciones asincrÃ³nicas que dependen unas de otras</p>
        <pre class="chaptrSubSect__console wScript">
          function @loadImg(â€¢url) &#123;    /* â€ */
            return new @Promise((@resolve, @reject) =&gt; &#123;     /* â */
              const Â·img = new @Image();    /* â‚ */
              Â·img.â€¢src = â€¢url;    /* âƒ */

              Â·img.addEventListener('load', () =&gt; &#123;        /* â„ */
                @resolve(Â·img); 
              &#125;);

              Â·img.addEventListener('error', () =&gt; &#123;       /* â… */
                @reject( new Error('/Âº Error al cargar la imagen Âº/'));
              &#125;);
            &#125;);
          &#125;

          @loadImg('https://picsum.photos/200')    /* â† */
              .then((Â·img) =&gt; &#123;   /* â‡ */
                document.body.appendChild(Â·img);   /* âˆ */
                console.log('/Âº Imagen cargada y aÃ±adida! Âº/');    /* â‰ */

                return new @Promise((@resolve) =&gt; &#123;   /* â€â€ */
                  @setTimeout(() =&gt; &#123;   /* â€â */
                    Â·img.â€¢style.â€¢filter = '/Âº grayscale(100%) Âº/';   /* â€â‚ */
                    @resolve('/Âº Filtro aplicado con exito! Âº/');    /* â€âƒ */
                  &#125;, Â¬2500);    /* â€â„ */
                &#125;);
              &#125;)
              .then((Â·mensaje) =&gt; &#123;    /* â€â… */
                console.log(Â·mensaje);
              &#125;)
              .catch((â€¢error) =&gt; &#123;    /* â€â† */
                console.Âªerror(Ã§error.â€¢message);
              &#125;);</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>1 Â·</strong> Creamos la funciÃ³n que recibe como argumento la direcciÃ³n donde estÃ¡ la imagen.</li>
          <li class="chaptrSubSectUl__li"><strong>2 Â·</strong> Retornamos una promesa con <code>resolve, reject</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>3 Â·</strong> Creamos una instancia del objeto <code>Image</code> que es la etiqueta <code>&lt;img&gt;</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>4 Â·</strong> Asigamos la url a la propiedad <code>src</code> del objeto <code>img</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>5 Â·</strong> Usamos el mÃ©todo <code>load</code> con un <code>addEventListener</code>, quÃ© si se carga correctamente la imagen, se resuelve la promesa devolviendo el propio objeto <code>img</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>6 Â·</strong> Si hay un error al cargar la imagen, rechazamos la promesa con el mensaje de error.</li>
          <li class="chaptrSubSectUl__li"><strong>7 Â·</strong> Llamamos a la funciÃ³n pasando como parÃ¡metro la url donde estÃ¡ la imagen.</li>
          <li class="chaptrSubSectUl__li"><strong>8 Â·</strong> Si la promesa se resuelve con Ã©xito, ejecuta el <code>.then</code> que trae como parÃ¡metro el objeto <code>img</code> para poder procesarlo despuÃ©s.</li>
          <li class="chaptrSubSectUl__li"><strong>9 Â·</strong> AÃ±adimos al <code>body</code> el objeto <code>img</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>10 Â·</strong> Mostramos en consola el mensaje de Ã©xito de la carga.</li>
          <li class="chaptrSubSectUl__li"><strong>11 Â·</strong> Retornamos una nueva promesa, pasando solo el <code>resolve</code> puesto que si hay un error lo capturarÃ­a el <code>.catch</code> de abajo.</li>
          <li class="chaptrSubSectUl__li"><strong>12 Â·</strong> AÃ±adimos un retraso de tiempo para que primero cargue la imagen y despuÃ©s se vea la operaciÃ³n que se hace sobre ella.</li>
          <li class="chaptrSubSectUl__li"><strong>13 Â·</strong> AÃ±adimos a la imagen un filtro.</li>
          <li class="chaptrSubSectUl__li"><strong>14 Â·</strong> Resolvemos la promesa con un <span class="bttn">mensaje</span>.</li>
          <li class="chaptrSubSectUl__li"><strong>15 Â·</strong> DespuÃ©s de 2,5seg de haber cargado la imagen se verÃ¡ como se aplica el filtro.</li>
          <li class="chaptrSubSectUl__li"><strong>16 Â·</strong> Una vez se resuelve la promesa se ejecuta este <code>.then</code> que trae como parÃ¡metro el <span class="bttn">mensaje</span>.</li>
          <li class="chaptrSubSectUl__li"><strong>17 Â·</strong> Si la promesa falla muestra en consola el mensaje de error.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Manejo de errores" codeText="">
        <p class="chaptrSubSect__p">Cuando trabajamos con promesas, los errores se manejan usando <code>.catch()</code>. Si una promesa se rechaza o ocurre un error en cualquier parte de la cadena de promesas, <code>.catch()</code> captura ese error. Una de las grandes ventajas de usar promesas es que podemos manejar los errores en cualquier punto de la cadena. No necesitamos escribir un <code>.catch()</code> despuÃ©s de cada <code>.then()</code>, podemos colocarlo al final para manejar cualquier error que ocurra en la cadena.</p>
        <pre class="chaptrSubSect__console wScript">
          function @dividir(â€¢a, â€¢b) &#123;
            return new @Promise((@resolve, @reject) =&gt; &#123;
              if (â€¢b === Â¬0) &#123;
                @resolve(â€¢a / â€¢b);
              &#125; else &#123;
                @reject( new Error('/Âº DivisiÃ³n por cero no permitida Âº/') );
              &#125;
            &#125;);
          &#125;

          @dividir(Â¬10, Â¬2)
            .then((â€¢resultado) =&gt; &#123;
              console.log(`/Âº Resultado: $&#123;â€¢resultado&#125; Âº/`);
              return @dividir(â€¢resultado, Â¬0);   /* DivisiÃ³n por cero */
            &#125;)
            .then((â€¢resultado) =&gt; &#123;
              console.log(`/Âº Nuevo Resultado: $&#123;â€¢resultado&#125; Âº/`);
            &#125;)
            .catch((â€¢error) =&gt; &#123;
              console.Âªerror(Ã§error.â€¢message);
            &#125;);</pre>
        <p class="chaptrSubSect__p">â­ A veces, puedes capturar un error, pero no puedes manejarlo completamente en el momento. En ese caso, puedes volver a lanzar (rethrow) el error para que otro <code>.catch()</code> mÃ¡s arriba lo maneje</p>
        <pre class="chaptrSubSect__console wScript">
          function @validarUsuario(Â·usuario) &#123;
            return new @Promise((@resolve, @reject) =&gt; &#123;
              if (!Â·usuario.â€¢email) &#123;
                @reject( new Error('/Âº Falta el email Âº/'));
              &#125; else &#123;
                @resolve('/Âº Usuario vÃ¡lido Âº/');
              &#125;
            &#125;);
          &#125;

          @validarUsuario(&#123; nombre: 'Iker' &#125;)
            .catch((Ã§error) =&gt; &#123;
              console.warn(`/Âº Log interno: $&#123;Ã§error.message&#125; Âº/`);
              throw Ã§error;
            &#125;)
            .then((â€¢mensaje) =&gt; &#123;
              console.log(â€¢mensaje); // no se ejecuta
            &#125;)
            .catch((Ã§error) =&gt; &#123;
              console.Âªerror(`/Âº Error mostrado al usuario: $&#123;error.message&#125; Âº/`);
            &#125;);</pre>
        <p class="chaptrSubSect__p"><code>throw</code> lanza un error, lo que provoca que la promesa se rechace de inmediato. Esto es similar a llamar a <code>reject()</code> con un error</p>
        <p class="chaptrSubSect__p">â­ Rechazos no manejados. Si no agregas un <code>.catch()</code> y ocurre un error en tu cadena de promesas, el error no serÃ¡ manejado, lo que puede causar problemas en tu aplicaciÃ³n. Para evitar esto, puedes usar el evento <code>unhandledrejection</code> en el navegador, que captura cualquier promesa rechazada que no tenga un <code>.catch()</code>. El evento te permite detectar esos errores no manejados para hacer algo con ellos, como por ejemplo, mostrar un mensaje de error o guardarlo para reportarlo</p>
        <pre class="chaptrSubSect__console wScript">
          Ã§window.addEventListener('unhandledrejection', (Ã§event) =&gt; &#123;
            console.Âªerror(`/Âº âš ï¸ Promesa rechazada sin .catch(): $&#123;event.reason.message&#125; Âº/`);
          &#125;);

          /*/Âº Promesa SIN .catch() Âº/*/
          new @Promise((@resolve, @reject) =&gt; &#123;
            @reject( new Error('/Âº Fallo crÃ­tico en la promesa! Âº/') );
          &#125;);

          /*/Âº Otra promesa sin manejar Âº/*/
          Ã§Promise.Âªreject( new Error('/Âº Otro error sin .catch() Âº/'));</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Promise API" codeText="Promise.all">
        <p class="chaptrSubSect__p">Toma un array de promesas <code>requests</code> y devuelve una nueva promesa que <b>se resuelve cuando todas las promesas en el array se han completado</b>. Si alguna solicitud falla, <code>Promise.all</code> rechazarÃ¡ con un error, y se manejarÃ¡ mÃ¡s adelante en el cÃ³digo con un <code>.catch()</code></p>
        <pre class="chaptrSubSect__console wScript">
          const Â·promesa1 = Ã§Promise.@resolve(Â¬5);  /*/Âº se resuelve inmediatamente con 5 Âº/*/

          const Â·promesa2 = new Ã§Promise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(Â¬10), Â¬500); /*/Âº se resuelve en 0.5s con 10 Âº/*/
          &#125;);

          const Â·promesa3 = new Ã§Promise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(Â¬15), Â¬1000); /*/Âº se resuelve en 1s con 15 Âº/*/
          &#125;);

          Ã§Promise.@all([Â·promesa1, Â·promesa2, Â·promesa3])
            .then((Â·resultados) =&gt; &#123;
              console.log(`/Âº Resultados: $&#123;resultados&#125; Âº/`); /*/Âº "Resultados: 5, 10, 15" Âº/*/
            &#125;)
            .catch((Ã§error) =&gt; &#123;
              console.Âªerror(`/Âº Error en una de las promesas: $&#123;error&#125; Âº/`);
            &#125;);</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Promise API" codeText="Promise.allSetlled">
        <p class="chaptrSubSect__p">Rechaza como un todo si cualquiera de sus promesas es rechazada, <b>siempre esperarÃ¡ a que todas las promesas se resuelvan</b>, ya sea de manera exitosa o con un error, y devolverÃ¡ un array que contiene el estado y el resultado de cada promesa (ya sea resuelta o rechazada). Esto es bueno para los casos de â€œtodo o nadaâ€, cuando necesitamos proceder aunque haya promesas rechazadas</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·promesa1 = Ã§Promise.@resolve(Â¬5);

          const Â·promesa2 = new Ã§Promise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(Â¬10), Â¬500);
          &#125;);

          const Â·promesa3 = new @Promise((_, @reject) =&gt; &#123;
            @setTimeout(() =&gt; @reject( new Error('/Âº FallÃ³ la promesa 3 Âº/')), Â¬800);
          &#125;);

          Ã§Promise.@allSettled([â€¢promesa1, â€¢promesa2, â€¢promesa3])
            .then((Â·resultados) =&gt; &#123;
              console.log(`Resultados: $&#123;resultados&#125;`);

              Â·resultados.forEach((Â·resultado) =&gt; &#123;
                  console.log(Â·resultado.â€¢status)
              &#125;);
            &#125;);
          
          /*/Âº Resultados: [ Âº/*/
            /*/Âº &#123; status: 'fulfilled', value: 5 &#125;, Âº/*/
            /*/Âº &#123; status: 'fulfilled', value: 10 &#125;, Âº/*/
            /*/Âº &#123; status: 'rejected', reason: Âº/ /ÂºError : FallÃ³ la promesa 3 &#125; Âº/*/
          /*/Âº ] Âº/*/
          /*/Âº fulfilled Âº/*/
          /*/Âº fulfilled Âº/*/
          /*/Âº rejected Âº/*/
          </pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Promise API" codeText="Promise.race">
        <p class="chaptrSubSect__p">Devuelve una promesa que se resuelve o se rechaza con el resultado de la primera promesa que termine (ya sea con Ã©xito o error)</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·promesa1 = Ã§Promise.@resolve(Â¬5);

          const Â·promesa2 = new Ã§Promise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(Â¬10), Â¬500);
          &#125;);

          const Â·promesa3 = new @Promise((_, @reject) =&gt; &#123;
            @setTimeout(() =&gt; @reject( new Error('/Âº FallÃ³ la promesa 3 Âº/')), Â¬800);
          &#125;);

          Ã§Promise.@race([Â·promesa1, Â·promesa2, Â·promesa3])
            .then((Â·resultado) =&gt; &#123;
              console.log(`/Âº Ganadora: $&#123;Â·resultado&#125; Âº/`);
            &#125;)
            .catch((Ã§error) =&gt; &#123;
              console.Âªerror(`/Âº Error : $&#123;error.message&#125; Âº/`);
            &#125;);

          /*/Âº Ganadora: 5 Âº/*/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Promise API" codeText="Promise.any">
        <p class="chaptrSubSect__p">Similar a <code>Promise.race</code>, solo se resuelve cuando al menos una de las promesas se resuelve correctamente, ignorando cualquier promesa que falle. Si todas las promesas fallan, entonces devuelve un error</p>
        <pre class="chaptrSubSect__console wScript">
          const Â·promesa1 = new @Promise((_, @reject) =&gt; &#123;
            @setTimeout(() =&gt; @reject( new Error('/Âº FallÃ³ promesa 1 Âº/')), Â¬300);
          &#125;);

          const Â·promesa2 = new @Promise((_, @reject) =&gt; &#123;
            @setTimeout(() =&gt; @reject( new Error('/Âº FallÃ³ promesa 2 Âº/')), Â¬500);
          &#125;);

          const Â·promesa3 = new Ã§Promise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(`/Âº Promesa 3 cumplida! ğŸ‰ Âº/`), Â¬800);
          &#125;);

          Ã§Promise.@any([Â·promesa1, Â·promesa2, Â·promesa3])
            .then((Â·resultado) =&gt; &#123;
              console.log(`/Âº 1Âª Promesa cumplida: $&#123;Â·resultado&#125; Âº/`);
            &#125;)
            .catch((Ã§error) =&gt; &#123;
              console.Âªerror(`/Âº Error : $&#123;error.message&#125; Âº/`);
            &#125;);

          /*/Âº 1Âª Promesa cumplida: Promesa 3 cumplida! ğŸ‰ Âº/*/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_26" nextPage="/lessons/lesson_28"/>
</MainLayout>

<!-- 
&lt;&gt;          < > no estilados
()&#123;&#125;    ( ) { } no estilados
ï¹›ï¹œ              { } Llaves no estilados
ï¹•                : 2 puntos no estilados
ï¼ƒ                # Rejilla no estilada

ÂªmÃ©todos
â€¢parametro
Â·variable
#variable en Func/if/for
Ã§Objetos
â‹— Resultado
@funcion()
Â¬numbers
objProperty:
ÂºobjProperty
/* comentario */
'/Âº modo texto quita span Âº/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">

-->
