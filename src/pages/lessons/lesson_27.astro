---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__27" h2Title="Promesas" slot="mainContent">
    <ChaptrSect h3Title="Las Promesas" codeText="">
      <ChaptrSubSect h4Title="Definición" codeText="">
        <p class="chaptrSubSect__p">Una <span class="bttn">promesa</span> es algo que representa un valor que no está disponible inmediatamente, pero que lo estará en el futuro. Piensa en una promesa como algo que puede cumplirse o fallar, pero que aún no sabes cuál será el resultado. En la vida real, sería como hacer un pedido de comida: no tienes la comida ahora, pero la tendrás después (eso sí, podría haber un retraso o incluso no llegar).</p>
        <p class="chaptrSubSect__p">Estados de una promesa</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>Pending</strong> cuando la promesa se ha creado, pero aún no se ha resuelto. Como cuando haces el pedido de comida.</li>
          <li class="chaptrSubSectUl__li"><strong>Fulfilled</strong> cuando todo sale bien y obtienes el valor esperado. Como cuando recibes tu comida.</li>
          <li class="chaptrSubSectUl__li"><strong>Rejected</strong> cuando algo salió mal y no obtienes el valor esperado. Como cuando te llaman y te dicen que no pueden entregarte la comida.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Creación con" codeText="new Promise()">
        <p class="chaptrSubSect__p">Para crear una promesa, usamos el constructor <code>new Promise()</code>. Este constructor necesita que se le pase una función (llamada <span class="bttn">executor</span>) que contiene dos <span class="bttn">callbacks</span> como parámetros</p>
        <p class="chaptrSubSect__p">Cuando creamos la promesa con <code>new Promise()</code> el <span class="bttn">executor</span> corre inmediatamente</p>
        <pre class="chaptrSubSect__console wScript">
          const ·miPromesa = new @Promise( function @executor( function @siTodoOk, function @siAlgoFalla ) &#123; 
            /* Aquí va el código asíncrono */
          &#125;);</pre>
        <p class="chaptrSubSect__p">Los <span class="bttn">callback</span> pasados como argumento al <span class="bttn">executor</span> se llaman por convención <code>resolve</code> y <code>reject</code> y se usa la notación de arrow function</p>
        <pre class="chaptrSubSect__console wScript">
          const ·miPromesa = new @Promise((•resolve, •reject) =&gt; &#123; 
            /* Aquí va el código asíncrono */
          &#125;);</pre>
        <p class="chaptrSubSect__p">Cuando el <span class="bttn">executor</span> obtiene el resultado (da igual cuando) debe llamar a una de estas dos <span class="bttn">callback</span></p>
        <p class="chaptrSubSect__p">Que son <code>resolve</code> y <code>reject</code>?</p>
        <p class="chaptrSubSect__p"><code>resolve</code> es una función que se llama cuando la tarea asincrónica se completa con éxito. Su propósito es "cumplir" la promesa y enviar un valor de éxito, "Todo salió bien, aquí tienes el resultado"</p>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          const ·miPromesa = new @Promise((•resolve, •reject) =&gt; &#123;   /* ➀ */
            @resolve(·value); /* ➁ */
          &#125;);</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>➀</strong>: El "executor" <code>() =&gt; &#123;&#125;</code> ejecuta inmediatamente el bloque de código de su interior.</li>
          <li class="chaptrSubSectUl__li"><strong>➁</strong>: Cuando se llama a <code>resolve</code> el valor que pasamos entre paréntesis será el valor que devolverá la promesa.</li>
          <li class="chaptrSubSectUl__li"><strong>➂</strong>: Cambia el estado de la promesa a <code>fullfilled</code>.</li>
        </ul>
        <p class="chaptrSubSect__p"><code>reject</code> (o su nombre descriptivo) es una función que se llama cuando la tarea asincrónica falla. Su propósito es "rechazar" la promesa y enviar un mensaje o razón del fallo, "Algo salió mal, no puedo cumplir la promesa".</p>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          const ·miPromesa = new @Promise((•resolve, •reject) =&gt; &#123;   /* ➀ */
              @reject( new Error('/º Oooops! º/') );  /* ➁ */
            &#125;;</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>➀</strong>: El "executor" <code>() =&gt; &#123;&#125;</code> ejecuta automáticamente el bloque de código de su interior.</li>
          <li class="chaptrSubSectUl__li"><strong>➁</strong>: Si ocurre un error se llama a "reject" con el objeto Error. El valor de la promesa es el string "Oooops!".</li>
          <li class="chaptrSubSectUl__li"><strong>➂</strong>: Cambia el estado de la promesa a <code>rejected</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Entonces el executor en algun momento pasa la <span class="bttn">promise</span> a uno de estos dos estados</p>
        <pre class="chaptrSubSect__console wScript">
                                                                         state: 'fullfilled'
                                                  @resolve(çvalue) =&gt;  result: çvalue
            state: 'pending'
            result: undefined
                                                  @reject(çerror) =&gt;   state: 'rejected'
                                                                        result: çerror</pre>
        <p class="chaptrSubSect__p">Entonces, esta sería una versión completa, simulando un código asíncrono</p>
        <pre class="chaptrSubSect__console wScript">
          console.log('/º 1. Creando la promesa º/');

          let ·miPromesa = new @Promise((•resolve, •reject) =&gt; &#123;
            console.log('/º 2. Iniciando tarea asíncrona º/');

            @setTimeout(() =&gt; &#123;
              let ·todoBien = true;  /* /º Cambia a false para ver el rechazo º/ */

              if (·todoBien) &#123;
                @resolve('/º 3. ✔ La tarea se completó con éxito. º/');
              &#125; else &#123;
                @reject( new Error('/º 3. Oooops! Algo falló. º/') );
              &#125;

            &#125;, ¬1500);
          &#125;);

          console.log('/º 4. Ejecucion de promesa terminada, esperando resultado º/');

          ⋗ /º 1. Creando la promesa º/
          ⋗ /º 2. Iniciando tarea asíncrona º/
          ⋗ /º 4. Ejecucion de promesa terminada, esperando resultado º/
          ⋗ /º 3. ✔ La tarea se completó con éxito. º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Consumidores" codeText="then, catch, finally">
        <p class="chaptrSubSect__p">Aprender <span class="bttn">Promesas</span> no es tanto el aprender a crearlas, sino a manejar su resultado. Esto nos servirá mas adelante para saber manejar el resultado por ejemplo de <code>fetch</code> que devuelve una promesa</p>
        <p class="chaptrSubSect__p">Un objeto <code>Promise</code> sirve como enlace entre el <span class="bttn">executor</span> y las <strong>funciones consumidoras</strong>, que recibirán un resultado o un error. Las <strong>funciones consumidoras</strong> son las que manejan el resultado que el <span class="bttn">executor</span> entrega a través de <code>resolve</code> o <code>reject</code>, utilizando los métodos <code>.then</code> y <code>.catch</code></p>
        <p class="chaptrSubSect__p">El más importante es <code>.then</code></p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis */
          çmyPromise.then(
            @function(•onFulfilled?) &#123; /* Maneja resultado exitoso */ &#125;,
            @function(•onRejected?) &#123; /* Maneja error */ &#125;
          );
        
          /* Con arrow functions */
          çmyPromise.then(•onFulfilled?, •onRejected?);</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">El primer argumento de <code>.then</code> es una <mark>función</mark> que se ejecuta cuando se resuelve la promesa y recibe el resultado.</li>
          <li class="chaptrSubSectUl__li">El segundo argumento de <code>.then</code> es una <mark>función</mark> que se ejecuta cuando se rechaza la promesa y recibe el error, aunque <mark>no es recomendable</mark> es mejor usar <code>.catch()</code>.</li>
          <li class="chaptrSubSectUl__li"><code>result</code> devuelve el mismo valor que se le pasa a <code>resolve</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Veamos un ejemplo completo</p>
        <pre class="chaptrSubSect__console wScript">
          console.log('/º 1. Creando la promesa º/');

          let ·verificarPago = new @Promise((•resolve, •reject) =&gt; &#123;
            console.log('/º 2. Verificando estado del pago º/');

            @setTimeout(() =&gt; &#123;
              let ·pagoExitoso = true;  /* /º Cambia a false para ver el rechazo º/ */

              if (·pagoExitoso) &#123;
                @resolve('/º 3. ✔ El pago fue exitoso. º/');
              &#125; else &#123;
                console.log('/º 3. Algo falló... º/');
              &#125;
              
            &#125;, ¬2000);
          &#125;);

          console.log('/º 4. Promesa finalizada º/');
        
          ·verificarPago
            .then((•value) =&gt; &#123;     /* value es el valor pasado a resolve */
              console.log(`/º 5. Resultado: $&#123;•value&#125; º/`);
          &#125;);

          console.log('/º 6. Fin del script º/');

          ⋗ /º 1. Creando la promesa º/
          ⋗ /º 2. Verificando estado del pago º/
          ⋗ /º 4. Promesa finalizada º/
          ⋗ /º 6. Fin del script º/
          ⋗ /º 5. Resultado: 3. ✔ El pago fue exitoso. º/</pre>
        <p class="chaptrSubSect__p">Después tenemos <code>.catch</code>. Si la promesa es rechazada, (si <code>reject()</code> es llamado), el bloque <code>.catch()</code> se activa e intercepta y maneja el error</p>
        <pre class="chaptrSubSect__console wScript">
          console.log('/º 1. Creando la promesa º/');

          let ·verificarPago = new @Promise((•resolve, •reject) =&gt; &#123;
            console.log('/º 2. Verificando estado del pago º/');

            @setTimeout(() =&gt; &#123;
              let ·pagoExitoso = false;  /* /º Cambia a false para ver el rechazo º/ */

              if (·pagoExitoso) &#123;
                @resolve('/º 3. ✔ El pago fue exitoso. º/');
              &#125; else &#123;
                console.log('/º 3. Algo falló! º/');
              &#125;
              
            &#125;, ¬2000);
          &#125;);

          console.log('/º 4. Promesa finalizada º/');
        
          ·verificarPago
            .then((•value) =&gt; &#123;     /* value es el valor pasado a resolve */
              console.log(`/º 5. Resultado: $&#123;•value&#125; º/`);
          &#125;)
            .catch((•error) =&gt; &#123;    /* error es el valor pasado a reject */
              console.@error(•error.•message);  /* Accedemos al mensaje de error */
          &#125;);

          console.log('/º 6. Fin del script º/');
        
          ⋗ /º 1. Creando la promesa º/
          ⋗ /º 2. Verificando estado del pago º/
          ⋗ /º 4. Promesa finalizada º/
          ⋗ /º 6. Fin del script º/
          ⋗ /º 5. Resultado: 3. ✔ Algo falló! º/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">El argumento que recibe <code>.catch()</code> <mark>es el valor que se pasa a</mark> <code>reject()</code>, que en este caso es un objeto <code>Error</code>. El método <code>error.message</code> accede al mensaje <i>"Algo falló!"</i> que fue especificado en el <code>reject()</code>.</li>
          <li class="chaptrSubSectUl__li">Aquí usamos <code>console.error</code> para mostrar el error en la consola con un mensaje más claro.</li>
          <li class="chaptrSubSectUl__li">Entonces cuando <code>reject()</code> es llamado, el estado de la promesa cambia a <code>rejected</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Por último tenemos <code>.finally()</code>. El bloque <code>.finally()</code> se ejecuta <b>siempre</b>, independientemente de si la promesa fue resuelta con éxito o rechazada. Es útil para tareas que deben realizarse tanto si el pago fue exitoso como si falló (por ejemplo, cerrar una conexión, limpiar variables, etc.)</p>
        <pre class="chaptrSubSect__console wScript">
          console.log('/º 1. Creando la promesa º/');

          let ·verificarPago = new @Promise((•resolve, •reject) =&gt; &#123;
            console.log('/º 2. Verificando estado del pago º/');

            @setTimeout(() =&gt; &#123;
              let ·pagoExitoso = true;  /* /º Cambia a false para ver el rechazo º/ */

              if (·pagoExitoso) &#123;
                @resolve('/º 3. ✔ El pago fue exitoso. º/');
              &#125; else &#123;
                console.log('/º 3. Algo falló... º/');
              &#125;
              
            &#125;, ¬2000);
          &#125;);

          console.log('/º 4. Promesa finalizada º/');
        
          ·verificarPago
            .then((•value) =&gt; &#123;     /* value es el valor pasado a resolve */
              console.log(`/º 5. Resultado: $&#123;•value&#125; º/`);
          &#125;)
            .catch((•error) =&gt; &#123;    /* error es el valor pasado a reject */
              console.@error(•error.•message);  /* Accedemos al mensaje de error */
          &#125;)
            .finally(() =&gt; &#123;
              console.log('/º 6. Proceso finalizado, logout. º/');
          &#125;);
          
          console.log('/º 7. Fin del script º/');

          ⋗ /º 1. Creando la promesa º/
          ⋗ /º 2. Verificando estado del pago º/
          ⋗ /º 4. Promesa finalizada º/
          ⋗ /º 7. Fin del script º/
          ⋗ /º 5. Resultado: 3. ✔ El pago fue exitoso. º/
          ⋗ /º 6. Proceso finalizado, logout. º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Expresión de Promesa vs Función" codeText="">
        <p class="chaptrSubSect__p">Una promesa puede ser asignada directamente a una variable (expresión de promesa) o crear una función que retorne una promesa. Vamos a explorar ambos enfoques en términos de ventajas, inconvenientes, usos y recomendaciones</p>
        <pre class="chaptrSubSect__console wScript">
          /* Expresión de Promesa */
          const ·miPromesa = new @Promise((•resolve, •reject) =&gt; &#123;
            @setTimeout(() =&gt; &#123;
              @resolve(·value);             /*/º o @reject(·error); º/*/
            &#125;, ¬1500);
          &#125;);</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">✅ <strong>Simplicidad:</strong> Es sencillo de escribir si sólo necesitas ejecutar una promesa una vez en un contexto fijo.</li>
          <li class="chaptrSubSectUl__li">✅ <strong>Se ejecuta inmediatamente:</strong> La promesa comienza su ejecución en el momento en que se asigna a la variable. No es necesario invocar una función para iniciarla.</li>
          <li class="chaptrSubSectUl__li">❌ <strong>No reutilizable:</strong> Si necesitas ejecutar esa promesa varias veces, no es posible con una expresión de promesa asignada a una variable, porque ya se ha iniciado y finalizado.</li>
          <li class="chaptrSubSectUl__li">❌ <strong>Menos control:</strong> Dado que la promesa se ejecuta inmediatamente, tienes menos control sobre cuándo empieza la operación asíncrona.</li>
          <li class="chaptrSubSectUl__li">❌ <strong>Difícil de manejar en contextos complejos:</strong> Cuando necesitas manejar promesas con parámetros variables o lógica más avanzada, este enfoque se vuelve más limitado.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /* Función que devuelve una Promesa */
          function ·miPromesa() &#123;
            return new @Promise((•resolve, •reject) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                @resolve(·value);           /*/º o @reject(·error); º/*/
              &#125;, ¬1500);
            &#125;);
          &#125;</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">✅ <code>Reutilización:</code> Puedes invocar la función varias veces y cada vez obtendrás una nueva promesa, permitiendo la ejecución repetida de la tarea asíncrona.</li>
          <li class="chaptrSubSectUl__li">✅ <code>Control de la ejecución:</code> La promesa no se ejecuta inmediatamente, sino cuando llamas a la función. Esto te permite tener más control sobre cuándo deseas que se inicie la operación asíncrona.</li>
          <li class="chaptrSubSectUl__li">✅ <code>Parámetros:</code> Puedes pasar parámetros a la función, lo que hace que sea mucho más flexible y adecuada para manejar diferentes entradas.</li>
          <li class="chaptrSubSectUl__li">✅ <code>Encapsulación:</code> Agrupa el código asíncrono dentro de una función, lo que ayuda a mantener el código organizado, especialmente en proyectos grandes.</li>
          <li class="chaptrSubSectUl__li">❌ <code>Puede parecer más complejo:</code> En algunos casos, puede requerir más líneas de código, aunque esto es más una cuestión de estilo y no necesariamente una desventaja significativa.</li>
        </ul>
        <p class="chaptrSubSect__p">Ejemplo completo paso a paso</p>
        <pre class="chaptrSubSect__console wScript">
          function @calcularCuadrado(•numero)&#123;
            return new @Promise((•resolve, •reject) =&gt; &#123;
              console.log(`/º Calculando el cuadrado de $&#123;numero&#125;...º/`);

              @setTimeout(() =&gt; &#123;
                if(•numero &gt;= ¬0 )&#123;
                  @resolve(•numero * •numero);
                &#125; else &#123;
                  @reject(ªnew Error('Número invalido'));
                &#125;
              &#125;, ¬1500);
            &#125;);
          &#125;

          /* Reutilizable con diferentes numeros */
          @calcularCuadrado(¬3)
            .then((•resultado) =&gt; &#123;
              console.log(`/º El cuadrado es: $&#123;resultado&#125; º/`);
            &#125;)
            .catch((•error) =&gt; &#123;
              console.ªerror('Error:', çerror.•message);
            &#125;);
          
          ⋗ /º Calculando el cuadrado de 3...º/
          ⋗ /º El cuadrado es: 9 º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Encadenamiento Promesas" codeText="">
        <p class="chaptrSubSect__p">Así encadenamos promesas</p>
        <pre class="chaptrSubSect__console wScript">
          function @inicioDia()&#123;
            return new @Promise((•resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`*** Rutina matinal ***`);
                @resolve();
              &#125;, ¬1500);
            &#125;);
          &#125;

          function @task1()&#123;
            return new @Promise((•resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Suena el despertador`);
                @resolve();
              &#125;, ¬2000);
            &#125;);
          &#125;

          function @task2()&#123;
            return new @Promise((•resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Me levanto y voy a mear`);
                @resolve();
              &#125;, ¬2000);
            &#125;);
          &#125;

          function @task3()&#123;
            return new @Promise((•resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Me visto`);
                @resolve();
              &#125;, ¬2000);
            &#125;);
          &#125;

          function @task4()&#123;
            return new @Promise((•resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Preparo un café`);
                @resolve();
              &#125;, ¬2000);
            &#125;);
          &#125;

          function @task5()&#123;
            return new @Promise((•resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Mientras bebo el café miro el móvil`);
                @resolve();
              &#125;, ¬2000);
            &#125;);
          &#125;

          function @task6()&#123;
            return new @Promise((•resolve) =&gt; &#123;
              @setTimeout(() =&gt; &#123;
                console.log(`Me voy a trabajar`);
                resolve();
              &#125;, ¬2000);
            &#125;);
          &#125;

          @inicioDia()
                .then(() =&gt; @task1())
                .then(() =&gt; @task2())
                .then(() =&gt; @task3())
                .then(() =&gt; @task4())
                .then(() =&gt; @task5())
                .then(() =&gt; @task6())
        
          ⋗ /º *** Rutina matinal *** º/
          ⋗ /º Suena el despertador º/
          ⋗ /º Me levanto y voy a mear º/
          ⋗ /º Me visto º/
          ⋗ /º Preparo un café º/
          ⋗ /º Mientras bebo el café miro el móvil º/
          ⋗ /º Me voy a trabajar º/</pre>
        <p class="chaptrSubSect__p">A esto se le llama encadenamiento de promesas, y el resultado se va pasando a lo largo de la cadena de controladores</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="El ejemplo" codeText="loadScript">
        <p class="chaptrSubSect__p">Imagina que tienes una página web que, en lugar de cargar todos los scripts al inicio, los carga de manera dinámica cuando son necesarios. Por ejemplo, quieres cargar un archivo JavaScript externo solo cuando el usuario realiza cierta acción</p>
        <pre class="chaptrSubSect__console wScript">
          /* Creamos una función que recibe un archivo como argumento */ 
          /* src es la ruta del archivo que queremos cargar */
          function @loadScript(•src) &#123;
            return new @Promise((•resolve, •reject) =&gt; &#123;
              /* Crea un elemento "script" y lo guarda en la variable */
              let ·script = document.createElement('script');
              /* Asigna el argumento src como propiedad del elemento */
              çscript.•src = •src;

              /* Si el script se carga correctamente, resolvemos la promesa */
              /* devolviendo el objeto completo para poder trabajar con él */
              çscript.addEventListener('load', () =&gt; @resolve(çscript));

              /* Si hay un error al cargar el script, rechazamos la promesa */
              çscript.addEventListener('error', () =&gt; @reject( new Error(`/º Error de carga º/`)));

              /* Añadimos el script al documento */
              document.•head.append(çscript);
            &#125;);
          &#125;

          /* Llamamos a la función pasando como parámetro un archivo */
          @loadScript('miScript.js')
              .then((•script) =&gt; &#123;
                console.log(`/º Script $&#123;çscript.•src&#125; cargado! º/`);
              &#125;)
              .catch((•error) =&gt; &#123;
                console.•error(çerror.•message);
              &#125;);</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Devolviendo promesas" codeText="">
        <p class="chaptrSubSect__p">En un encadenamiento de promesas, cada <code>.then()</code> puede devolver un valor o una nueva promesa. Si devuelve un valor, este se pasa al siguiente <code>.then()</code>. Pero si devuelve una promesa, el siguiente <code>.then()</code> esperará a que esta nueva promesa se resuelva antes de continuar. Esto es útil cuando tienes operaciones asincrónicas que dependen unas de otras</p>
        <pre class="chaptrSubSect__console wScript">
          function @loadImg(•url) &#123;    /* ➀ */
            return new @Promise((@resolve, @reject) =&gt; &#123;     /* ➁ */
              const ·img = new @Image();    /* ➂ */
              ·img.•src = •url;    /* ➃ */

              ·img.addEventListener('load', () =&gt; &#123;        /* ➄ */
                @resolve(·img); 
              &#125;);

              ·img.addEventListener('error', () =&gt; &#123;       /* ➅ */
                @reject( new Error('/º Error al cargar la imagen º/'));
              &#125;);
            &#125;);
          &#125;

          @loadImg('https://picsum.photos/200')    /* ➆ */
              .then((·img) =&gt; &#123;   /* ➇ */
                document.body.appendChild(·img);   /* ➈ */
                console.log('/º Imagen cargada y añadida! º/');    /* ➉ */

                return new @Promise((@resolve) =&gt; &#123;   /* ➀➀ */
                  @setTimeout(() =&gt; &#123;   /* ➀➁ */
                    ·img.•style.•filter = '/º grayscale(100%) º/';   /* ➀➂ */
                    @resolve('/º Filtro aplicado con exito! º/');    /* ➀➃ */
                  &#125;, ¬2500);    /* ➀➄ */
                &#125;);
              &#125;)
              .then((·mensaje) =&gt; &#123;    /* ➀➅ */
                console.log(·mensaje);
              &#125;)
              .catch((•error) =&gt; &#123;    /* ➀➆ */
                console.ªerror(çerror.•message);
              &#125;);</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>1 ·</strong> Creamos la función que recibe como argumento la dirección donde está la imagen.</li>
          <li class="chaptrSubSectUl__li"><strong>2 ·</strong> Retornamos una promesa con <code>resolve, reject</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>3 ·</strong> Creamos una instancia del objeto <code>Image</code> que es la etiqueta <code>&lt;img&gt;</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>4 ·</strong> Asigamos la url a la propiedad <code>src</code> del objeto <code>img</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>5 ·</strong> Usamos el método <code>load</code> con un <code>addEventListener</code>, qué si se carga correctamente la imagen, se resuelve la promesa devolviendo el propio objeto <code>img</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>6 ·</strong> Si hay un error al cargar la imagen, rechazamos la promesa con el mensaje de error.</li>
          <li class="chaptrSubSectUl__li"><strong>7 ·</strong> Llamamos a la función pasando como parámetro la url donde está la imagen.</li>
          <li class="chaptrSubSectUl__li"><strong>8 ·</strong> Si la promesa se resuelve con éxito, ejecuta el <code>.then</code> que trae como parámetro el objeto <code>img</code> para poder procesarlo después.</li>
          <li class="chaptrSubSectUl__li"><strong>9 ·</strong> Añadimos al <code>body</code> el objeto <code>img</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>10 ·</strong> Mostramos en consola el mensaje de éxito de la carga.</li>
          <li class="chaptrSubSectUl__li"><strong>11 ·</strong> Retornamos una nueva promesa, pasando solo el <code>resolve</code> puesto que si hay un error lo capturaría el <code>.catch</code> de abajo.</li>
          <li class="chaptrSubSectUl__li"><strong>12 ·</strong> Añadimos un retraso de tiempo para que primero cargue la imagen y después se vea la operación que se hace sobre ella.</li>
          <li class="chaptrSubSectUl__li"><strong>13 ·</strong> Añadimos a la imagen un filtro.</li>
          <li class="chaptrSubSectUl__li"><strong>14 ·</strong> Resolvemos la promesa con un <span class="bttn">mensaje</span>.</li>
          <li class="chaptrSubSectUl__li"><strong>15 ·</strong> Después de 2,5seg de haber cargado la imagen se verá como se aplica el filtro.</li>
          <li class="chaptrSubSectUl__li"><strong>16 ·</strong> Una vez se resuelve la promesa se ejecuta este <code>.then</code> que trae como parámetro el <span class="bttn">mensaje</span>.</li>
          <li class="chaptrSubSectUl__li"><strong>17 ·</strong> Si la promesa falla muestra en consola el mensaje de error.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Manejo de errores" codeText="">
        <p class="chaptrSubSect__p">Cuando trabajamos con promesas, los errores se manejan usando <code>.catch()</code>. Si una promesa se rechaza o ocurre un error en cualquier parte de la cadena de promesas, <code>.catch()</code> captura ese error. Una de las grandes ventajas de usar promesas es que podemos manejar los errores en cualquier punto de la cadena. No necesitamos escribir un <code>.catch()</code> después de cada <code>.then()</code>, podemos colocarlo al final para manejar cualquier error que ocurra en la cadena.</p>
        <pre class="chaptrSubSect__console wScript">
          function @dividir(•a, •b) &#123;
            return new @Promise((@resolve, @reject) =&gt; &#123;
              if (•b === ¬0) &#123;
                @resolve(•a / •b);
              &#125; else &#123;
                @reject( new Error('/º División por cero no permitida º/') );
              &#125;
            &#125;);
          &#125;

          @dividir(¬10, ¬2)
            .then((•resultado) =&gt; &#123;
              console.log(`/º Resultado: $&#123;•resultado&#125; º/`);
              return @dividir(•resultado, ¬0);   /* División por cero */
            &#125;)
            .then((•resultado) =&gt; &#123;
              console.log(`/º Nuevo Resultado: $&#123;•resultado&#125; º/`);
            &#125;)
            .catch((•error) =&gt; &#123;
              console.ªerror(çerror.•message);
            &#125;);</pre>
        <p class="chaptrSubSect__p">⭐ A veces, puedes capturar un error, pero no puedes manejarlo completamente en el momento. En ese caso, puedes volver a lanzar (rethrow) el error para que otro <code>.catch()</code> más arriba lo maneje</p>
        <pre class="chaptrSubSect__console wScript">
          function @validarUsuario(·usuario) &#123;
            return new @Promise((@resolve, @reject) =&gt; &#123;
              if (!·usuario.•email) &#123;
                @reject( new Error('/º Falta el email º/'));
              &#125; else &#123;
                @resolve('/º Usuario válido º/');
              &#125;
            &#125;);
          &#125;

          @validarUsuario(&#123; nombre: 'Iker' &#125;)
            .catch((çerror) =&gt; &#123;
              console.warn(`/º Log interno: $&#123;çerror.message&#125; º/`);
              throw çerror;
            &#125;)
            .then((•mensaje) =&gt; &#123;
              console.log(•mensaje); // no se ejecuta
            &#125;)
            .catch((çerror) =&gt; &#123;
              console.ªerror(`/º Error mostrado al usuario: $&#123;error.message&#125; º/`);
            &#125;);</pre>
        <p class="chaptrSubSect__p"><code>throw</code> lanza un error, lo que provoca que la promesa se rechace de inmediato. Esto es similar a llamar a <code>reject()</code> con un error</p>
        <p class="chaptrSubSect__p">⭐ Rechazos no manejados. Si no agregas un <code>.catch()</code> y ocurre un error en tu cadena de promesas, el error no será manejado, lo que puede causar problemas en tu aplicación. Para evitar esto, puedes usar el evento <code>unhandledrejection</code> en el navegador, que captura cualquier promesa rechazada que no tenga un <code>.catch()</code>. El evento te permite detectar esos errores no manejados para hacer algo con ellos, como por ejemplo, mostrar un mensaje de error o guardarlo para reportarlo</p>
        <pre class="chaptrSubSect__console wScript">
          çwindow.addEventListener('unhandledrejection', (çevent) =&gt; &#123;
            console.ªerror(`/º ⚠️ Promesa rechazada sin .catch(): $&#123;event.reason.message&#125; º/`);
          &#125;);

          /*/º Promesa SIN .catch() º/*/
          new @Promise((@resolve, @reject) =&gt; &#123;
            @reject( new Error('/º Fallo crítico en la promesa! º/') );
          &#125;);

          /*/º Otra promesa sin manejar º/*/
          çPromise.ªreject( new Error('/º Otro error sin .catch() º/'));</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Promise API" codeText="Promise.all">
        <p class="chaptrSubSect__p">Toma un array de promesas <code>requests</code> y devuelve una nueva promesa que <b>se resuelve cuando todas las promesas en el array se han completado</b>. Si alguna solicitud falla, <code>Promise.all</code> rechazará con un error, y se manejará más adelante en el código con un <code>.catch()</code></p>
        <pre class="chaptrSubSect__console wScript">
          const ·promesa1 = çPromise.@resolve(¬5);  /*/º se resuelve inmediatamente con 5 º/*/

          const ·promesa2 = new çPromise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(¬10), ¬500); /*/º se resuelve en 0.5s con 10 º/*/
          &#125;);

          const ·promesa3 = new çPromise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(¬15), ¬1000); /*/º se resuelve en 1s con 15 º/*/
          &#125;);

          çPromise.@all([·promesa1, ·promesa2, ·promesa3])
            .then((·resultados) =&gt; &#123;
              console.log(`/º Resultados: $&#123;resultados&#125; º/`); /*/º "Resultados: 5, 10, 15" º/*/
            &#125;)
            .catch((çerror) =&gt; &#123;
              console.ªerror(`/º Error en una de las promesas: $&#123;error&#125; º/`);
            &#125;);</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Promise API" codeText="Promise.allSetlled">
        <p class="chaptrSubSect__p">Rechaza como un todo si cualquiera de sus promesas es rechazada, <b>siempre esperará a que todas las promesas se resuelvan</b>, ya sea de manera exitosa o con un error, y devolverá un array que contiene el estado y el resultado de cada promesa (ya sea resuelta o rechazada). Esto es bueno para los casos de “todo o nada”, cuando necesitamos proceder aunque haya promesas rechazadas</p>
        <pre class="chaptrSubSect__console wScript">
          const ·promesa1 = çPromise.@resolve(¬5);

          const ·promesa2 = new çPromise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(¬10), ¬500);
          &#125;);

          const ·promesa3 = new @Promise((_, @reject) =&gt; &#123;
            @setTimeout(() =&gt; @reject( new Error('/º Falló la promesa 3 º/')), ¬800);
          &#125;);

          çPromise.@allSettled([•promesa1, •promesa2, •promesa3])
            .then((·resultados) =&gt; &#123;
              console.log(`Resultados: $&#123;resultados&#125;`);

              ·resultados.forEach((·resultado) =&gt; &#123;
                  console.log(·resultado.•status)
              &#125;);
            &#125;);
          
          /*/º Resultados: [ º/*/
            /*/º &#123; status: 'fulfilled', value: 5 &#125;, º/*/
            /*/º &#123; status: 'fulfilled', value: 10 &#125;, º/*/
            /*/º &#123; status: 'rejected', reason: º/ /ºError : Falló la promesa 3 &#125; º/*/
          /*/º ] º/*/
          /*/º fulfilled º/*/
          /*/º fulfilled º/*/
          /*/º rejected º/*/
          </pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Promise API" codeText="Promise.race">
        <p class="chaptrSubSect__p">Devuelve una promesa que se resuelve o se rechaza con el resultado de la primera promesa que termine (ya sea con éxito o error)</p>
        <pre class="chaptrSubSect__console wScript">
          const ·promesa1 = çPromise.@resolve(¬5);

          const ·promesa2 = new çPromise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(¬10), ¬500);
          &#125;);

          const ·promesa3 = new @Promise((_, @reject) =&gt; &#123;
            @setTimeout(() =&gt; @reject( new Error('/º Falló la promesa 3 º/')), ¬800);
          &#125;);

          çPromise.@race([·promesa1, ·promesa2, ·promesa3])
            .then((·resultado) =&gt; &#123;
              console.log(`/º Ganadora: $&#123;·resultado&#125; º/`);
            &#125;)
            .catch((çerror) =&gt; &#123;
              console.ªerror(`/º Error : $&#123;error.message&#125; º/`);
            &#125;);

          /*/º Ganadora: 5 º/*/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Promise API" codeText="Promise.any">
        <p class="chaptrSubSect__p">Similar a <code>Promise.race</code>, solo se resuelve cuando al menos una de las promesas se resuelve correctamente, ignorando cualquier promesa que falle. Si todas las promesas fallan, entonces devuelve un error</p>
        <pre class="chaptrSubSect__console wScript">
          const ·promesa1 = new @Promise((_, @reject) =&gt; &#123;
            @setTimeout(() =&gt; @reject( new Error('/º Falló promesa 1 º/')), ¬300);
          &#125;);

          const ·promesa2 = new @Promise((_, @reject) =&gt; &#123;
            @setTimeout(() =&gt; @reject( new Error('/º Falló promesa 2 º/')), ¬500);
          &#125;);

          const ·promesa3 = new çPromise((@resolve) =&gt; &#123;
            @setTimeout(() =&gt; @resolve(`/º Promesa 3 cumplida! 🎉 º/`), ¬800);
          &#125;);

          çPromise.@any([·promesa1, ·promesa2, ·promesa3])
            .then((·resultado) =&gt; &#123;
              console.log(`/º 1ª Promesa cumplida: $&#123;·resultado&#125; º/`);
            &#125;)
            .catch((çerror) =&gt; &#123;
              console.ªerror(`/º Error : $&#123;error.message&#125; º/`);
            &#125;);

          /*/º 1ª Promesa cumplida: Promesa 3 cumplida! 🎉 º/*/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_26" nextPage="/lessons/lesson_28"/>
</MainLayout>

<!-- 
&lt;&gt;          < > no estilados
()&#123;&#125;    ( ) { } no estilados
﹛﹜              { } Llaves no estilados
﹕                : 2 puntos no estilados
＃                # Rejilla no estilada

ªmétodos
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">

-->
