---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__26" h2Title="Callbacks" slot="mainContent">
    <ChaptrSect h3Title="Las Callbacks" codeText="">
      <ChaptrSubSect h4Title="Introducción" codeText="">
        <p class="chaptrSubSect__p">Un <span class="bttn">Callback</span> es una función que se pasa como argumento a otra función y se ejecuta después de que la primera función haya completado su tarea. Esto permite que el código se ejecute de manera asíncrona, es decir, sin bloquear la ejecución de otras operaciones</p>
        <pre class="chaptrSubSect__console wScript">
          function @fnName(#parametro, @callback)&#123;
            /*/º Código de la función º/*/
            @callback();
          &#125;;</pre>
        <p class="chaptrSubSect__p">Veamos un ejemplo del mundo real de acciones asincrónicas, p. ej.: la carga de scripts y módulos (a cubrirse en capítulos posteriores).</p>
        <pre class="chaptrSubSect__console wScript">
          function @loadScript(#src)&#123;    /* ➀ */
            let ·script = document.createElement('script');    /* ➁ */
            ·script.•src = #src;   /* ➂ */
            document.•head.append(#script);   /* ➃ */
          &#125;;</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>➀</strong>: La función <code>loadScript</code> acepta un argumento <code>src</code>, el cual representa la URL del archivo JavaScript externo que desea cargar.</li>
          <li class="chaptrSubSectUl__li"><strong>➁</strong>: Se crea dinámicamente una etiqueta <code>&lt;script&gt;</code> utilizando el método <code>document.createElement()</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>➂</strong>: El archivo JavaScript que se desea cargar se especifica al establecer el atributo <code>src</code> del nuevo elemento <code>&lt;script&gt;</code>. El valor de <code>src</code> proviene del argumento pasado a la función <code>loadScript</code>.</li>
          <li class="chaptrSubSectUl__li"><strong>➃</strong>: La etiqueta <code>&lt;script&gt;</code> creada se inserta en el elemento <code>&lt;head&gt;</code> del documento mediante el método <code>append()</code>. Esto añade el <code>&lt;script&gt;</code> al DOM (Document Object Model), lo que hace que el navegador comience a descargar y ejecutar el archivo JavaScript especificado en <code>src</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Esto inserta en el documento una etiqueta nueva, creada dinámicamente, <code>&lt;script src = "..."&gt;</code> con el código <code>src</code> dado. El navegador comienza a cargarlo automáticamente y lo ejecuta cuando la carga se completa.</p>
        <pre class="chaptrSubSect__console wScript">
          /*/º cargar y ejecutar el script en la ruta dada º/*/
          @loadScript('/º /my/script.js º/');
          
          /*/º Funcion dentro del archivo script.js º/*/
          @newFunction();       ⋗ /º error, no existe! º/</pre>
        <p class="chaptrSubSect__p">El script se ejecuta “asincrónicamente”, ya que comienza a cargarse ahora, pero se ejecuta más tarde, cuando la función ya ha finalizado. El código debajo de <code>loadScript (...)</code>, no espera que finalice la carga del script.</p>
        <p class="chaptrSubSect__p">Digamos que necesitamos usar el nuevo script tan pronto como se cargue. Este script declara nuevas funciones, y las queremos ejecutar. Si lo hacemos inmediatamente después de llamar a <code>loadScript (...)</code>, no funcionarán:</p>
        <p class="chaptrSubSect__p">Agreguemos a <code>loadScript</code> un segundo argumento: una función <span class="bttn">callback</span> que se ejecuta cuando se completa la carga el script</p>
        <pre class="chaptrSubSect__console wScript">
          function @loadScript(#src, @callback)&#123;
            let ·script = document.createElement('script');
            ·script.•src = #src;
            ·script.ªonload = () =&gt; @callback(#script);
            document.•head.append(#script);
          &#125;;</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Ejemplos síncronos" codeText="">
        <p class="chaptrSubSect__p">Vamos con un ejemplo sencillo</p>
        <pre class="chaptrSubSect__console wScript">
          const ·operation = @function(#num1, #num2, @callback)&#123;
              return @callback(#num1, #num2);
          &#125;;

          function @suma(#num1, #num2)&#123;
            return #num1 + #num2;
          &#125;;
        
          const ·result = @operation(¬5, ¬4, @suma);
          console.log(·result);
          ⋗ /º 9 º/</pre>
        <p class="chaptrSubSect__p">Y con otro muy visual</p>
        <pre class="chaptrSubSect__console wScript">
          const ·saludar = @function(#name, @callback)&#123;
              return @callback(#name);
          &#125;;

          function @saludoFormal(#name)&#123;
            console.log(`/º Buenas tardes, mi nombre es $&#123;#name&#125; º/`);
          &#125;;
        
          @saludar('/º Éder º/', @saludoFormal);
          ⋗ /º 'Buenas tardes, mi nombre es Éder' º/</pre>
        <p class="chaptrSubSect__p">(*) Cuando escribes <code>saludoFormal</code>, estás pasando la función misma como argumento para que <code>saludar</code> la ejecute más tarde. Si escribieras <code>saludoFormal()</code>, estarías ejecutando la función inmediatamente y pasando su resultado (que en este caso sería undefined porque <code>saludoFormal</code> no retorna nada) a <code>saludar</code></p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Ejemplos asíncronos" codeText="">
        <p class="chaptrSubSect__p">Este ejemplo es asíncrono</p>
        <pre class="chaptrSubSect__console wScript">
          console.log(`/º Hola, ¿Cómo se llama usted? º/`);

          const ·saludar = @function(#name, @callback)&#123;
            return @setTimeout(() =&gt; &#123;
              @callback(#name)
              &#125;, ¬3000)
          &#125;;

          console.log(`/º Esperando respuesta...º/`)

          function @saludoFormal(#name)&#123;
            console.log(`/º Hola, mi nombre es $&#123;name&#125; º/`)
          &#125;;
        
          @saludar('/º Éder º/', @saludoFormal);
          ⋗ /º Hola, ¿Cómo se llama usted? º/
          ⋗ /º Esperando respuesta... º/
          ⋗ /º Hola, mi nombre es Éder º/       /*/º después de 3seg º/*/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Manejo de errores" codeText="">
        <p class="chaptrSubSect__p">¿Qué pasa si falla la carga del script? Nuestra callback debería poder reaccionar ante eso. Utilizaremos el <mark>error first callback</mark>. Aquí una versión mejorada de <code>loadScript</code> que monitorea los errores de carga:</p>
        <pre class="chaptrSubSect__console wScript">
          function @loadScript(#src, @callback)&#123;
            let ·script = document.createElement('script');
            ·script.•src = #src;
            ·script.ªonload = () =&gt; @callback(null, ·script);
            ·script.ªonerror = () =&gt; @callback( new Error(`/º Error de carga con $&#123;src&#125;º/`));
            document.•head.append(·script);
          &#125;;</pre>
        <p class="chaptrSubSect__p">Para una carga exitosa llama a <code>callback(null, script)</code> y de lo contrario a <code>callback(error)</code></p>
        <pre class="chaptrSubSect__console wScript">
          @loadScript('/º /my/script.js º/', @function(çerror, ·script) &#123;
            if(çerror) &#123;
              /*/º maneja el error º/*/
            &#125; else &#123;
              /*/º script cargado exitosamente º/*/
            &#125;
          &#125;);</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Callback Hell" codeText="">
        <p class="chaptrSubSect__p">A medida que las llamadas se anidan más, el código se vuelve más profundo y difícil de administrar, que puede incluir más bucles, declaraciones condicionales, etc. A esto se le llama “infierno de callbacks” o “pirámide infernal” (“callback hell”, “pyramid of doom”).</p>
        <pre class="chaptrSubSect__console wScript">
          function @task1(@callback)&#123;
             @setTimeout(() => &#123;
              console.log(`Suena el despertador`);
            &#125;, ¬1000);
             @callback();
          &#125;;

          function @task2(@callback)&#123;
           @setTimeout(() =&gt; &#123;
            console.log(`Me levanto y voy a mear`);
            &#125;, ¬2000);
             @callback();
          &#125;;

          function @task3(@callback)&#123;
           @setTimeout(() =&gt; &#123;
            console.log(`Me visto`);
            &#125;, ¬3000);
             @callback();
          &#125;;

          function @task4(@callback)&#123;
           @setTimeout(() =&gt; &#123;
            console.log(`Preparo un café`);
            &#125;, ¬4000);
             @callback();
          &#125;;

          function @task5(@callback)&#123;
           @setTimeout(() =&gt; &#123;
            console.log(`Mientras bebo el café miro el móvil`);
            &#125;, ¬5000);
             @callback();
          &#125;;

          function @task6(@callback)&#123;
           @setTimeout(() =&gt; &#123;
            console.log(`Me voy a trabajar`);
            &#125;, ¬6000);
             @callback();
          &#125;;

          @task1(() =&gt; &#123;
            @task2(() =&gt; &#123;
              @task3(() =&gt; &#123;
                @task4(() =&gt; &#123;
                  @task5(() =&gt; &#123;
                    @task6(() =&gt; &#123;
            
                      &#125;);
                    &#125;);
                  &#125;);
                &#125;);
              &#125;);
          &#125;);
        
          ⋗ /º Suena el despertador º/
          ⋗ /º Me levanto y voy a mear º/
          ⋗ /º Me visto º/
          ⋗ /º Preparo un café º/
          ⋗ /º Mientras bebo el café miro el móvil º/
          ⋗ /º Me voy a trabajar º/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_23" nextPage="/lessons/lesson_27"/>
</MainLayout>






<!-- 
&lt;&gt;
()&#123;&#125;
﹛﹜    Llaves no estiladas
﹕     2 puntos no estilizados
ªmétodos
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ ∞Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">
＃
﹘
-->
