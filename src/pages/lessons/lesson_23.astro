---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__23" h2Title="Clases" slot="mainContent">
    <ChaptrSect h3Title="Sintaxis y buenas prÃ¡cticas" codeText="">
      <ChaptrSubSect h4Title="DefiniciÃ³n" codeText="">
        <p class="chaptrSubSect__p">Son una forma moderna y mÃ¡s estructurada de crear objetos y gestionar la herencia, introducida en ES6. Aunque bajo el capÃ³ siguen funcionando con prototipos, las clases proporcionan una sintaxis mÃ¡s clara y legible</p>
        <p class="chaptrSubSect__p">Se dice que <code>class</code> es <mark>azÃºcar sintÃ¡ctica</mark> (sintaxis que es diseÃ±ada para una lectura mÃ¡s fÃ¡cil, pero que no introduce nada nuevo), porque en realidad podemos declarar lo mismo sin la palabra clave <code>class</code></p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº Creamos la funciÃ³n constructora Âº/*/
          function Ã§User(#name) &#123;
            this.â€¢name = #name;
          &#125;

          /*/Âº Agregamos el mÃ©todo al prototipo Âº/*/
          Ã§User.â€¢prototype.ÂªsayHi = @function() &#123;
            console.log(this.#name);
          &#125;;

          /*/Âº Uso de la claseÂº/*/
          let Â·user = new Ã§User('Ã‰der');
          
          /*/Âº Ejecutamos metodo de instancia Âº/*/
          Â·user.ÂªsayHi(); 
          â‹— /Âº'Ã‰der'Âº/</pre>
        <p class="chaptrSubSect__p">QuÃ© es lo que sucede aquÃ­</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">La funciÃ³n <code>User</code> es una funciÃ³n constructora (usada con <code>new</code>).</li>
          <li class="chaptrSubSectUl__li">Su prototipo (<code>User.prototype</code>) almacena los mÃ©todos que comparten todas las instancias.</li>
          <li class="chaptrSubSectUl__li">Cuando creamos <code>new User("Ã‰der")</code>, el objeto resultante hereda de <code>User.prototype</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Y esta es la versiÃ³n moderna. Aunque parece completamente distinto, JavaScript lo transforma internamente casi igual que en el ejemplo anterior con funciones y prototipos</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº DefiniciÃ³n de clase Âº/*/
          class Ã§User &#123;
            constructor(#name) &#123;
              this.â€¢name = #name;
            &#125;

            @sayHi() &#123;
              console.log(this.#name);
            &#125;
          &#125;

          /*/Âº Uso Âº/*/
          let Â·user = new Ã§User('Ã‰der');
          
          Â·user.ÂªsayHi(); 
          â‹— /Âº'Ã‰der'Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Sintaxis" codeText="">
        <p class="chaptrSubSect__p">Sintaxis bÃ¡sica</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§MyClass &#123;
            /*/Âº Se ejecuta automaticamente al crear una nueva instancia Âº/*/
            @constructor() &#123;
              /*/Âº InicializaciÃ³n de propiedades Âº/*/
            &#125;

            /*/Âº MÃ©todos de la clase Âº/*/
            @method1() &#123; ... &#125;
            @method2() &#123; ... &#125;
          &#125;</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Una clase solo puede tener un <mark>constructor</mark>.</li>
          <li class="chaptrSubSectUl__li">Los mÃ©todos se aÃ±aden automÃ¡ticamente al <mark>prototype</mark> del objeto creado.</li>
          <li class="chaptrSubSectUl__li">Dentro de los mÃ©todos, <mark>this</mark> hace referencia a la instancia del objeto.</li>
        </ul>
        <p class="chaptrSubSect__p">En realidad, una clase es una funciÃ³n, concretamente el cuerpo del constructor</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§MyClass &#123;
            @constructor() &#123;&#125;
            @sayHi() &#123;&#125;
          &#125;

          /*/Âº Una clase es una funciÃ³n Âº/*/
          console.log(typeof Ã§MyClass); 
          â‹— /Âº'function'Âº/

          /*/Âº Su constructor es el mÃ©todo que actÃºa como esa funciÃ³n Âº/*/
          console.log(Ã§MyClass === Ã§MyClass.â€¢prototype.constructor); 
          â‹— /ÂºtrueÂº/

          /*/Âº Los mÃ©todos se almacenan en el prototipo Âº/*/
          console.log(Ã§MyClass.â€¢prototype.ÂªsayHi); 
          â‹— /ÂºÆ’ sayHi() &#123;&#125;Âº/

          /*/Âº Podemos listar las propiedades del prototipo Âº/*/
          console.log(Object.ÂªgetOwnPropertyNames(Ã§MyClass.â€¢prototype)); 
          â‹— /Âº (2) ["constructor", "sayHi"] Âº/

          /*/Âº Los mÃ©todos se almacenan en el prototipo, no en la instancia Âº/*/
          console.log(Ã§MyClass.ÂªhasOwnProperty('sayHi')); 
          â‹— /ÂºfalseÂº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Diferencias funciÃ³n vs Clase" codeText="">
        <table class="chaptrSubSect__table">
          <thead>
            <tr>
              <th>Diferencia</th>
              <th>Func. Normal</th>
              <th>Clase</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Etiqueta interna</td>
              <td>No</td>
              <td>[[IsClassConstructor]]: true</td>
            </tr>
            <tr>
              <td>InvocaciÃ³n</td>
              <td>Directamente</td>
              <td>Con <b>new</b></td>
            </tr>
            <tr>
              <td>Enumerabilidad</td>
              <td>Enumerables</td>
              <td>No enumerables</td>
            </tr>
            <tr>
              <td>Modo estricto</td>
              <td>Opcional</td>
              <td>Siempre</td>
            </tr>
            <tr>
              <td>Contexto de <b>this</b></td>
              <td>Flexible (call, apply)</td>
              <td>Siempre apunta a la instancia</td>
            </tr>
          </tbody>
        </table>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Buenas prÃ¡cticas" codeText="">
        <p class="chaptrSubSect__p"><b>Un archivo por clase:</b> Cada clase debe tener su propio archivo, con su mismo nombre para facilitar la lectura y el mantenimiento del proyecto</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“ Animal.js Âº/*/

          export class Ã§Animal &#123;
            constructor(#nombre) &#123;
              this.â€¢nombre = #nombre;
            &#125;
          &#125;;</pre>
        <p class="chaptrSubSect__p">Para instanciar objetos basados en esa clase, se puede importar el fichero de la clase donde se necesite</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº ğŸ“ main.js Âº/*/

          import &#123; Ã§Animal &#125; from '/Âº ./Animal.js Âº/';

          const Â·perro = new Ã§Animal('Firulais');

          console.log(Â·perro.â€¢nombre); 
          â‹— /Âº'Firulais'Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="CreaciÃ³n" codeText="">
      <ChaptrSubSect h4Title="DeclaraciÃ³n literal" codeText="class">
        <p class="chaptrSubSect__p">Es la forma mÃ¡s habitual y recomendada. La sintaxis es directa y fÃ¡cil de leer.</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº DefiniciÃ³n de clase Âº/*/
          class Ã§Player &#123;
            /*/Âº Constructor se ejecuta automÃ¡ticamente al crear una instancia Âº/*/
            constructor(#name, #position) &#123;
              this.â€¢name = #name;       /*/Âº Propiedad de instancia Âº/*/
              this.â€¢position = #position;     /*/Âº Propiedad de instancia Âº/*/
            &#125;
            /*/Âº MÃ©todo de la clase compartido por todas las instancias Âº/*/
            @bestSkill() &#123;
              console.log(`/Âº $&#123;this.name&#125; tiene un gran pase! Âº/`);
            &#125;
          &#125;;

          /*/Âº CreaciÃ³n de instancia Âº/*/
          const Ã§player_11 = new Ã§Player('Ã‰der', 'LatDer');

          /*/Âº VerificaciÃ³n de instancia Âº/*/
          console.log(Ã§player_11);
          â‹— /Âº Player &#123;name: 'Ã‰der', position: 'LatDer'&#125; Âº/

          /*/Âº Uso de mÃ©todo Âº/*/
          Ã§player_11.ÂªbestSkill();
          â‹— /Âº"Ã‰der tiene un gran pase!"Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="ExpresiÃ³n de clase anÃ³nima" codeText="">
        <p class="chaptrSubSect__p">Una clase anÃ³nima es aquella que no tiene nombre propio y se asigna directamente a una variable. Se usa cuando queremos crear una clase de forma mÃ¡s flexible o condicional, sin necesidad de declararla explÃ­citamente con <code>class NombreClase &#123;&#125;..</code></p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§Player = class &#123;          /*/Âº Clase anÃ³nima asignada a una variable Âº/*/
            constructor(#name, #position) &#123;
              this.â€¢name = #name;
              this.â€¢position = #position;
            &#125;
            ÂªbestSkill() &#123;                 /*/Âº MÃ©todo de clase Âº/*/
              console.log(`/Âº $&#123;this.name&#125; centra muy bien! Âº/`);
            &#125;
          &#125;;

          /*/Âº CreaciÃ³n de instancia Âº/*/
          const Ã§player_8 = new Ã§Player('Ã‰der', Â¬5, 'MedDer');

          /*/Âº Uso de mÃ©todo Âº/*/
          Ã§player_8.ÂªbestSkill();
          â‹— /Âº"Ã‰der centra muy bien!"Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="ExpresiÃ³n de clase nombrada" codeText="">
        <p class="chaptrSubSect__p">Su utilidad se basa en la auto-referencia dentro de la clase, se puede referir a la propia clase desde dentro del cuerpo de la clase usando su nombre, lo que no se puede hacer con una expresiÃ³n de clase anÃ³nima.</p>
        <p class="chaptrSubSect__p">Tienen una mejor depuraciÃ³n, al usar una clase nombrada, los errores en tiempo de ejecuciÃ³n mostrarÃ¡n un nombre Ãºtil en los rastreos de pila (stack traces). En el caso de una expresiÃ³n de clase anÃ³nima, a veces es mÃ¡s difÃ­cil identificar el origen del problema</p>
        <pre class="chaptrSubSect__console wScript">
          const Ã§Player = class Ã§FootballPlayer &#123;          /*/Âº Clase anÃ³nima asignada a una variable Âº/*/
            constructor(#name, #position) &#123;
              this.â€¢name = #name;
              this.â€¢position = #position;
            &#125;
            ÂªbestSkill() &#123;                 /*/Âº MÃ©todo de clase Âº/*/
              console.log(`/Âº $&#123;this.name&#125; centra muy bien! Âº/`);
            &#125;
          &#125;;

          /*/Âº CreaciÃ³n de instancia Âº/*/
          const Ã§player_8 = new Ã§Player('Ã‰der', Â¬5, 'MedDer');

          /*/Âº Uso de mÃ©todo Âº/*/
          Ã§player_8.ÂªbestSkill();
          â‹— /Âº"Ã‰der centra muy bien!"Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="DinÃ¡micamente" codeText="">
        <p class="chaptrSubSect__p">Puedes crear clases dinÃ¡micamente usando una funciÃ³n, generando una clase segÃºn ciertos parÃ¡metros o condiciones</p>
        <pre class="chaptrSubSect__console wScript">
          function @createPlayerClass(#type) &#123;
            return Ã§class &#123;
              constructor(#name) &#123;
                this.â€¢name = #name;
                this.â€¢type = #type;
              &#125;
              Âªdescribe() &#123;
                console.log(`/Âº $&#123;this.name&#125; es un $&#123;this.type&#125; Âº/`);
              &#125;
            &#125;;
          &#125;;

          /*/Âº Crear clases especÃ­ficas dinÃ¡micamente Âº/*/
          const Ã§Defender = @createPlayerClass('Mediocampista');

          /*/Âº Crear instancias de las clases generadas Âº/*/
          const Â·player_18 = new Ã§Defender('Ã‰der');

          /*/Âº Uso de mÃ©todo Âº/*/
          Â·player_18.Âªdescribe();
          â‹— /Âº"Ã‰der es un Mediocampista"Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Miembros de una clase" codeText="">
      <ChaptrSubSect h4Title="El constructor" codeText="">
        <p class="chaptrSubSect__p">Es un <mark>mÃ©todo</mark> que se ejecuta automÃ¡ticamente cuando se crea una nueva instancia de una clase utilizando la palabra clave <code>new</code>. <b>Inicializa las propiedades del nuevo objeto</b>. Cada clase sÃ³lo puede tener un  constructor</p>
        <p class="chaptrSubSect__p">Si no defines un constructor en una clase, JavaScript crea uno implÃ­cito para ti. Este constructor por defecto no acepta parÃ¡metros y simplemente inicializa la instancia sin aÃ±adir propiedades</p>
        <pre class="chaptrSubSect__console wScript">
          /* Sintaxis bÃ¡sica */
          class Ã§Player &#123;
            constructor(#params) &#123;               /* Se ejecuta al crear nueva instancia */
              this.â€¢props = #params;               /* Inicializa propiedades */
            &#125;
          &#125;</pre>
        <p class="chaptrSubSect__p"><span class="bttn">Constructor implicito:</span> Si no defines un constructor, JavaScript crea uno automÃ¡ticamente</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Team &#123;
            /*/Âº No hay constructor definido Âº/*/
          &#125;

          /*/Âº Se crea un nuevo objeto Team sin pasar parÃ¡metros Âº/*/
          const Ã§myTeam = new Ã§Team();

          console.log(Ã§myTeam);
          â‹— /Âº Team &#123;&#125; Âº/</pre>
        <p class="chaptrSubSect__p"><span class="bttn">Constructor con valores por defecto:</span> Puedes asignar valores por defecto a los parÃ¡metros del constructor. Esto permite crear instancias sin necesidad de pasar todos los argumentos.</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Player &#123;
            constructor(#name = 'Desconocido', #position = 'Desconocida') &#123;
              this.â€¢name = #name;
              this.â€¢position = #position;
            &#125;

            Âªinfo() &#123;
              console.log(`Nombre: $&#123;this.name&#125;, PosiciÃ³n: $&#123;this.position&#125;`);
            &#125;
          &#125;;

          /*/Âº Instancia con valores personalizados Âº/*/
          const Ã§player_7 = new Ã§Player('Iker', 'Mediocentro');
          Ã§player_7.Âªinfo();
          â‹— /Âº "Nombre: Iker, PosiciÃ³n: Mediocentro" Âº/

          /*/Âº Instancia con valores por defecto Âº/*/
          const Ã§player_99 = new Ã§Player();
          Ã§player_99.Âªinfo();
          â‹— /Âº "Nombre: Desconocido, PosiciÃ³n: Desconocida" Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Tipos de propiedades" codeText="">
        <p class="chaptrSubSect__p"><mark>Propiedades de Clase</mark></p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Pertenecen a la clase en sÃ­, no a las instancias.</li>
          <li class="chaptrSubSectUl__li">Se accede con <code>NombreClase.propiedad</code>.</li>
        </ul>
        <p class="chaptrSubSect__p"><mark>Propiedades de Instancia</mark></p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Pertenecen a cada objeto creado con <code>new</code>.</li>
          <li class="chaptrSubSectUl__li">Se accede con <code>instancia.propiedad</code>.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="CategorÃ­as de propiedades" codeText="">
        <p class="chaptrSubSect__p"><mark>Propiedades de Clase</mark> o tambiÃ©n llamadas <b>Propiedades estÃ¡ticas</b></p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>EstÃ¡tica:</strong> <code>static</code> Se accede directamente desde la clase, no desde las instancias.</li>
          <li class="chaptrSubSectUl__li"><strong>Privada:</strong> <code>#</code> Igual que la estÃ¡tica, pero solo accesible dentro de la clase.</li>
          <li class="chaptrSubSectUl__li"><strong>PÃºblica:</strong> (Rara vez usada) SerÃ­a una propiedad estÃ¡tica sin #, accesible desde fuera.</li>
        </ul>
        <p class="chaptrSubSect__p"><mark>Propiedades de Instancia</mark></p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><strong>PÃºblica:</strong> Visible y modificable desde fuera.</li>
          <li class="chaptrSubSectUl__li"><strong>Privada:</strong> <code>#</code> Solo accesible dentro de la clase.</li>
          <li class="chaptrSubSectUl__li"><strong>Protegida:</strong> <code>_</code> ConvenciÃ³n (no real), indica que no deberÃ­as accederla fuera de la clase.</li>
          <li class="chaptrSubSectUl__li"><strong>Computada:</strong> <code>getter/setter</code> No almacena datos directamente, sino que calcula o controla el acceso a una propiedad.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Propiedades de clase static pÃºblica" codeText="">
        <p class="chaptrSubSect__p">Estas propiedades pertenecen a la clase misma, no a los objetos creados con ella. Se acceden directamente desde el nombre de la clase, sin necesidad de instanciar. Sirven para guardar informaciÃ³n comÃºn a todas las instancias, como contadores, configuraciones globales o valores compartidos.</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Team &#123;
            static â€¢sport = 'FÃºtbol';          /*/Âº Propiedad de clase estÃ¡tica Âº/*/
          &#125;

          /*/Âº Se accede directamente desde la clase Âº/*/
          console.log(Ã§Team.â€¢sport);         â‹— /Âº "FÃºtbol" Âº/

          /*/Âº No se puede acceder desde una instancia Âº/*/
          const Ã§myTeam = new Ã§Team();
          console.log(Ã§myTeam.â€¢sport);        â‹— /Âº undefined Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Propiedades de clase static privada" codeText="">
        <p class="chaptrSubSect__p">Estas propiedades pertenecen a la clase misma, no a los objetos creados con ella. No estÃ¡ permitido acceder a ella</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Team &#123;
            static ï¼ƒâ€¢teamCount = Â¬0;        /*/Âº Propiedad de clase estÃ¡tica y privada Âº/*/

            constructor() &#123;
              Ã§Team.ï¼ƒâ€¢teamCount++;          /*/Âº Al crear nueva instancia aumenta el contador Âº/*/
            &#125;

            /*/Âº MÃ©todo estÃ¡tico pÃºblico para acceder al valor privado Âº/*/
            static ÂªgetTeamCount() &#123;
              return Ã§Team.ï¼ƒâ€¢teamCount;
            &#125;
          &#125;

          /*/Âº Creamos algunas instancias Âº/*/
          new Ã§Team();
          new Ã§Team();

          /*/Âº Acceso correcto mediante el mÃ©todo pÃºblico Âº/*/
          console.log(Ã§Team.ÂªgetTeamCount());
          â‹— /Âº 2 Âº/

          /Âº/* Acceso directo prohibido Âº/*/
          console.log(Ã§Team.ï¼ƒâ€¢teamCount); 
          â‹— /Âº SyntaxError : Private field "ï¼ƒteamCount" Âº/
          /Âº must be declared in an enclosing class Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Propiedades de clase static computadas" codeText="">
        <p class="chaptrSubSect__p">Permiten controlar el acceso o cÃ¡lculo de una propiedad estÃ¡tica de la clase. En lugar de almacenar directamente un valor, se calcula o gestiona mediante mÃ©todos <code>get</code> y <code>set</code> declarados como <code>static</code>.</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Team &#123;
            static ï¼ƒâ€¢wins = Â¬0;                      /*/Âº Propiedad de clase privada Âº/*/

            static get ÂªtotalWins() &#123;                  /*/Âº Getter estÃ¡tico Âº/*/
              return `El equipo lleva $&#123;Ã§Team.ï¼ƒâ€¢wins&#125; victorias`;
            &#125;

            static set ÂªaddWin(#value) &#123;               /*/Âº Setter estÃ¡tico Âº/*/
              if (#value &gt; Â¬0) Ã§Team.ï¼ƒâ€¢wins += #value;
            &#125;
          &#125;

          /*/Âº Uso del setter y getter estÃ¡ticos Âº/*/
          Ã§Team.ÂªaddWin = Â¬3;

          console.log(Ã§Team.ÂªtotalWins);
          â‹— /Âº "El equipo lleva 3 victorias" Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Propiedades de instancia pÃºblicas" codeText="">
        <p class="chaptrSubSect__p">Propiedades declaradas directamente en la clase (sintaxis moderna)</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Las propiedades se definen directamente en la clase, fuera del constructor.</li>
          <li class="chaptrSubSectUl__li">Se inicializan automÃ¡ticamente cuando haces <code>new Player()</code>.</li>
          <li class="chaptrSubSectUl__li">No necesitas escribir <code>this.</code> dentro del constructor.</li>
          <li class="chaptrSubSectUl__li">El cÃ³digo es mÃ¡s limpio y declarativo.</li>
          <li class="chaptrSubSectUl__li">JavaScript internamente crea esas propiedades en la instancia, no en el prototipo.</li>
          <li class="chaptrSubSectUl__li">Todas las instancias tendrÃ¡n esas propiedades (aunque con valor <code>undefined</code> si no se asigna).</li>
          <li class="chaptrSubSectUl__li">No se pueden modificar con <code>NombreClase.propiedad</code> puesto que eso crearÃ¡ una <b>nueva</b> propiedad de clase <mark>estÃ¡tica</mark>.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Player &#123;
            Â·canterano;                    /*/Âº Propiedad de instancia pÃºblica Âº/*/
            Â·mayorEdad;
            constructor()&#123;
            &#125;
          &#125;

          const Ã§jugador_11 = new Ã§Character();

          Ã§jugador_11.Â·canterano = true;

          console.log(Ã§jugador_11);
          â‹— /Âº Player &#123; canterano: true, mayorEdad: undefined &#125;Âº/</pre>
        <p class="chaptrSubSect__p">Propiedades declaradas dentro del constructor (sintaxis tradicional)</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Es la forma tradicional (ES6).</li>
          <li class="chaptrSubSectUl__li">Las propiedades se crean dinÃ¡micamente dentro del constructor al usar <code>this</code>.</li>
          <li class="chaptrSubSectUl__li">Permite inicializar con valores pasados como parÃ¡metros.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Player &#123;
            constructor(#name, #position)&#123;
              this.â€¢name = #name;
              this.â€¢position = #position;
            &#125;
          &#125;

          const Ã§jugador_11 = new Ã§Character('Eder', 'MedDer');

          console.log(Ã§jugador_11);
          â‹— /Âº Player &#123; name: 'Eder', position: 'MedDer' &#125;Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Propiedades de instancia privadas" codeText="#">
        <p class="chaptrSubSect__p">Propiedades declaradas directamente en la clase (sintaxis moderna)</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Player &#123;
            ï¼ƒâ€¢salario = Â¬0;                    /*/Âº Propiedad de instancia privada Âº/*/
            ï¼ƒâ€¢edad = Â¬0;
          &#125;

          const Ã§jugador_11 = new Ã§Player();

          Ã§jugador_11.ï¼ƒâ€¢salario = Â¬10000;

          console.log(Ã§jugador_11);
          â‹— /Âº Player &#123; ï¼ƒsalario: 10000, ï¼ƒedad: 0 &#125;Âº/</pre>
        <p class="chaptrSubSect__p">Propiedades declaradas dentro del constructor (sintaxis tradicional)</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Se definen las propiedades en el constructor, pasÃ¡ndoles valores dinÃ¡micos (por parÃ¡metros).</li>
          <li class="chaptrSubSectUl__li">Se deben declarar antes con <code>#salario</code>; <code>#edad</code>; en la <mark>clase</mark>para que el cÃ³digo sea vÃ¡lido.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Player &#123;
            ï¼ƒâ€¢salario = Â¬0;                    /*/Âº Deben declararse primero aquÃ­ Âº/*/
            ï¼ƒâ€¢edad = Â¬0;
            constructor(#name, #edad, #salario)&#123;
              this.â€¢name = #name;
              this.ï¼ƒâ€¢edad = #edad;
              this.ï¼ƒâ€¢salario = #salario;
            &#125;
          &#125;

          const Ã§jugador_11 = new Ã§Player('Ã‰der', Â¬4, Â¬50000);

          console.log(Ã§jugador_11);
          â‹— /Âº Player &#123; name: "Ã‰der", ï¼ƒedad: 4, ï¼ƒsalario: 50000 &#125;Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Propiedades de instancia protegidas" codeText="_">
        <p class="chaptrSubSect__p">JavaScript no tiene propiedades protegidas reales, pero por convenciÃ³n se utiliza el guion bajo (<code>_</code>) al inicio del nombre para indicar que una propiedad no deberÃ­a ser accedida directamente desde fuera de la clase, aunque tÃ©cnicamente sÃ­ se puede. Esto sirve para marcar internamente propiedades â€œsensiblesâ€ o â€œde uso internoâ€, que se espera que solo sean manipuladas por la propia clase o por sus subclases</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Player &#123;
            _energia = Â¬100;                    /*/Âº Propiedad "protegida" por convenciÃ³n Âº/*/
            constructor(#name)&#123;
              this.â€¢name = #name;
            &#125;
          &#125;

          const Ã§jugador_11 = new Ã§Player('Ã‰der');

          console.log(Ã§jugador_11);
          â‹— /Âº Player &#123; ï¹˜energia: 100, name: "Ã‰der" &#125;Âº/
        
          Ã§jugador_11._energia = 125;     /*/Âº Se puede pero no se debe Âº/*/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Propiedades de instancia computadas" codeText="">
        <p class="chaptrSubSect__p"><mark>Getters:</mark> Un <code>getter</code> permite leer una propiedad como si fuera un valor normal, pero en realidad ejecuta una funciÃ³n que devuelve el resultado. Sirve para mostrar informaciÃ³n calculada o derivada sin necesidad de almacenarla fÃ­sicamente</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Player &#123;
            ï¼ƒâ€¢goles = Â¬0;                        /*/Âº Propiedad de instancia privada Âº/*/

            constructor(#name, #partidos) &#123;
              this.â€¢name = #name;                 /*/Âº Propiedades de instancia Âº/*/
              this.â€¢partidos = #partidos;
            &#125;

            get ÂªpromedioGoles() &#123;           /*/Âº Getter de instancia Âº/*/
              if(this.â€¢partidos === Â¬0) &#123;
                return `/Âº $&#123;this.name&#125; no jugÃ³ ningun partido Âº/`;
              &#125;
              return `/Âº Ã‰der promedia $&#123;(this.ï¼ƒâ€¢goles / this.â€¢partidos).toFixed(Â¬2)&#125; goles Âº/`;
            &#125;

            ÂªmarcarGol() &#123;               /*/Âº MÃ©todo de instancia Âº/*/
              this.ï¼ƒâ€¢goles++;
              console.log(`/Âº $&#123;this.â€¢name&#125; anotÃ³ Gol! Âº/`);
            &#125;
          &#125;

          const Ã§player_10 = new Ã§Player('Ã‰der', Â¬4);

          Ã§player_10.ÂªmarcarGol();
          Ã§player_10.ÂªmarcarGol();
          Ã§player_10.ÂªmarcarGol();

          console.log(Ã§player_10.ÂªpromedioGoles);
          â‹— /Âº "Ã‰der promedia 0.75 goles" Âº/</pre>
        <p class="chaptrSubSect__p"><mark>Setters:</mark> Un <code>setter</code> permite controlar cÃ³mo se asigna un valor a una propiedad. Es ideal para validar datos, formatear valores, o actualizar varias propiedades relacionadas</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Player &#123;
            ï¼ƒâ€¢goles = Â¬0;                        /*/Âº Propiedad de instancia privada Âº/*/

            constructor(#name) &#123;
              this.â€¢name = #name;                 /*/Âº Propiedades de instancia Âº/*/
            &#125;

            set Âªgoles(#valor) &#123;           /*/Âº Setter de instancia Âº/*/
              if(#valor &lt; Â¬0) &#123;
                console.log(`/Âº No se pueden asignar goles negativos Âº/`);
              &#125; else &#123;
                this.ï¼ƒâ€¢goles = #valor;
              &#125;
            &#125;

            get Âªgoles() &#123;               /*/Âº Getter de instancia Âº/*/
              return `/Âº $&#123;this.â€¢name&#125; ha marcado $&#123;this.ï¼ƒâ€¢goles&#125; goles Âº/`;
            &#125;
          &#125;

          const Ã§player_11 = new Ã§Player('Iker');

          Ã§player_11.â€¢goles = 3;        /*/Âº Uso del setter Âº/*/
          console.log(Ã§player_11.â€¢goles);    /*/Âº Uso del getter Âº/*/
          â‹— /Âº "Iker ha marcado 3 goles" Âº/

          Ã§player_11.â€¢goles = -5;
          â‹— /Âº "No se pueden asignar goles negativos" Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="MÃ©todos de instancia pÃºblicos" codeText="">
        <p class="chaptrSubSect__p">Los <span class="bttn">mÃ©todos de instancia</span> se definen dentro de la clase sin usar <code>static</code> y se llaman a travÃ©s de una instancia. Tienen acceso a las propiedades y mÃ©todos de esa instancia mediante <code>this</code></p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Character &#123;
            constructor(#type) &#123;
              this.â€¢type = #type;
            &#125;

            Âªpresentation() &#123;           /*/Âº MÃ©todo de instancia Âº/*/
              console.log(`/Âº Hola, soy un $&#123;this.â€¢type&#125; Âº/`);
            &#125;

          &#125;;

          Ã§player_1 = new Ã§Character('Humano');
          
          Ã§player_1.Âªpresentation();
          â‹— /Âº "Hola, soy un Humano" Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="MÃ©todos de clase estÃ¡ticos" codeText="static">
        <p class="chaptrSubSect__p">Los mÃ©todos estÃ¡ticos pertenecen a la clase en sÃ­, no a sus instancias. Se llaman directamente desde la clase, y no pueden acceder a <code>this</code> de la instancia (a menos que se pase una instancia como argumento)</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Character &#123;

            constructor(#tipo) &#123;
              this.â€¢tipo = #tipo;
            &#125;

            Âªpresentar() &#123;
              console.log(`/Âº Hola, soy un personaje tipo $&#123;this.â€¢tipo&#125; Âº/`);
            &#125;

            static ÂªtiposDisponibles() &#123;           /*/Âº MÃ©todo de clase estÃ¡tico Âº/*/
              console.log(`/Âº Humano, Robot, Alien, Fantasma Âº/`);
            &#125;

          &#125;;

          const Ã§jugador_1 = new Ã§Character('Humano');

          /*/Âº No podemos acceder al mÃ©todo estÃ¡tico Âº/*/
          Ã§jugador_1.ÂªtiposDisponibles();
          â‹— /Âº TypeError: jugador1.saludarClase is not a function Âº/

          /*/Âº Podemos llamar al mÃ©todo de clase sin crear una instancia Âº/*/
          Ã§Character.ÂªtiposDisponibles();
          â‹— /Âº "Humano, Robot, Alien, Fantasma" Âº/</pre>
        <p class="chaptrSubSect__p">PodrÃ­amos llamar al mÃ©todo de clase estÃ¡tico desde la instancia con el constructor <code>jugador1.constructor.tiposDisponibles()</code> pero es poco comÃºn</p>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Herencia de clase" codeText="">
      <ChaptrSubSect h4Title="DefiniciÃ³n" codeText="">
        <p class="chaptrSubSect__p">La herencia de clase es el modo para que una clase extienda a otra de esta manera podemos aÃ±adir nueva funcionalidad a la ya existente</p>
        <p class="chaptrSubSect__p">Se usa dentro de una subclase para llamar al constructor de la clase padre. Es una herramienta fundamental en la herencia, ya que permite a la subclase inicializar o utilizar las propiedades y mÃ©todos definidos en la clase base</p>
        <p class="chaptrSubSect__p">Se logra con las palabras clave <code>extends</code> y <code>super()</code></p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Herencia de otra clase con" codeText="extends">
        <p class="chaptrSubSect__p">La palabra clave <code>extends</code> se usa para indicar que una clase â€œhijaâ€ hereda las propiedades y mÃ©todos de otra clase â€œpadreâ€</p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Character &#123;
            constructor(#tipo, #nombre) &#123;
              this.â€¢tipo = #tipo;
              this.â€¢nombre = #nombre;
            &#125;

            Âªdescribir() &#123;
              console.log(`/Âº Soy un $&#123;this.tipo&#125; llamado $&#123;this.nombre&#125; Âº/`);
            &#125;
          &#125;

          /*/Âº La clase Hero extiende (hereda de) Character Âº/*/
          class Ã§Hero extends Ã§Character &#123;
            ÂªhabilidadEspecial()&#123;
              console.log(`$&#123;this.nombre&#125; hace imposiciÃ³n manos`)
            &#125;
          &#125;

          const Ã§jugador1 = new Ã§Hero('Humano', 'Ã‰der');
          Ã§jugador1.Âªdescribir();
          â‹— /Âº Soy un Humano llamado Ã‰der Âº/
        
          Ã§jugador1.ÂªhabilidadEspecial();
          â‹— /Âº Ã‰der hace imposiciÃ³n de manos Âº/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Llamar al constructor del padre" codeText="super()">
        <p class="chaptrSubSect__p">Cuando la subclase define su propio constructor, debe llamar al constructor de la clase padre con <code>super()</code></p>
        <pre class="chaptrSubSect__console wScript">
          class Ã§Character &#123;
            constructor(#tipo, #nombre) &#123;
              this.â€¢tipo = #tipo;
              this.â€¢nombre = #nombre;
              this.â€¢salud = Â¬100;
            &#125;

            ÂªrecibirDaÃ±o(#puntos) &#123;
              this.â€¢salud -= #puntos;
              console.log(`/Âº $&#123;this.nombre&#125; recibe $&#123;puntos&#125; puntos de daÃ±o Âº/`);
            &#125;
          &#125;

          /*/Âº Clase hija que aÃ±ade nueva funcionalidad Âº/*/
          class Ã§Hero extends Ã§Character &#123;
            constructor(#tipo, #nombre, #habilidad) &#123;      /*/Âº Llama al constructor de Character Âº/*/
              @super(#tipo, #nombre);
              this.â€¢habilidad = #habilidad;
            &#125;

            ÂªusarHabilidad() &#123;
              console.log(`/Âº $&#123;this.nombre&#125; usa $&#123;this.habilidad&#125;! Âº/`);
            &#125;
          &#125;

          const Ã§jugador1 = new Ã§Hero('/Âº Humano', 'Ã‰der', 'Chutazo Âº/');

          Ã§jugador1.ÂªusarHabilidad();       â‹— /Âº Ã‰der usa Chutazo! Âº/
          Ã§jugador1.ÂªrecibirDaÃ±o(Â¬30);       â‹— /Âº Ã‰der recibe 30 puntos de daÃ±o Âº/
          console.log(Ã§jugador1.â€¢salud);    â‹— /Âº 70 Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="ComprobaciÃ³n de clase" codeText="">
      <ChaptrSubSect h4Title="El operador" codeText="instanceof">
        <p class="chaptrSubSect__p">El operador <code>instanceof</code> permite verificar si un objeto pertenece a una clase determinada. TambiÃ©n tiene en cuenta la herencia, en resumen, no solo verifica la clase directa, sino que tambiÃ©n recorre toda la cadena de prototipos para verificar si un objeto es una instancia de una clase o cualquiera de sus padres. Por eso, tanto <code>Hero</code> como <code>Character</code> devuelven <code>true</code></p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº Clase Padre Âº/*/
          class Ã§Character &#123;
            /Âº ..resto de cÃ³digo...Âº/
          &#125;;

          /*/Âº Clase Hija que hereda de Character Âº/*/
          class Ã§Hero extends Ã§Character &#123;
              /Âº ...resto de cÃ³digo... Âº/
          &#125;;

          const Ã§player1 = new Ã§Hero();

          console.log(Ã§player1 instanceof Ã§Hero);
          â‹— /Âº true Âº/
          console.log(Ã§player1 instanceof Ã§Character);
          â‹— /Âº true Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
    <ChaptrSect h3Title="Mixins" codeText="">
      <ChaptrSubSect h4Title="Los mixins" codeText="">
        <p class="chaptrSubSect__p">Un <mark>mixin</mark> es un objeto o funciÃ³n que contiene mÃ©todos o propiedades que pueden aÃ±adirse a una clase existente, sin usar herencia. Sirve para reutilizar cÃ³digo entre distintas clases sin necesidad de que una herede de otra.</p>
        <p class="chaptrSubSect__p">Supongamos que tenemos una clase <code>Character</code>, y queremos que algunos personajes puedan volar o nadar, pero no todos. En lugar de crear varias subclases (FlyingHero, SwimmingHeroâ€¦), podemos usar un mixin para â€œaÃ±adirâ€ esas habilidades.</p>
        <pre class="chaptrSubSect__console wScript">
          /*/Âº Mixin (objeto) con nuevas habilidades Âº/*/
          const Ã§habilidadesMixin = &#123;
            Âªvolar() &#123;
              console.log(`/Âº $&#123;this.nombre&#125; vuela por los cielos ğŸ•Šï¸ Âº/`);
            &#125;,
            Âªnadar() &#123;
              console.log(`/Âº $&#123;this.nombre&#125; nada en el agua ğŸŒŠ Âº/`);
            &#125;
          &#125;;

          /*/Âº Clase base Âº/*/
          class Ã§Character &#123;
            constructor(#tipo, #nombre) &#123;
              this.â€¢tipo = #tipo;
              this.â€¢nombre = #nombre;
              this.â€¢salud = Â¬100;
            &#125;

            Âªdescribir() &#123;
              console.log(`/Âº Soy un $&#123;this.tipo&#125; llamado $&#123;this.nombre&#125; Âº/`);
            &#125;
          &#125;

          /*/Âº Clase hija Âº/*/
          class Ã§Hero extends Ã§Character &#123;
            ÂªusarHabilidad() &#123;
              console.log(`/Âº $&#123;this.nombre&#125; usa su habilidad especial âš¡ Âº/`);
            &#125;
          &#125;

          /*/Âº Mezclamos las habilidades del mixin en la clase Hero Âº/*/
          Object.Âªassign(Ã§Hero.â€¢prototype, Ã§habilidadesMixin);

          /*/Âº Creamos un personaje Âº/*/
          const Ã§jugador1 = new Ã§Hero('Humano', 'Ã‰der');

          /*/Âº Usamos mÃ©todos de distintos orÃ­genes Âº/*/
          Ã§jugador1.Âªdescribir(); /*/Âº heredado de Character Âº/*/
          â‹— /Âº Soy un Humano llamado Ã‰der Âº/
          Ã§jugador1.ÂªusarHabilidad(); /*/Âº propio de Hero Âº/*/
          â‹— /Âº Ã‰der usa su habilidad especial âš¡ Âº/
          Ã§jugador1.Âªvolar(); /*/Âº aÃ±adido por el mixin Âº/*/
          â‹— /Âº Ã‰der vuela por los cielos ğŸ•Šï¸ Âº/
          Ã§jugador1.Âªnadar(); /*/Âº aÃ±adido por el mixin Âº/*/
          â‹— /Âº Ã‰der nada en el agua ğŸŒŠ Âº/</pre>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_22" nextPage="/lessons/lesson_26"/>
</MainLayout>






<!-- 
&lt;&gt;
()&#123;&#125;
ï¹›ï¹œ    Llaves no estiladas
ï¹•     2 puntos no estilizados
ÂªmÃ©todos
â€¢parametro
Â·variable
#variable en Func/if/for
Ã§Objetos
â‹— âˆResultado
@funcion()
Â¬numbers
objProperty:
ÂºobjProperty
/* comentario */
'/Âº modo texto quita span Âº/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">
ï¼ƒ
ï¹˜
-->
