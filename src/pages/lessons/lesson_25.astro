---
import MainLayout from "@/layouts/MainLayout.astro"
import Footer from "@/components/Footer.astro"
import LssnArt from "@/components/LssnArt.astro"
import ChaptrSect from "@/components/ChaptrSect.astro"
import ChaptrSubSect from "@/components/ChaptrSubSect.astro"
---
<MainLayout>
  <LssnArt artClass="lssn__25" h2Title="Closures" slot="mainContent">
    <ChaptrSect h3Title="Los Clousures" codeText="">
      <ChaptrSubSect h4Title="Explicación" codeText="">
        <p class="chaptrSubSect__p">Un <mark>closure</mark> es una función que "recuerda" el entorno en el que fue creada, incluso después de que ese entorno haya terminado de ejecutarse. Imagina que tienes una función dentro de otra función. La función interna tiene acceso a las variables de la función externa, aunque esta última ya haya finalizado su ejecución. Este "acceso a las variables de la función externa" es lo que hace que un <mark>closure</mark> funcione</p>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Funciones anidadas" codeText="">
        <p class="chaptrSubSect__p">Una función dentro de otra función, pueden producir nuevos ámbitos o scopes para las variables que hay dentro de ellas, y para poder acceder desde fuera de la función a esas variables tenemos que utilizar el doble paréntesis <code>()()</code></p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Variable global º/*/
          const ·saludoInicial = '¡Hola, ';

          function @crearSaludo() &#123;
            const ·pregunta = '¿cómo estás';      /*/º Variable local º/*/
            function @mensajeFinal() &#123;           /*/º Función interna º/*/
              const ·cierre = '/º ? º/';                  /*/º Variable local en función interna º/*/
              return `/º $&#123;·saludoInicial&#125; $&#123;·pregunta&#125; $&#123;·cierre&#125; º/`;
            &#125;
            return ·mensajeFinal;     /* Retorna función interna sin ejecutarla */
          &#125;;
          
          @crearSaludo();     /*/º crearSaludo() devuelve la función interna º/*/
          ⋗  /º ƒ mensajeFinal() º/
          
          @crearSaludo()();     /*/º Para ejecutarla, usamos un segundo paréntesis º/*/
          ⋗  /º"¡Hola, ¿cómo estás?"º/</pre>
        <p class="chaptrSubSect__p">Desglosando lo que pasa</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">La función <code>crearSaludo()</code> retorna la función <code>local</code> en sí (su código), no su resultado.</li>
          <li class="chaptrSubSectUl__li">La función <code>mensajeFinal()</code> es la más interna, tiene acceso a: <code>saludoInicial</code>, <code>pregunta</code> y <code>cierre</code>.</li>
          <li class="chaptrSubSectUl__li">Si llamamos a <code>crearSaludo()</code> nos retornará el código de la función <code>local</code>, por lo que para ejecutarla necesitamos el doble paréntesis <code>()()</code>.</li>
        </ul>
        <p class="chaptrSubSect__p">Para evitar el doble paréntesis <code>()()</code> podemos crear una constante y asignarle la llamada a la función <code>globlal</code> para luego ejecutar esa variable recien creada con sólo 1 paréntesis</p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Asignamos a una variable la función global º/*/
          const ·saludar = @crearSaludo();

          /*/º Ahora podemos ejecutar la función interna con un solo paréntesis º/*/
          ·saludar();
          ⋗  /º"¡Hola, ¿cómo estás?"º/</pre>
        <p class="chaptrSubSect__p">Esto ya se acerca a lo que es un <mark>closure</mark></p>
        <p class="chaptrSubSect__p">Los closures son invisibles en el código, pero el motor de JavaScript los mantiene en memoria para que las funciones internas puedan seguir accediendo a las variables externas. Podemos “ver” ese contexto oculto con <code>console.dir()</code></p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Asignamos a una variable la función global º/*/
          const ·saludar = @crearSaludo();

          /*/º Vemos el contexto oculto con console.dir() º/*/
          @console.ªdir(·saludar);
            /ºlength: 0º/
            /ºname: "mensajeFinal"º/
            /ºprototype: &#123;&#125;º/
            /ºarguments: nullº/
            /ºcaller: nullº/
            /º[[FunctionLocation]]: VM772:8º/
            /º[Prototype]: ƒ ()º/
            /º[[Scopes]]: Scopes[3]º/
              /º0: Closure (crearSaludo)&#123;pregunta: '¿cómo estás'&#125;º/
              /º1: Script &#123;saludoInicial: '¡Hola,', saludar: ƒ ()&#125;º/
              /º2: Global &#123;window: window, d0cument: document, name: " "&#125;º/</pre>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Closures" codeText="">
        <p class="chaptrSubSect__p">Supongamos que tienes una función que devuelve otra función</p>
        <pre class="chaptrSubSect__console wScript">
          function @saludo(·nombre) &#123;
            /*/º La función interna es un closure º/*/
            return function @decirHola() &#123;
              return `/º ¡Hola, $&#123;·nombre&#125;! º/`;
            &#125;;
          &#125;

          /*/º Llamamos a la función saludo y guardamos el resultado en una variable º/*/
          const ·saludarEder = @saludo('Éder');

          /*/º Ejecutamos la función devuelta por saludo() º/*/
          ·saludarEder();
          ⋗  /º"¡Hola, Éder!"º/</pre>
        <p class="chaptrSubSect__p">Desglosando lo que pasa</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Llamamos a la función <code>saludo('Éder')</code>. Esta función toma el argumento <code>'Éder'</code> y devuelve una nueva función.</li>
          <li class="chaptrSubSectUl__li">La nueva función que devuelve tiene acceso a la variable <code>nombre</code> aunque la función <code>saludo</code> ya haya terminado de ejecutarse.</li>
          <li class="chaptrSubSectUl__li">Cuando llamas a <code>saludarEder()</code>, que es la función devuelta, todavía puede acceder al valor de <code>nombre</code> que se le pasó originalmente (en este caso, <code>'Éder'</code>).</li>
        </ul>
        <p class="chaptrSubSect__p">Es una función que encapsula una serie de variables y definiciones locales que unicamente serán accesibles si son devueltas con el operador <code>return</code>, esto nos permite en cierto modo tener variables <strong>privadas</strong>. Esto se utilizaba antes de la llegada de las <mark>Clases</mark> ya que los <mark>closures</mark> se acercan bastante a la definición de <mark>Clase</mark> como por ejemplo en lenguajes como Java</p>
        <pre class="chaptrSubSect__console wScript">
          const ·miContador = (@function() &#123;
            let _contador = ¬0;     /*/º Variable privada, solo accesible dentro del closure º/*/

            function @incrementar() &#123;      /*/º Función incrementadora º/*/
              return _contador++;
            &#125;

            function @decrementar() &#123;      /*/º Función decrementadora º/*/
              return _contador--;
            &#125;

            function @obtenerValor() &#123;     /*/º Función info valor actual º/*/
              return _contador;
            &#125;
            
            return &#123;       /*/º Retornamos un objeto con los métodos públicos º/*/
              @incrementar,
              @decrementar,
              @obtenerValor
            &#125;;
          &#125;)();

          /*/º Usamos los métodos públicos para interactuar con el contador º/*/
          ·miContador.ªincrementar();
          ·miContador.ªincrementar();
          ·miContador.ªincrementar();
          ·miContador.ªdecrementar();
          ·miContador.ªobtenerValor();
          ⋗  /º 2 º/</pre>
        <p class="chaptrSubSect__p">Desglosando lo que pasa</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li">Después de crear todas las funciones, envolvemos la princial entre paréntesis y le añadimos dos más para que se auto-ejecute</li>
          <li class="chaptrSubSectUl__li">No podremos acceder a la variable <code>_contador</code> a menos que sea desde dentro de la <mark>closure</mark></li>
          <li class="chaptrSubSectUl__li">Si llamamos a <code>miContador()</code> nos retornará el código de las funciones.</li>
          <li class="chaptrSubSectUl__li">El motivo por el que se llama como si fueran métodos de objeto es porque en realidad se devuelve un objeto en el <code>return</code> principal de la función principal.</li>
        </ul>
      </ChaptrSubSect>
      <ChaptrSubSect h4Title="Interview Closures" codeText="">
        <p class="chaptrSubSect__p">Una de las preguntas estrella en las entrevistas es como se comporta el scope y porque este ciclo <code>for</code> si se usa <code>var</code> da un resultado y si se usa <code>let</code> da otro</p>
        <pre class="chaptrSubSect__console wScript">
          /*/º Usando let º/*/
          for(let #i = ¬0; #i &lt; ¬3; #i++) &#123;
            @setTimeout(() =&gt; &#123;
              console.log(#i)
            &#125;, ¬3000)
          &#125;

          ⋗ 0
          ⋗ 1
          ⋗ 2</pre>
        <p class="chaptrSubSect__p">Desglosando lo que pasa con <code>let</code></p>
        <p class="chaptrSubSect__p">Cada vez que comienza una nueva iteración del bucle, <code>let</code> crea una nueva variable <code>i</code> dentro de su propio ámbito (scope). Piensa en cada iteración como si JavaScript guardara una “cajita privada” con el valor actual de <code>i</code> y el código del <code>setTimeout</code>.</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><mark>1ª</mark><span class="bttn">Inicialización:</span> Crea la variable <code>i</code> y le asigna el valor <code>0</code>.</li>
          <li class="chaptrSubSectUl__li">Al crearla, también crea una <span class="bttn">caja</span> (scope) privada, y dentro guarda el valor que en ese momento tenía <code>i</code> en este caso <code>0</code>.</li>
          <li class="chaptrSubSectUl__li"><mark>1ª</mark><span class="bttn">Comprobación:</span> Comprueba que <code>i &lt; 3</code> en este caso es <code>true</code> por lo que procede adelante.</li>
          <li class="chaptrSubSectUl__li"><mark>1ª</mark><span class="bttn">Ejecución:</span> Al ejecutar el código, guarda en la caja del <code>let</code> el código del <code>setTimeout</code>, pero todavía no imprime nada porque no ha pasado el tiempo parametrizado.</li>
          <li class="chaptrSubSectUl__li"><mark>1ª</mark><span class="bttn">Actualización:</span> Incrementa a <code>i</code> en 1.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /*/º   ―― Caja 1ª Iteración ――      º/*/
          #i = ¬0;
          @setTimeout(() =&gt; &#123;
            console.log(#i)
          &#125;, ¬3000)
          /*/º 3seg para que se "abra la caja" º/*/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><mark>2ª</mark><span class="bttn">Inicialización:</span> Asigna a la variable <code>i</code> el valor recién incrementado, en este caso <code>1</code>.</li>
          <li class="chaptrSubSectUl__li">También crea una <span class="bttn">caja</span> (scope) privada, y dentro guarda el valor que en ese momento tenía <code>i</code> en este caso <code>1</code>.</li>
          <li class="chaptrSubSectUl__li"><mark>2ª</mark><span class="bttn">Comprobación:</span> Comprueba que <code>i &lt; 3</code> en este caso es <code>true</code> por lo que procede adelante.</li>
          <li class="chaptrSubSectUl__li"><mark>2ª</mark><span class="bttn">Ejecución:</span> Al ejecutar el código, guarda en la caja del <code>let</code> el código del <code>setTimeout</code>, pero todavía no imprime nada porque no ha pasado el tiempo parametrizado.</li>
          <li class="chaptrSubSectUl__li"><mark>2ª</mark><span class="bttn">Actualización:</span> Incrementa a <code>i</code> en 1.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /*/º   ―― Caja 2ª Iteración ――      º/*/
          #i = ¬1;
          @setTimeout(() =&gt; &#123;
            console.log(#i)
          &#125;, ¬3000)
          /*/º 3seg para que se "abra la caja" º/*/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><mark>3ª</mark><span class="bttn">Inicialización:</span> Asigna a la variable <code>i</code> el valor recién incrementado, en este caso <code>2</code>.</li>
          <li class="chaptrSubSectUl__li">También crea una <span class="bttn">caja</span> (scope) privada, y dentro guarda el valor que en ese momento tenía <code>i</code> en este caso <code>2</code>.</li>
          <li class="chaptrSubSectUl__li"><mark>3ª</mark><span class="bttn">Comprobación:</span> Comprueba que <code>i &lt; 3</code> en este caso es <code>true</code> por lo que procede adelante.</li>
          <li class="chaptrSubSectUl__li"><mark>3ª</mark><span class="bttn">Ejecución:</span> Al ejecutar el código, guarda en la caja del <code>let</code> el código del <code>setTimeout</code>, pero todavía no imprime nada porque no ha pasado el tiempo parametrizado.</li>
          <li class="chaptrSubSectUl__li"><mark>3ª</mark><span class="bttn">Actualización:</span> Incrementa a <code>i</code> en 1.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /*/º   ―― Caja 3ª Iteración ――      º/*/
          #i = ¬2;
          @setTimeout(() =&gt; &#123;
            console.log(#i)
          &#125;, ¬3000)
          /*/º 3seg para que se "abra la caja" º/*/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><mark>4ª</mark><span class="bttn">Inicialización:</span> Asigna a la variable <code>i</code> el valor recién incrementado, en este caso <code>3</code>.</li>
          <li class="chaptrSubSectUl__li">También crea una <span class="bttn">caja</span> (scope) privada, y dentro guarda el valor que en ese momento tenía <code>i</code> en este caso <code>3</code>.</li>
          <li class="chaptrSubSectUl__li"><mark>4ª</mark><span class="bttn">Comprobación:</span> Comprueba que <code>i &lt; 3</code> en este caso es <code>false</code> por lo que detiene el ciclo y esa caja recién creada la borra el recolector de basura.</li>
          <li class="chaptrSubSectUl__li">Cuando el tiempo del <code>setTimeout</code> ha cumplido, se proceden a "abrir" esas caja e imprimir los <code>console.log</code> con las variables cuyos valores tenían en ese momento que se guardaron.</li>
          <li class="chaptrSubSectUl__li">Primero se abre la caja del <code>setTimeout</code> de la primera iteración con valor <code>0</code>, luego la 2º con valor <code>1</code> y por último la 3º con valor <code>2</code>.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /*/º Usando var º/*/
          for(var #i = ¬0; #i &lt; ¬3; #i++) &#123;
            @setTimeout(() =&gt; &#123;
              console.log(#i)
            &#125;, ¬3000)
          &#125;

          ⋗ 3
          ⋗ 3
          ⋗ 3</pre>
        <p class="chaptrSubSect__p">Desglosando lo que pasa con <code>var</code></p>
        <p class="chaptrSubSect__p">Aquí el comportamiento cambia porque <code>var</code> no tiene ámbito de bloque, sino que su ámbito es global o de función. Por tanto, solo existe una única variable <code>i</code> compartida por todas las iteraciones. No hay “cajitas privadas”</p>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><mark>1ª</mark><span class="bttn">Inicialización:</span> Crea la variable <code>i</code> <mark>global</mark> y le asigna el valor <code>0</code>.</li>
          <li class="chaptrSubSectUl__li"><mark>1ª</mark><span class="bttn">Comprobación:</span> Comprueba que <code>i &lt; 3</code> en este caso es <code>true</code> por lo que procede adelante.</li>
          <li class="chaptrSubSectUl__li"><mark>1ª</mark><span class="bttn">Ejecución:</span> Al ejecutar el código, guarda en un espacio de memoria el código del <code>setTimeout</code>, pero todavía no imprime nada porque no ha pasado el tiempo parametrizado.</li>
          <li class="chaptrSubSectUl__li"><mark>1ª</mark><span class="bttn">Actualización:</span> Incrementa a <code>i</code> en 1.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /*/º   ―― Variable global ――      º/*/
          #i = ¬0;
          @setTimeout(() =&gt; &#123;
            console.log(#i)
          &#125;, ¬3000)
          /*/º 3seg para que se ejecute el setTimeout º/*/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><mark>2ª</mark><span class="bttn">Inicialización:</span> Asigna a la variable <mark>global</mark> <code>i</code> el valor recién incrementado, en este caso <code>1</code>.</li>
          <li class="chaptrSubSectUl__li"><mark>2ª</mark><span class="bttn">Comprobación:</span> Comprueba que <code>i &lt; 3</code> en este caso es <code>true</code> por lo que procede adelante.</li>
          <li class="chaptrSubSectUl__li"><mark>2ª</mark><span class="bttn">Ejecución:</span> Al ejecutar el código, guarda en un espacio de memoria el código del <code>setTimeout</code>, pero todavía no imprime nada porque no ha pasado el tiempo parametrizado.</li>
          <li class="chaptrSubSectUl__li"><mark>2ª</mark><span class="bttn">Actualización:</span> Incrementa a <code>i</code> en 1.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /*/º   ―― Variable global ――      º/*/
          #i = ¬1;
          /* /º Espacio en memoria 2ª iteración º/*/
          @setTimeout(() =&gt; &#123;
            console.log(#i)
          &#125;, ¬3000)
          /*/º 3seg para que se ejecute el setTimeout º/*/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><mark>3ª</mark><span class="bttn">Inicialización:</span> Asigna a la variable <mark>global</mark> <code>i</code> el valor recién incrementado, en este caso <code>2</code>.</li>
          <li class="chaptrSubSectUl__li"><mark>3ª</mark><span class="bttn">Comprobación:</span> Comprueba que <code>i &lt; 3</code> en este caso es <code>true</code> por lo que procede adelante.</li>
          <li class="chaptrSubSectUl__li"><mark>3ª</mark><span class="bttn">Ejecución:</span> Al ejecutar el código, guarda en un espacio de memoria el código del <code>setTimeout</code>, pero todavía no imprime nada porque no ha pasado el tiempo parametrizado.</li>
          <li class="chaptrSubSectUl__li"><mark>3ª</mark><span class="bttn">Actualización:</span> Incrementa a <code>i</code> en 1.</li>
        </ul>
        <pre class="chaptrSubSect__console wScript">
          /*/º   ―― Variable global ――      º/*/
          #i = ¬2;
          /* /º Espacio en memoria 3ª iteración º/*/
          @setTimeout(() =&gt; &#123;
            console.log(#i)
          &#125;, ¬3000)
          /*/º 3seg para que se ejecute el setTimeout º/*/</pre>
        <ul class="chaptrSubSect__ul">
          <li class="chaptrSubSectUl__li"><mark>4ª</mark><span class="bttn">Inicialización:</span> Asigna a la variable <mark>global</mark> <code>i</code> el valor recién incrementado, en este caso <code>3</code>.</li>
          <li class="chaptrSubSectUl__li"><mark>4ª</mark><span class="bttn">Comprobación:</span> Comprueba que <code>i &lt; 3</code> en este caso es <code>false</code> por lo que detiene el ciclo pero hay que recordar que como la variable es <mark>global</mark> se ha actualizado su valor a 3 y es accesible a todo el código, está fuera digamos de una <span class="bttn">caja</span> como hace <code>let</code>.</li>
          <li class="chaptrSubSectUl__li">Cuando el tiempo del <code>setTimeout</code> ha cumplido, se procede a ejecutar el primer <code>setTimeout</code> guardado en esos espacios en memoria. Cuando el primer <code>console.log</code> accede a la variable <code>i</code> busca su valor que es <code>3</code> puesto que no ha estado protegida en una <span class="bttn">caja</span> y ha sido actualizado. Después se ejecutará el segundo con el mismo valor y el tercero igual.</li>
        </ul>
      </ChaptrSubSect>
    </ChaptrSect>
  </LssnArt>
	<Footer slot="mainFooter" prevPage="/lessons/lesson_10" nextPage="/lessons/lesson_12"/>
</MainLayout>






<!-- 
&lt;&gt;          < > no estilados
()&#123;&#125;    ( ) { } no estilados
﹛﹜              { } Llaves no estilados
﹕                : 2 puntos no estilados
＃                # Rejilla no estilada

ªmétodos
•parametro
·variable
#variable en Func/if/for
çObjetos
⋗ Resultado
@funcion()
¬numbers
objProperty:
ºobjProperty
/* comentario */
'/º modo texto quita span º/'
<p class="chaptrSubSect__p">
<pre class="chaptrSubSect__console wScript">
<table class="chaptrSubSect__table">
<ul class="chaptrSubSect__ul">
<li class="chaptrSubSectUl__li">

-->
